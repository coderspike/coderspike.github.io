<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>spike</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-08-04T07:19:28.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>喵两只</title>
    <link href="http://yoursite.com/2016/07/10/%E5%96%B5%E4%B8%A4%E5%8F%AA/"/>
    <id>http://yoursite.com/2016/07/10/喵两只/</id>
    <published>2016-07-10T09:23:06.000Z</published>
    <updated>2016-08-04T07:19:28.000Z</updated>
    
    <content type="html">&lt;p&gt;家里有喵两只，老大名为七喜，老二唤作大白。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;老大型若小虎，老二全身白毛，老大高冷却胆小，老二傻呆还粘人，在不自愿的情况下被迫养之，怎奈随着铲屎量的增加，感情却也日渐深厚。每到夜晚，老大必定嚎之，知其狂思母喵，却怎奈何并无适龄母喵相配，大概过些时日也要阉之，思此不觉伤感，但每逢嚎叫之时，我也必定出手殴之，或以妙鲜包哄之，大抵如此。每逢清晨，老二粘人尤甚，跳上床来，又舔又蹭，嗷嗷声如二三岁的孩童。烦感之时，将其揪起放在地上，二三分钟不到，呼噜声又在耳边响起，媳妇与我都感到无奈却也好笑。转念回想，两个小家伙陪伴我们也已很多时日，也因闹着玩被抓伤，被老二传染了毛癣，也被老大掉的毛弄得不厌其烦。可分别两日心里也不觉会想念。感情的事大都难说，烦感还是喜爱有时候自己也说不清楚。日子继续过，依旧每日喂饭，铲屎，希望两个家伙健康成长。&lt;br&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw1024/bc254b75gw1f5oz242plcj20ow0ion2u.jpg&quot; alt=&quot;七喜&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw1024/bc254b75jw1f5oyxapm1aj21420qojvj.jpg&quot; alt=&quot;大白&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;2016-7-10周日下午于家中&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;家里有喵两只，老大名为七喜，老二唤作大白。&lt;br&gt;
    
    </summary>
    
      <category term="读书-生活" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6-%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>获取iOS设备唯一标识</title>
    <link href="http://yoursite.com/2016/07/07/%E8%8E%B7%E5%8F%96iOS%E8%AE%BE%E5%A4%87%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86/"/>
    <id>http://yoursite.com/2016/07/07/获取iOS设备唯一标识/</id>
    <published>2016-07-07T07:04:26.000Z</published>
    <updated>2016-07-07T08:29:21.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;之前碰到过获取设备唯一标识的情况，很多方法都已经作废了，转载一篇文章，很好的总结了能用的方法。(自己还未测试)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.ximu.site/uuid/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原始文章&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;IDFA&quot;&gt;&lt;a href=&quot;#IDFA&quot; class=&quot;headerlink&quot; title=&quot;IDFA&quot;&gt;&lt;/a&gt;IDFA&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;全名：advertisingIdentifier&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;获取代码：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  #import &amp;lt;AdSupport/AdSupport.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  NSString *adId = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;来源：iOS6.0及以后&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;说明：直译就是广告id， 在同一个设备上的所有App都会取到相同的值，是苹果专门给各广告提供商用来追踪用户而设的，用户可以在 设置|隐私|广告追踪 里重置此id的值，或限制此id的使用，故此id有可能会取不到值，但好在Apple默认是允许追踪的，而且一般用户都不知道有这么个设置，所以基本上用来监测推广效果，是戳戳有余了。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;注意：由于idfa会出现取不到的情况，故绝不可以作为业务分析的主id，来识别用户。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;IDFV&quot;&gt;&lt;a href=&quot;#IDFV&quot; class=&quot;headerlink&quot; title=&quot;IDFV&quot;&gt;&lt;/a&gt;IDFV&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;全名：identifierForVendor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;获取代码： &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString *idfv = [[[UIDevice currentDevice] identifierForVendor] UUIDString]; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;来源：iOS6.0及以后&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;说明：顾名思义，是给Vendor标识用户用的，每个设备在所属同一个Vender的应用里，都有相同的值。其中的Vender是指应用提供商，但准确点说，是通过BundleID的反转的前两部分进行匹配，如果相同就是同一个Vender，例如对于com.taobao.app1, com.taobao.app2 这两个BundleID来说，就属于同一个Vender，共享同一个idfv的值。和idfa不同的是，idfv的值是一定能取到的，所以非常适合于作为内部用户行为分析的主id，来标识用户，替代OpenUDID。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;注意：如果用户将属于此Vender的所有App卸载，则idfv的值会被重置，即再重装此Vender的App，idfv的值和之前不同。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;UUID&quot;&gt;&lt;a href=&quot;#UUID&quot; class=&quot;headerlink&quot; title=&quot;UUID&quot;&gt;&lt;/a&gt;UUID&lt;/h2&gt;&lt;p&gt;我们可以获取到UUID，然后把UUID保存到KeyChain里面。&lt;/p&gt;
&lt;p&gt;这样以后即使APP删了再装回来，也可以从KeyChain中读取回来。使用group还可以可以保证同一个开发商的所有程序针对同一台设备能够获取到相同的不变的UDID。&lt;/p&gt;
&lt;p&gt;但是刷机或重装系统后uuid还是会改变。&lt;/p&gt;
&lt;h3 id=&quot;把下面两个类文件放到你的项目中&quot;&gt;&lt;a href=&quot;#把下面两个类文件放到你的项目中&quot; class=&quot;headerlink&quot; title=&quot;把下面两个类文件放到你的项目中&quot;&gt;&lt;/a&gt;把下面两个类文件放到你的项目中&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;KeychainItemWrapper.h文件  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;********************************&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;lt;UIKit/UIKit.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface KeychainItemWrapper : NSObject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSMutableDictionary *keychainItemData;        // The actual keychain item data backing store.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSMutableDictionary *genericPasswordQuery;    // A placeholder for the generic keychain item query used to locate the item.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, retain) NSMutableDictionary *keychainItemData;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, retain) NSMutableDictionary *genericPasswordQuery;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Designated initializer.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (id)initWithAccount:(NSString *)account service:(NSString *)service accessGroup:(NSString *) accessGroup;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (id)initWithIdentifier: (NSString *)identifier accessGroup:(NSString *) accessGroup;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)setObject:(id)inObject forKey:(id)key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (id)objectForKey:(id)key;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Initializes and resets the default generic keychain item data.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)resetKeychainItem;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;KeychainItemWrapper.h文件  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;********************************&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;KeychainItemWrapper.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;lt;Security/Security.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;These are the default constants and their respective types,  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;available for the kSecClassGenericPassword Keychain Item class:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kSecAttrAccessGroup            -       CFStringRef  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kSecAttrCreationDate        -       CFDateRef  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kSecAttrModificationDate    -        CFDateRef  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kSecAttrDescription            -       CFStringRef  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kSecAttrComment                -       CFStringRef  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kSecAttrCreator                -       CFNumberRef  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kSecAttrType                -        CFNumberRef  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kSecAttrLabel                -       CFStringRef  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kSecAttrIsInvisible            -       CFBooleanRef  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kSecAttrIsNegative            -       CFBooleanRef  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kSecAttrAccount                -       CFStringRef  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kSecAttrService                -       CFStringRef  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;kSecAttrGeneric                -       CFDataRef&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;See the header file Security/SecItem.h for more details.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface KeychainItemWrapper (PrivateMethods)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;/*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The decision behind the following two methods (secItemFormatToDictionary and dictionaryToSecItemFormat) was  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;to encapsulate the transition between what the detail view controller was expecting (NSString *) and what the  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Keychain API expects as a validly constructed container class.  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (NSMutableDictionary *)secItemFormatToDictionary:(NSDictionary *)dictionaryToConvert;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (NSMutableDictionary *)dictionaryToSecItemFormat:(NSDictionary *)dictionaryToConvert;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Updates the item in the keychain, or adds it if it doesn&amp;apos;t exist.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)writeToKeychain;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation KeychainItemWrapper&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@synthesize keychainItemData, genericPasswordQuery;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (id)initWithAccount:(NSString *)account service:(NSString *)service accessGroup:(NSString *) accessGroup;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (self = [super init])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSAssert(account != nil || service != nil, @&amp;quot;Both account and service are nil.  Must specifiy at least one.&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // Begin Keychain search setup. The genericPasswordQuery the attributes kSecAttrAccount and&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // kSecAttrService are used as unique identifiers differentiating keychain items from one another&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        genericPasswordQuery = [[NSMutableDictionary alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [genericPasswordQuery setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [genericPasswordQuery setObject:account forKey:(id)kSecAttrAccount];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [genericPasswordQuery setObject:service forKey:(id)kSecAttrService];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // The keychain access group attribute determines if this item can be shared&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // amongst multiple apps whose code signing entitlements contain the same keychain access group.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (accessGroup != nil)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#if TARGET_IPHONE_SIMULATOR&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // Ignore the access group if running on the iPhone simulator.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // Apps that are built for the simulator aren&amp;apos;t signed, so there&amp;apos;s no keychain access group&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // for the simulator to check. This means that all apps can see all keychain items when run&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // on the simulator.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // simulator will return -25243 (errSecNoAccessForItem).&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [genericPasswordQuery setObject:accessGroup forKey:(id)kSecAttrAccessGroup];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#endif&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // Use the proper search constants, return only the attributes of the first match.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [genericPasswordQuery setObject:(id)kSecMatchLimitOne forKey:(id)kSecMatchLimit];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [genericPasswordQuery setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnAttributes];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSDictionary *tempQuery = [NSDictionary dictionaryWithDictionary:genericPasswordQuery];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSMutableDictionary *outDictionary = nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (! SecItemCopyMatching((CFDictionaryRef)tempQuery, (CFTypeRef *)&amp;amp;outDictionary) == noErr)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // Stick these default values into keychain item if nothing found.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [self resetKeychainItem];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //Adding the account and service identifiers to the keychain&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [keychainItemData setObject:account forKey:(id)kSecAttrAccount];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [keychainItemData setObject:service forKey:(id)kSecAttrService];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if (accessGroup != nil)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#if TARGET_IPHONE_SIMULATOR&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                // Ignore the access group if running on the iPhone simulator.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                //&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                // Apps that are built for the simulator aren&amp;apos;t signed, so there&amp;apos;s no keychain access group&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                // for the simulator to check. This means that all apps can see all keychain items when run&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                // on the simulator.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                //&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                // simulator will return -25243 (errSecNoAccessForItem).&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                [keychainItemData setObject:accessGroup forKey:(id)kSecAttrAccessGroup];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#endif&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // load the saved data from Keychain.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self.keychainItemData = [self secItemFormatToDictionary:outDictionary];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [outDictionary release];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return self;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (id)initWithIdentifier: (NSString *)identifier accessGroup:(NSString *) accessGroup;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (self = [super init])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // Begin Keychain search setup. The genericPasswordQuery leverages the special user&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // defined attribute kSecAttrGeneric to distinguish itself between other generic Keychain&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // items which may be included by the same application.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        genericPasswordQuery = [[NSMutableDictionary alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [genericPasswordQuery setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [genericPasswordQuery setObject:identifier forKey:(id)kSecAttrGeneric];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // The keychain access group attribute determines if this item can be shared&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // amongst multiple apps whose code signing entitlements contain the same keychain access group.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (accessGroup != nil)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#if TARGET_IPHONE_SIMULATOR&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // Ignore the access group if running on the iPhone simulator.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // Apps that are built for the simulator aren&amp;apos;t signed, so there&amp;apos;s no keychain access group&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // for the simulator to check. This means that all apps can see all keychain items when run&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // on the simulator.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            //&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // simulator will return -25243 (errSecNoAccessForItem).&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#else            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [genericPasswordQuery setObject:accessGroup forKey:(id)kSecAttrAccessGroup];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#endif&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // Use the proper search constants, return only the attributes of the first match.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [genericPasswordQuery setObject:(id)kSecMatchLimitOne forKey:(id)kSecMatchLimit];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [genericPasswordQuery setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnAttributes];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSDictionary *tempQuery = [NSDictionary dictionaryWithDictionary:genericPasswordQuery];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSMutableDictionary *outDictionary = nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (! SecItemCopyMatching((CFDictionaryRef)tempQuery, (CFTypeRef *)&amp;amp;outDictionary) == noErr)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // Stick these default values into keychain item if nothing found.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [self resetKeychainItem];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // Add the generic attribute and the keychain access group.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [keychainItemData setObject:identifier forKey:(id)kSecAttrGeneric];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            if (accessGroup != nil)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#if TARGET_IPHONE_SIMULATOR&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                // Ignore the access group if running on the iPhone simulator.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                // &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                // Apps that are built for the simulator aren&amp;apos;t signed, so there&amp;apos;s no keychain access group&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                // for the simulator to check. This means that all apps can see all keychain items when run&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                // on the simulator.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                //&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                // simulator will return -25243 (errSecNoAccessForItem).&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#else            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                [keychainItemData setObject:accessGroup forKey:(id)kSecAttrAccessGroup];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#endif&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            // load the saved data from Keychain.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self.keychainItemData = [self secItemFormatToDictionary:outDictionary];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [outDictionary release];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return self;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)dealloc&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [keychainItemData release];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [genericPasswordQuery release];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [super dealloc];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)setObject:(id)inObject forKey:(id)key &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (inObject == nil) return;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    id currentObject = [keychainItemData objectForKey:key];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (![currentObject isEqual:inObject])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [keychainItemData setObject:inObject forKey:key];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [self writeToKeychain];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (id)objectForKey:(id)key&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return [keychainItemData objectForKey:key];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)resetKeychainItem&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    OSStatus junk = noErr;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (!keychainItemData) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.keychainItemData = [[NSMutableDictionary alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    else if (keychainItemData)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSMutableDictionary *tempDictionary = [self dictionaryToSecItemFormat:keychainItemData];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        junk = SecItemDelete((CFDictionaryRef)tempDictionary);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSAssert( junk == noErr || junk == errSecItemNotFound, @&amp;quot;Problem deleting current dictionary.&amp;quot; );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Default attributes for keychain item.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [keychainItemData setObject:@&amp;quot;&amp;quot; forKey:(id)kSecAttrAccount];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [keychainItemData setObject:@&amp;quot;&amp;quot; forKey:(id)kSecAttrLabel];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [keychainItemData setObject:@&amp;quot;&amp;quot; forKey:(id)kSecAttrDescription];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Default data for keychain item.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [keychainItemData setObject:@&amp;quot;&amp;quot; forKey:(id)kSecValueData];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (NSMutableDictionary *)dictionaryToSecItemFormat:(NSDictionary *)dictionaryToConvert&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // The assumption is that this method will be called with a properly populated dictionary&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // containing all the right key/value pairs for a SecItem.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Create a dictionary to return populated with the attributes and data.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSMutableDictionary *returnDictionary = [NSMutableDictionary dictionaryWithDictionary:dictionaryToConvert];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Add the Generic Password keychain item class attribute.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [returnDictionary setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Convert the NSString to NSData to meet the requirements for the value type kSecValueData.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // This is where to store sensitive data that should be encrypted.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSString *passwordString = [dictionaryToConvert objectForKey:(id)kSecValueData];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [returnDictionary setObject:[passwordString dataUsingEncoding:NSUTF8StringEncoding] forKey:(id)kSecValueData];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return returnDictionary;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (NSMutableDictionary *)secItemFormatToDictionary:(NSDictionary *)dictionaryToConvert&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // The assumption is that this method will be called with a properly populated dictionary&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // containing all the right key/value pairs for the UI element.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Create a dictionary to return populated with the attributes and data.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSMutableDictionary *returnDictionary = [NSMutableDictionary dictionaryWithDictionary:dictionaryToConvert];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Add the proper search key and class attribute.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [returnDictionary setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnData];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [returnDictionary setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // Acquire the password data from the attributes.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSData *passwordData = NULL;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (SecItemCopyMatching((CFDictionaryRef)returnDictionary, (CFTypeRef *)&amp;amp;passwordData) == noErr)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // Remove the search, class, and identifier key/value, we don&amp;apos;t need them anymore.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [returnDictionary removeObjectForKey:(id)kSecReturnData];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // Add the password to the dictionary, converting from NSData to NSString.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSString *password = [[[NSString alloc] initWithBytes:[passwordData bytes] length:[passwordData length] &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                                                     encoding:NSUTF8StringEncoding] autorelease];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [returnDictionary setObject:password forKey:(id)kSecValueData];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // Don&amp;apos;t do anything if nothing is found.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSAssert(NO, @&amp;quot;Serious error, no matching item found in the keychain.\n&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [passwordData release];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return returnDictionary;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)writeToKeychain&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSDictionary *attributes = NULL;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSMutableDictionary *updateItem = NULL;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    OSStatus result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (SecItemCopyMatching((CFDictionaryRef)genericPasswordQuery, (CFTypeRef *)&amp;amp;attributes) == noErr)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // First we need the attributes from the Keychain.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        updateItem = [NSMutableDictionary dictionaryWithDictionary:attributes];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // Second we need to add the appropriate search key/values.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [updateItem setObject:[genericPasswordQuery objectForKey:(id)kSecClass] forKey:(id)kSecClass];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // Lastly, we need to set up the updated attribute list being careful to remove the class.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSMutableDictionary *tempCheck = [self dictionaryToSecItemFormat:keychainItemData];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [tempCheck removeObjectForKey:(id)kSecClass];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#if TARGET_IPHONE_SIMULATOR&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // Remove the access group if running on the iPhone simulator.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // Apps that are built for the simulator aren&amp;apos;t signed, so there&amp;apos;s no keychain access group&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // for the simulator to check. This means that all apps can see all keychain items when run&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // on the simulator.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // simulator will return -25243 (errSecNoAccessForItem).&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // The access group attribute will be included in items returned by SecItemCopyMatching,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // which is why we need to remove it before updating the item.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [tempCheck removeObjectForKey:(id)kSecAttrAccessGroup];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#endif&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // An implicit assumption is that you can only update a single item at a time.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result = SecItemUpdate((CFDictionaryRef)updateItem, (CFDictionaryRef)tempCheck);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSAssert( result == noErr, @&amp;quot;Couldn&amp;apos;t update the Keychain Item.&amp;quot; );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    else&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        // No previous item found; add the new one.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result = SecItemAdd((CFDictionaryRef)[self dictionaryToSecItemFormat:keychainItemData], NULL);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSAssert( result == noErr, @&amp;quot;Couldn&amp;apos;t add the Keychain Item.&amp;quot; );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;我们在写一个工具类用来保存UUID到keychain和从keychain中读取UUID.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现代码&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;AppUntils.m文件  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*********************&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import  &amp;lt;Security/Security.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;KeychainItemWrapper.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark - 保存和读取UUID&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+(void)saveUUIDToKeyChain&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    KeychainItemWrapper *keychainItem = [[KeychainItemWrapper alloc] initWithAccount:@&amp;quot;Identfier&amp;quot; service:@&amp;quot;AppName&amp;quot; accessGroup:nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSString *string = [keychainItem objectForKey: (__bridge id)kSecAttrGeneric];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if([string isEqualToString:@&amp;quot;&amp;quot;] || !string)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [keychainItem setObject:[self getUUIDString] forKey:(__bridge id)kSecAttrGeneric];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+(NSString *)readUUIDFromKeyChain&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    KeychainItemWrapper *keychainItemm = [[KeychainItemWrapper alloc] initWithAccount:@&amp;quot;Identfier&amp;quot; service:@&amp;quot;AppName&amp;quot; accessGroup:nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSString *UUID = [keychainItemm objectForKey: (__bridge id)kSecAttrGeneric];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return UUID;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (NSString *)getUUIDString&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CFUUIDRef uuidRef = CFUUIDCreate(kCFAllocatorDefault);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CFStringRef strRef = CFUUIDCreateString(kCFAllocatorDefault , uuidRef);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSString *uuidString = [(__bridge NSString*)strRef stringByReplacingOccurrencesOfString:@&amp;quot;-&amp;quot; withString:@&amp;quot;&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CFRelease(strRef);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CFRelease(uuidRef);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return uuidString;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;读取UUID&lt;br&gt;在需要读取的地方直接调用AppUtils的类方法readUUIDFromKeyChain即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注意&lt;/p&gt;
&lt;h3 id=&quot;1-设置非ARC编译环境&quot;&gt;&lt;a href=&quot;#1-设置非ARC编译环境&quot; class=&quot;headerlink&quot; title=&quot;1.设置非ARC编译环境&quot;&gt;&lt;/a&gt;1.设置非ARC编译环境&lt;/h3&gt;&lt;p&gt;因为KeychainItemWrapper.m文件是在非ARC环境下运行的，所以需要设置非arc编译环境， 在Build Phases下选在文件，设置compiler flags:-fno-objc-arc&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;2-让同一开发商的所有APP在同一台设备上获取到UUID相同&quot;&gt;&lt;a href=&quot;#2-让同一开发商的所有APP在同一台设备上获取到UUID相同&quot; class=&quot;headerlink&quot; title=&quot;2. 让同一开发商的所有APP在同一台设备上获取到UUID相同&quot;&gt;&lt;/a&gt;2. 让同一开发商的所有APP在同一台设备上获取到UUID相同&lt;/h3&gt;&lt;p&gt;在每个APP的项目里面做如下设置&lt;/p&gt;
&lt;h4 id=&quot;2-1、设置accessgroup&quot;&gt;&lt;a href=&quot;#2-1、设置accessgroup&quot; class=&quot;headerlink&quot; title=&quot;2.1、设置accessgroup&quot;&gt;&lt;/a&gt;2.1、设置accessgroup&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;keychainItemWrapper *keychainItem = [[KeychainItemWrapper alloc] initWithAccount:@&amp;quot;Identfier&amp;quot; service:@&amp;quot;AppName&amp;quot; accessGroup:@&amp;quot;YOUR_BUNDLE_SEED.com.yourcompany.userinfo&amp;quot;];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;此处设置accessGroup为YOURBUNDLESEED.com.yourcompany.userinfo&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;2-2、创建plist文件&quot;&gt;&lt;a href=&quot;#2-2、创建plist文件&quot; class=&quot;headerlink&quot; title=&quot;2.2、创建plist文件&quot;&gt;&lt;/a&gt;2.2、创建plist文件&lt;/h4&gt;&lt;p&gt;然后在项目相同的目录下创建KeychainAccessGroups.plist文件。&lt;/p&gt;
&lt;p&gt;该文件的结构是一个字典，其中中最顶层的节点必须是一个键为“keychain-access-groups”的Array，并且该Array中每一项都是一个描述分组的NSString。YOURBUNDLESEED.com.yourcompany.userinfo就是要设置的组名。&lt;/p&gt;
&lt;h4 id=&quot;2-3-设置code-signing&quot;&gt;&lt;a href=&quot;#2-3-设置code-signing&quot; class=&quot;headerlink&quot; title=&quot;2.3 设置code signing&quot;&gt;&lt;/a&gt;2.3 设置code signing&lt;/h4&gt;&lt;p&gt;接着在Target—&amp;gt;Build Settings—-&amp;gt;Code Signing栏下的Code Signing Entitlements右侧添加KeychainAccessGroups.plist&lt;/p&gt;
&lt;p&gt;这样就可以保证每个app都是从keychain中读取出来同一个UUID&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;之前碰到过获取设备唯一标识的情况，很多方法都已经作废了，转载一篇文章，很好的总结了能用的方法。(自己还未测试)&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>CALayer</title>
    <link href="http://yoursite.com/2016/07/06/CALayer/"/>
    <id>http://yoursite.com/2016/07/06/CALayer/</id>
    <published>2016-07-06T05:49:55.000Z</published>
    <updated>2016-08-04T02:19:34.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;在iOS中，你能看得见摸得着的东西基本上都是UIView，比如一个按钮、一个文本标签、一个文本输入框、一个图标等等，这些都是UIView。&lt;br&gt;其实UIView之所以能显示在屏幕上，完全是因为它内部的一个图层，在创建UIView对象时，UIView内部会自动创建一个图层(即CALayer对象)，通过UIView的layer属性可以访问这个层&lt;br&gt;@property(nonatomic,readonly,retain) CALayer *layer;&lt;br&gt;当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的图层（CALayer）上，绘图完毕后，系统会将图层拷贝到屏幕上，于是就完成了UIView的显示&lt;br&gt;换句话说，UIView本身不具备显示的功能，拥有显示功能的是它内部的图层。&lt;br&gt;NSObject–&amp;gt;CALayer&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h2&gt;&lt;p&gt;UIView之所以能够显示，完全是因为内部的CALayer对象。因此，通过操作这个CALayer对象，可以很方便地调整UIView的一些界面属性，比如：阴影、圆角大小、边框宽度和颜色等。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例1：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;新建一个项目，在storyboard中添加一个view.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1.通过layer设置边框的宽度和颜色&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;YYViewController.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface YYViewController ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (weak, nonatomic) IBOutlet UIView *customView;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation YYViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [super viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //设置边框的宽度为20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.customView.layer.borderWidth=20;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //设置边框的颜色&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.customView.layer.borderColor=[UIColor greenColor].CGColor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.通过layer设置边框为圆角self.customView.layer.cornerRadius=20;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.在layer上添加一张图片 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;YYViewController.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface YYViewController ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (weak, nonatomic) IBOutlet UIView *customView;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation YYViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [super viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //设置边框的宽度为20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.customView.layer.borderWidth=5;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //设置边框的颜色&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.customView.layer.borderColor=[UIColor blackColor].CGColor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //设置layer的圆角&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.customView.layer.cornerRadius=20;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //在view的图层上添加一个image，contents表示接受内容&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.customView.layer.contents=(id)[UIImage imageNamed:@&amp;quot;me&amp;quot;].CGImage;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;说明：contents是id类型，可以接受内容，上面的实例让layer显示一张图片，仔细观察可以发现四个圆角的部分露了一个角出来。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;产生的原因说明：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;那是因为设置的image不是展示在主图层上的，而是显示在子图层上的。可以通过设置一个范围，设置超出主图层的部分把它给剪切掉。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;有以下两种方法，建议使用layer中的方法（第二种）self.customView.layer.masksToBounds=YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [super viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //设置边框的宽度为20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.customView.layer.borderWidth=5;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //设置边框的颜色&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.customView.layer.borderColor=[UIColor blackColor].CGColor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //设置layer的圆角&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.customView.layer.cornerRadius=20;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //设置超过子图层的部分裁减掉&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //UI框架中使用的方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    self.customView.clipsToBounds=YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.customView.layer.masksToBounds=YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //在view的图层上添加一个image，contents表示接受内容&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.customView.layer.contents=(id)[UIImage imageNamed:@&amp;quot;me&amp;quot;].CGImage;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;注意：layer中不能直接接受UI框架中的东西&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4.设置阴影&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;设置阴影，不光需要设置阴影颜色，还应该设置阴影的偏移位和透明度。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;因为如果不设置偏移位的话，那么阴影和layer完全重叠，且默认透明度为0（即完全透明）。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [super viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //设置阴影的颜色&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.customView.layer.shadowColor=[UIColor blackColor].CGColor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //设置阴影的偏移量，如果为正数，则代表为往右边偏移&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.customView.layer.shadowOffset=CGSizeMake(15, 5);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //设置阴影的透明度(0~1之间，0表示完全透明)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.customView.layer.shadowOpacity=0.6;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;补充说明：如果设置了超过主图层的部分减掉，则设置阴影不会有显示效果。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [super viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //设置边框的宽度为20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.customView.layer.borderWidth=5;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //设置边框的颜色&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.customView.layer.borderColor=[UIColor blackColor].CGColor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //设置layer的圆角&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.customView.layer.cornerRadius=20;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //设置超过子图层的部分裁减掉&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //UI框架中使用的方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //self.customView.clipsToBounds=YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.customView.layer.masksToBounds=YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //在view的图层上添加一个image，contents表示接受内容&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.customView.layer.contents=(id)[UIImage imageNamed:@&amp;quot;me&amp;quot;].CGImage;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //设置阴影的颜色&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.customView.layer.shadowColor=[UIColor blackColor].CGColor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //设置阴影的偏移量，如果为正数，则代表为往右边偏移&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.customView.layer.shadowOffset=CGSizeMake(15, 5);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //设置阴影的透明度(0~1之间，0表示完全透明)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.customView.layer.shadowOpacity=0.6;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;把剪切超出主图层部分的代码注释掉之后的显示效果&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在iOS中，你能看得见摸得着的东西基本上都是UIView，比如一个按钮、一个文本标签、一个文本输入框、一个图标等等，这些都是UIView。&lt;br&gt;其实UIView之所以能显示在屏幕上，完全是因为它内部的一个图层，在创建UIView对象时，UIView内部会自动创建一个图层(即CALayer对象)，通过UIView的layer属性可以访问这个层&lt;br&gt;@property(nonatomic,readonly,retain) CALayer *layer;&lt;br&gt;当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的图层（CALayer）上，绘图完毕后，系统会将图层拷贝到屏幕上，于是就完成了UIView的显示&lt;br&gt;换句话说，UIView本身不具备显示的功能，拥有显示功能的是它内部的图层。&lt;br&gt;NSObject–&amp;gt;CALayer&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS-UI" scheme="http://yoursite.com/categories/iOS-UI/"/>
    
    
  </entry>
  
  <entry>
    <title>布局相关</title>
    <link href="http://yoursite.com/2016/07/04/%E5%B8%83%E5%B1%80%E7%9B%B8%E5%85%B3/"/>
    <id>http://yoursite.com/2016/07/04/布局相关/</id>
    <published>2016-07-04T07:08:43.000Z</published>
    <updated>2016-08-04T01:07:37.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;收录一些关于布局，Masonary，autolayout的相关用法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;iOS 7 以后 View Controller 添加了几个相关的属性来方便我们来做页面布局：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic,assign) UIRectEdge edgesForExtendedLayout NS_AVAILABLE_IOS(7_0); // Defaults to UIRectEdgeAll&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic,assign) BOOL extendedLayoutIncludesOpaqueBars NS_AVAILABLE_IOS(7_0); // Defaults to NO, but bars are translucent by default on 7_0.  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic,assign) BOOL automaticallyAdjustsScrollViewInsets NS_AVAILABLE_IOS(7_0); // Defaults to YES&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* edgesForExtendedLayout&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;通过 edgesForExtendedLayout 这个属性来设置你的 View Controller 页面的哪一侧会延伸至屏幕边缘。可选值有：UIRectEdgeNone、UIRectEdgeTop、UIRectEdgeLeft、UIRectEdgeBottom、UIRectEdgeRight、UIRectEdgeAll。默认值是 UIRectEdgeAll，即 View Controller 的布局是全屏填满。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在有 NavigationBar、TabBar、TooBar 等系统 Bar 的情况下，该属性设置为 UIRectEdgeAll 时，View Controller 的页面会被这些 Bar 盖住部分；而当该属性设为 UIRectEdgeNone 的时候，View Controller 的页面布局会限制在这些 Bar 之间。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;我们可以在 View Controller 的 - (void)viewWillLayoutSubviews 方法中打印出 self.view 的 frame 来观察这个属性带来的影响。我们以 iPhone 4s 的 320*480 的屏幕尺寸为例：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;设置 edgesForExtendedLayout 为 UIRectEdgeAll，不管是有 NavigationBar、TabBar、TooBar 哪一种 Bar，self.view 的 frame 均为 (0, 0, 320, 480)。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;设置 edgesForExtendedLayout 为 UIRectEdgeAll：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;有 NavigationBar 和 TabBar，self.view 的 frame 为 (0, 64, 320, 367)。即 self.view 的布局的起点从 NavigationBar 下开始，高度去掉了 StatusBar、NavigationBar 和 TabBar 的高度：20、44、49。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;有 NavigationBar 和 ToolBar，self.view 的 frame 为 (0, 64, 320, 372)。即 self.view 的布局的起点从 NavigationBar 下开始，高度去掉了 StatusBar、NavigationBar 和 ToolBar 的高度：20、44、44。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;需要注意的是：如果你在 - (void)viewDidLoad 方法中观察 self.view 的 frame 得到的结果始终是 (0, 0, 320, 480)，可见这个值的不对的，所以当我们需要对页面进行布局时正确的方式是在- (void)viewWillLayoutSubviews 中处理。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* extendedLayoutIncludesOpaqueBars&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;extendedLayoutIncludesOpaqueBars 这个属性是对 edgesForExtendedLayout 的补充。它的意思当 NavigationBar、TabBar、TooBar 这些 Bar 不是半透明时(Bar 的 translucent 属性值为 NO)，如果设置 extendedLayoutIncludesOpaqueBars 为 NO，则不会将 View Controller 的页面布局延伸至全屏，如果设置为 YES，则坚持延伸至全屏。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从 iOS 7 开始，NavigationBar、TabBar、TooBar 这些 Bar 默认都是半透明的，这时这个属性不会起到效果。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* automaticallyAdjustsScrollViewInsets&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;当我们采用全屏布局设置了 edgesForExtendedLayout 为 UIRectEdgeAll，而此时 View Controller 的 self.view 的第一个 Subview 是 UIScrollView 类型或其子类型(如：UITableView 等)时，automaticallyAdjustsScrollViewInsets 这个属性就会被用来辅助我们对 UIScrollView 类的视图进行布局。automaticallyAdjustsScrollViewInsets 默认值即为 YES。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;拿 UITableView 来举例，你希望你的 UITableView 的内容从 NavigationBar 底部开始展示(因为不这样的话就会被 NavigationBar 遮住一部分)，同时还需要在滑动时，UITableView 的布局又能填满全屏。这时你只需要设置 automaticallyAdjustsScrollViewInsets 为 YES 即可，系统会帮你调整 UITableView 的 contentInset 来实现效果使其中的内容不会被 NavigationBar、TabBar、TooBar 挡住。你可以同样在 - (void)viewWillLayoutSubviews 观察 UITableView 的 contentInset 的值。当你设置它为 NO 时，UITableView 的 contentInset 则不会被被设置。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;收录一些关于布局，Masonary，autolayout的相关用法&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS-UI" scheme="http://yoursite.com/categories/iOS-UI/"/>
    
    
  </entry>
  
  <entry>
    <title>读如何高效学习</title>
    <link href="http://yoursite.com/2016/07/03/%E8%AF%BB%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2016/07/03/读如何高效学习/</id>
    <published>2016-07-03T01:19:56.000Z</published>
    <updated>2016-08-04T07:19:17.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;这两天粗读了一遍如何高效学习这本书，做个简单的小结。书中提到了很多观点和方法，有很多关于“整体性学习”的阐述，个人在理解上还不算深刻，通过整理书后的小结及日常的应用，希望能对自己的学习生活起到正向作用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;整体性学习策略强调将信息编织到知识网络中，而不是给自己加上机械记忆的负担，这个策略的基础有以下几个方面。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 结构 --- 关于某个学科的知识之间联系的综合，它将是你大脑中的城市。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2 模型 --- 将信息压缩成最基本的单元，模型是结构的种子，形成模型的方法包括比喻法，内在化和图表法，模型是你的知识道路交通图中重要的几个十字路口。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3 高速公路 --- 不同结构之间的联系，有助于创造性思考。“跳出盒子之外思考”很好地描述了这种跳出原有结构，从其他结构来观察原有结构的思考方式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;整体性学习有5个步骤，但是并非按部就班，知识大体按照此顺序进行，不能拘泥于这种顺序。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 获取 --- 通过感官获取信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2 理解 --- 明白信息的表面意思&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3 拓展 --- 与其他信息联系，拓展有三种主要的方式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a 深度拓展 --探究知识背景&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;b 横向拓展 --探究知识关系&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c 纵向拓展 --与其他结构联系后，从其他结构的角度探究知识&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4 纠错 --- 删除错误联系&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5 应用 ---将知识应用到各种情境中去，包括现实生活&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;信息的类型有以下五种：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 随意信息 ： 事实，日期，列表，规则以及某种顺序。信息特点是没有逻辑分类或相互关系不强&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2 观点信息 ： 信息的唯一目的就是支持或者反对某种观点。容量在这是最重要的，而不是能记住&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3 过程信息 ： 它是指某种技能的信息。需要反复练习，但是容易记住&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4 具体信息 ： 容易视觉化的信息，一般是与实际紧密兰溪的信息，容易有自己的经验&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5 抽象信息 ： 信息不容易有自己的经验，数学，哲学，物理学都是非常抽象的领域&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;技术一览：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;快速阅读&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 指读法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 联系阅读&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 积极阅读，改善边度边学习的效率&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;笔记流&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 不要呆板，僵硬，貌似层次分明的记笔记&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 在卸下来的观点之间建立联系&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;比喻法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;寻找历史中的故事，图像或是过程，它与我们现在学习的东西有某种相似性&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;内在化&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 为你正在学习的东西创造脑海中的图像&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 在这幅图像上加入其它感官和情感&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 寻找图像不适用或不足的地方，防止产生错误的联系&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;图表法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;创造流程图，概念图或图像，将若干观念联系在一起&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;联想法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 创造一系列容易视觉化的符号&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 在条目之间创造联系，这种联系是可以“看得见的奇特场景”&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 在第一个条目和触发物之间建立联系&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;挂钩法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;与联想法相似，只不过我们是把每一个条目与事先建立好容易回忆的0-12的视觉符号相联系&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;信息压缩&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;记忆术-- 压缩若干知识，用一个单词代替&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;图像联系-- 创造一幅能联系若干知识的图像&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;笔记压缩-- 用寥寥几页纸缩写内容庞大的笔记&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;实际应用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;寻找将知识用于你的日常生活&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;模型纠错&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;经常性地解决各种问题，以发现整体性知识网络中的潜在错误。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;已项目为基础学习&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;建立一个大约需要1-3个月完成的项目，从而逼迫自己不断的学习，实践和解决各种各样的问题，这对自我教育来说是有用的练习，特别实在没有什么知识结构可以指导时。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;高效率学生&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;管理能量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;· 保持体形，健康饮食，不要熬夜&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;· 一周休息一天&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;· 不要“学习”&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;· 绝不拖延&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 建立每周目标和每日目标清单以保持注意力&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;· 将那些类似的，散在的工作集中起来批量处理&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;· 有组织&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 拥有一个日历和做事清单，永远随身携带一个笔记本&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这两天粗读了一遍如何高效学习这本书，做个简单的小结。书中提到了很多观点和方法，有很多关于“整体性学习”的阐述，个人在理解上还不算深刻，通过整理书后的小结及日常的应用，希望能对自己的学习生活起到正向作用。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="读书-生活" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6-%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>Git相关操作</title>
    <link href="http://yoursite.com/2016/06/30/Git%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2016/06/30/Git相关操作/</id>
    <published>2016-06-30T04:20:39.000Z</published>
    <updated>2016-07-04T08:21:02.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;git使用记录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;创建新项目&quot;&gt;&lt;a href=&quot;#创建新项目&quot; class=&quot;headerlink&quot; title=&quot;创建新项目&quot;&gt;&lt;/a&gt;创建新项目&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1现在git上新建一个项目&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2记住地址：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; 初始化一个readme&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（另外在xcode中创建项目的时候，不要勾选在本地创建git库）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3在系统中新建一个文件夹&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4打开xcode中点击导出项目。导出项目到这个空文件夹，导出路径为上边新建项目时的路径&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5将项目中的文件拷贝到此文件夹中，打开项目提交即可。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;异常&quot;&gt;&lt;a href=&quot;#异常&quot; class=&quot;headerlink&quot; title=&quot;异常&quot;&gt;&lt;/a&gt;异常&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;xcode push时时间很久，然后提示错误&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SecureTransport error: I/O error (bummers) (-1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 确定用户名账户正确 git config --list&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;更改命令：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global user.name username&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global user.email email&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2 确定xcode中的remote地址正确&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3 增加提交量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global http.postBuffer 524288000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;或者&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global http.postBuffer 1048576000&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;git使用记录&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS开发中的数据持久化</title>
    <link href="http://yoursite.com/2016/06/30/iOS%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://yoursite.com/2016/06/30/iOS开发中的数据持久化/</id>
    <published>2016-06-30T03:58:11.000Z</published>
    <updated>2016-07-04T07:39:45.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;详细记录iOS开发中几种常用的持久化方式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;NSUserDefaults&lt;/p&gt;
&lt;p&gt;NSUserDefaults只支持： NSString, NSNumber, NSDate, NSArray, NSDictionary.&lt;br&gt;NSUserDefaults适合存储轻量级的本地数据，比如要保存一个登陆界面的数据，用户名、密码之类的，个人觉得使用NSUserDefaults是首选。下次再登陆的时候就可以直接从NSUserDefaults里面读取上次登陆的信息咯。&lt;br&gt;用NSUserDefaults存储的数据下次程序运行的时候依然存在，它把数据存储在什么地方了？如何能够清除？&lt;br&gt;其实它存储在应用程序内置的一个plist文件里。&lt;/p&gt;
&lt;p&gt;iOS中缓存一定量的数据以便下次可以快速执行，那么数据会存储在什么地方，有多少种存储方式？&lt;br&gt;偏好设置(NSUserDefaults)&lt;br&gt;plist文件存储&lt;br&gt;归档&lt;br&gt;SQLite3&lt;br&gt;Core Data&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;详细记录iOS开发中几种常用的持久化方式&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>第三方框架使用记录</title>
    <link href="http://yoursite.com/2016/06/27/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2016/06/27/第三方框架使用记录/</id>
    <published>2016-06-27T02:19:21.000Z</published>
    <updated>2016-07-12T04:14:46.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;项目开发中会用到很多第三方框架，在此做个记录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;网络类&quot;&gt;&lt;a href=&quot;#网络类&quot; class=&quot;headerlink&quot; title=&quot;网络类&quot;&gt;&lt;/a&gt;网络类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;AFNetworking&lt;br&gt;轻量级的通讯类库，使用非常简单。&lt;br&gt;&lt;a href=&quot;https://github.com/AFNetworking/AFNetworking&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;下载地址&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;SDWebImage&lt;br&gt;调用网站上的图片，跟本地调用内置在应用包里的图片一样简单。操作也很简单。&lt;br&gt;&lt;a href=&quot;https://github.com/rs/SDWebImage&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;下载地址&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;数据类&quot;&gt;&lt;a href=&quot;#数据类&quot; class=&quot;headerlink&quot; title=&quot;数据类&quot;&gt;&lt;/a&gt;数据类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;FMDB&lt;br&gt;fmdb是一个数据库管理库，封装了sqlite相关的sql语句，简化数据库操作。&lt;br&gt;&lt;a href=&quot;https://github.com/ccgus/fmdb&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;下载地址&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;效果类&quot;&gt;&lt;a href=&quot;#效果类&quot; class=&quot;headerlink&quot; title=&quot;效果类&quot;&gt;&lt;/a&gt;效果类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;MBProgressHUD&lt;br&gt;MBProgressHUD就不多说了，加载等待特效框架，伟大的菊花。&lt;br&gt;&lt;a href=&quot;https://github.com/jdg/MBProgressHUD&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;下载地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;MJRefresh&lt;br&gt;下拉刷新，上拉加载的库。&lt;br&gt;&lt;a href=&quot;https://github.com/CoderMJLee/MJRefresh&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;下载地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;MMPopupView&lt;br&gt;一个封装的弹框组件，效果不错。&lt;br&gt;&lt;a href=&quot;https://github.com/adad184/MMPopupView&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;下载地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;PNChart&lt;br&gt;一个封装的图片组件，表现丰富。&lt;br&gt;&lt;a href=&quot;https://github.com/kevinzhow/PNChart&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;下载地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;HMSegmentedControl&lt;br&gt;HMSegmentedControl 是 UISegmentedControl 的替代品。表现效果不错。&lt;br&gt;&lt;a href=&quot;https://github.com/HeshamMegid/HMSegmentedControl&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;下载地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;MMPlaceHolder&lt;br&gt;显示各个UIview的size，用于方便的布局，很好用。&lt;br&gt;&lt;a href=&quot;https://github.com/adad184/MMPlaceHolder&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;下载地址&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;布局类&quot;&gt;&lt;a href=&quot;#布局类&quot; class=&quot;headerlink&quot; title=&quot;布局类&quot;&gt;&lt;/a&gt;布局类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;CYLTabBarController&lt;br&gt;低耦合集成TabBarController，传入几个参数就可以完成主流APP框架的搭建&lt;br&gt;&lt;a href=&quot;https://github.com/ChenYilong/CYLTabBarController&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;下载地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Masonry&lt;br&gt;Masonry是一个轻量级的布局框架 拥有自己的描述语法 采用更优雅的链式语法封装自动布局 简洁明了 并具有高可读性 而且同时支持 iOS 和 Max OS X。&lt;br&gt;&lt;a href=&quot;https://github.com/SnapKit/Masonry&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;下载地址&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;调试类&quot;&gt;&lt;a href=&quot;#调试类&quot; class=&quot;headerlink&quot; title=&quot;调试类&quot;&gt;&lt;/a&gt;调试类&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;CocoaLumberjack&lt;br&gt;CocoaLumberjack是Mac和iOS上一个集快捷、简单、强大和灵活于一身的日志框架。&lt;br&gt;&lt;a href=&quot;https://github.com/CocoaLumberjack/CocoaLumberjack&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;下载地址&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;项目开发中会用到很多第三方框架，在此做个记录。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Objc面试题收录</title>
    <link href="http://yoursite.com/2016/06/24/Objc%E9%9D%A2%E8%AF%95%E9%A2%98%E6%94%B6%E5%BD%95/"/>
    <id>http://yoursite.com/2016/06/24/Objc面试题收录/</id>
    <published>2016-06-24T01:33:55.000Z</published>
    <updated>2016-07-04T07:22:36.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;持续收录一些较经典的面试题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;简单描述一下XIB与Storyboards，说一下他们的优缺点&quot;&gt;&lt;a href=&quot;#简单描述一下XIB与Storyboards，说一下他们的优缺点&quot; class=&quot;headerlink&quot; title=&quot;简单描述一下XIB与Storyboards，说一下他们的优缺点&quot;&gt;&lt;/a&gt;简单描述一下XIB与Storyboards，说一下他们的优缺点&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;优点：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;XIB：在编译前就提供了可视化界面，可以直接拖控件，也可以直接给控件添加约束，更直观一些，而且类文件中就少了创建控件的代码，确实简化不少，通常每个XIB对应一个类。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Storyboard：在编译前提供了可视化界面，可拖控件，可加约束，在开发时比较直观，而且一个storyboard可以有很多的界面，每个界面对应一个类文件，通过storybard，可以直观地看出整个App的结构(事实上故事板是多个xib文件集合的描述文件，也采用xml格式).&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;缺点：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;XIB：需求变动时，需要修改XIB很大，有时候甚至需要重新添加约束，导致开发周期变长。XIB载入相比纯代码自然要慢一些。对于比较复杂逻辑控制不同状态下显示不同内容时，使用XIB是比较困难的。当多人团队或者多团队开发时，如果XIB文件被发动，极易导致冲突，而且解决冲突相对要困难很多。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Storyboard：需求变动时，需要修改storyboard上对应的界面的约束，与XIB一样可能要重新添加约束，或者添加约束会造成大量的冲突，尤其是多团队开发。对于复杂逻辑控制不同显示内容时，比较困难。当多人团队或者多团队开发时，大家会同时修改一个storyboard，导致大量冲突，解决起来相当困难。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;下面四个修饰指针有什么区别&quot;&gt;&lt;a href=&quot;#下面四个修饰指针有什么区别&quot; class=&quot;headerlink&quot; title=&quot;下面四个修饰指针有什么区别?&quot;&gt;&lt;/a&gt;下面四个修饰指针有什么区别?&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const char *p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;char const *p;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;char * const p;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const char * const p;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;参考答案：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;• const char *p定义了一个指向不可变的字符串的字符指针，可以这么看：const char *为类型，p是变量。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;• char const *p与上一个是一样的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;• char * const p定义了一个指向字符串的指针，该指针值不可改变，即不可改变指向。这么看：char *是类型，const是修饰变量p，也就是说p是一个常量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const char * const p定义了一个指向不可变的字符串的字符指针，且该指针也不可改变指向。这一个就很容易看出来了。两个const分别修饰，因此都是不可变的。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;请把字符串2015-04-10格式化日期转为NSDate类型&quot;&gt;&lt;a href=&quot;#请把字符串2015-04-10格式化日期转为NSDate类型&quot; class=&quot;headerlink&quot; title=&quot;请把字符串2015-04-10格式化日期转为NSDate类型&quot;&gt;&lt;/a&gt;请把字符串2015-04-10格式化日期转为NSDate类型&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSString *timeStr = @&amp;quot;2015-04-10&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSDateFormatter *formatter = [[NSDateFormatter alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;formatter.dateFormat = @&amp;quot;yyyy-MM-dd&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;formatter.timeZone = [NSTimeZone defaultTimeZone];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSDate *date = [formatter dateFromString:timeStr];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 2015-04-09 16:00:00 +0000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;%@&amp;quot;, date);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;描述一下iOS的内存管理，在开发中对于内存的使用和优化包含哪些方面。我们在开发中应该注意哪些问题。&quot;&gt;&lt;a href=&quot;#描述一下iOS的内存管理，在开发中对于内存的使用和优化包含哪些方面。我们在开发中应该注意哪些问题。&quot; class=&quot;headerlink&quot; title=&quot;描述一下iOS的内存管理，在开发中对于内存的使用和优化包含哪些方面。我们在开发中应该注意哪些问题。&quot;&gt;&lt;/a&gt;描述一下iOS的内存管理，在开发中对于内存的使用和优化包含哪些方面。我们在开发中应该注意哪些问题。&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;内存管理准则：谁强引用过，谁就在不再使用时使引用计数减一。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;对于内存的使用和优化常见的有以下方面：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;重用问题：如UITableViewCells、UICollectionViewCells、UITableViewHeaderFooterViews设置正确的reuseIdentifier，充分重用。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;尽量把views设置为不透明：当opque为NO的时候，图层的半透明取决于图片和其本身合成的图层为结果，可提高性能。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;不要使用太复杂的XIB/Storyboard：载入时就会将XIB/storyboard需要的所有资源，包括图片全部载入内存，即使未来很久才会使用。那些相比纯代码写的延迟加载，性能及内存就差了很多。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;选择正确的数据结构：学会选择对业务场景最合适的数组结构是写出高效代码的基础。比如，数组: 有序的一组值。使用索引来查询很快，使用值查询很慢，插入/删除很慢。字典: 存储键值对，用键来查找比较快。集合: 无序的一组值，用值来查找很快，插入/删除很快。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;gzip/zip压缩：当从服务端下载相关附件时，可以通过gzip/zip压缩后再下载，使得内存更小，下载速度也更快。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;延迟加载：对于不应该使用的数据，使用延迟加载方式。对于不需要马上显示的视图，使用延迟加载方式。比如，网络请求失败时显示的提示界面，可能一直都不会使用到，因此应该使用延迟加载。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;数据缓存：对于cell的行高要缓存起来，使得reload数据时，效率也极高。而对于那些网络数据，不需要每次都请求的，应该缓存起来，可以写入数据库，也可以通过plist文件存储。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;处理内存警告：一般在基类统一处理内存警告，将相关不用资源立即释放掉&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;重用大开销对象：一些objects的初始化很慢，比如NSDateFormatter和NSCalendar，但又不可避免地需要使用它们。通常是作为属性存储起来，防止反复创建。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;避免反复处理数据：许多应用需要从服务器加载功能所需的常为JSON或者XML格式的数据。在服务器端和客户端使用相同的数据结构很重要。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;使用Autorelease Pool：在某些循环创建临时变量处理数据时，自动释放池以保证能及时释放内存。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;深复制和浅复制的区别：&quot;&gt;&lt;a href=&quot;#深复制和浅复制的区别：&quot; class=&quot;headerlink&quot; title=&quot;深复制和浅复制的区别：&quot;&gt;&lt;/a&gt;深复制和浅复制的区别：&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;浅复制只复制指向对象的指针，而不复制引用对象的本身。深层复制复制对象的本身。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;意思就是说我有个A对象，复制一份后得到A_copy对象，对于浅复制来说，A和A_copy指向的是同一个内存资源，复制的只不过是一个指针，对象本身的资源还是只有一份，当对A_copy执行修改操作时，我们发现A引用的对象同样被修改，深复制对象中存在了两份独立的对象本身，浅复制好比你和你的影子，你完蛋，影子也完蛋，深复制好比克隆人，你完蛋，克隆人还活着。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;===什么情况使用 weak 关键字，相比 assign 有什么不同？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;什么情况使用 weak 关键字？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。在下文也有论述：《IBOutlet连出来的视图属性为什么可以被设置成weak?》&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;不同点：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。 而assign 的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或 NSlnteger 等)的简单赋值操作。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;assigin 可以用非 OC 对象,而 weak 必须用于 OC 对象&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;怎么用-copy-关键字？&quot;&gt;&lt;a href=&quot;#怎么用-copy-关键字？&quot; class=&quot;headerlink&quot; title=&quot;怎么用 copy 关键字？&quot;&gt;&lt;/a&gt;怎么用 copy 关键字？&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;用途：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;block 也经常使用 copy 关键字&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;property-的本质是什么？&quot;&gt;&lt;a href=&quot;#property-的本质是什么？&quot; class=&quot;headerlink&quot; title=&quot;@property 的本质是什么？&quot;&gt;&lt;/a&gt;@property 的本质是什么？&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property = ivar + getter + setter;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;下面解释下：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 Objective-C 2.0 的一部分。 而在正规的 Objective-C 编码风格中，存取方法有着严格的命名规范。 正因为有了这种严格的命名规范，所以 Objective-C 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。 所以你也可以这么说：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property = getter + setter;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;例如下面这个类：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface Person : NSObject@property NSString *firstName;@property NSString *lastName;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;上述代码写出来的类与下面这种写法等效：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface Person : NSObject- (NSString *)firstName;- (void)setFirstName:(NSString *)firstName;- (NSString *)lastName;- (void)setLastName:(NSString *)lastName;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？&quot;&gt;&lt;a href=&quot;#ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？&quot; class=&quot;headerlink&quot; title=&quot;ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？&quot;&gt;&lt;/a&gt;ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;对应基本数据类型默认关键字是atomic,readwrite,assign&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;对于普通的 Objective-C 对象atomic,readwrite,strong&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;一个objc对象的isa的指针指向什么？有什么作用？&quot;&gt;&lt;a href=&quot;#一个objc对象的isa的指针指向什么？有什么作用？&quot; class=&quot;headerlink&quot; title=&quot;一个objc对象的isa的指针指向什么？有什么作用？&quot;&gt;&lt;/a&gt;一个objc对象的isa的指针指向什么？有什么作用？&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;指向他的类对象,从而可以找到对象上的方法&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;objc中的类方法和实例方法有什么本质区别和联系？&quot;&gt;&lt;a href=&quot;#objc中的类方法和实例方法有什么本质区别和联系？&quot; class=&quot;headerlink&quot; title=&quot;objc中的类方法和实例方法有什么本质区别和联系？&quot;&gt;&lt;/a&gt;objc中的类方法和实例方法有什么本质区别和联系？&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;类方法：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	类方法是属于类对象的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	类方法只能通过类对象调用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	类方法中的self是类对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	类方法可以调用其他的类方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	类方法中不能访问成员变量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	类方法中不定直接调用对象方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;实例方法：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	实例方法是属于实例对象的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	实例方法只能通过实例对象调用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	实例方法中的self是实例对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	实例方法中可以访问成员变量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	实例方法中直接调用实例方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	实例方法中也可以调用类方法(通过类名)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;iOS-的沙盒目录结构是怎样的？-App-Bundle-里面都有什么？&quot;&gt;&lt;a href=&quot;#iOS-的沙盒目录结构是怎样的？-App-Bundle-里面都有什么？&quot; class=&quot;headerlink&quot; title=&quot;iOS 的沙盒目录结构是怎样的？ App Bundle 里面都有什么？&quot;&gt;&lt;/a&gt;iOS 的沙盒目录结构是怎样的？ App Bundle 里面都有什么？&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1.沙盒结构&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Application：存放程序源文件，上架前经过数字签名，上架后不可修改&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Documents：常用目录，iCloud备份目录，存放数据,这里不能存缓存文件,否则上架不被通过&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Library&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Caches：存放体积大又不需要备份的数据,SDWebImage缓存路径就是这个&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Preference：设置目录，iCloud会备份设置信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;tmp：存放临时文件，不会被备份，而且这个文件下的数据有可能随时被清除的可能&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.App Bundle 里面有什么&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Info.plist:此文件包含了应用程序的配置信息.系统依赖此文件以获取应用程序的相关信息&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可执行文件:此文件包含应用程序的入口和通过静态连接到应用程序target的代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;资源文件:图片,声音文件一类的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;其他:可以嵌入定制的数据资源&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Objective-C-如何对已有的方法，添加自己的功能代码以实现类似记录日志这样的功能？&quot;&gt;&lt;a href=&quot;#Objective-C-如何对已有的方法，添加自己的功能代码以实现类似记录日志这样的功能？&quot; class=&quot;headerlink&quot; title=&quot;Objective-C 如何对已有的方法，添加自己的功能代码以实现类似记录日志这样的功能？&quot;&gt;&lt;/a&gt;Objective-C 如何对已有的方法，添加自己的功能代码以实现类似记录日志这样的功能？&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;	这题目主要考察的是runtime如何交换方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	先在分类中添加一个方法,注意不能重写系统方法,会覆盖&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	+ (NSString *)myLog&amp;#123;    // 这里写打印行号,什么方法,哪个类调用等等&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	然后交换方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	// 加载分类到内存的时候调用+ (void)load&amp;#123;    // 获取imageWithName方法地址    Method description = class_getClassMethod(self, @selector(description));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	// 获取imageWithName方法地址    Method myLog = class_getClassMethod(self, @selector(myLog));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	// 交换方法地址，相当于交换实现方式    method_exchangeImplementations(description, myLog);&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;strong-weak-unsafe-unretained-的区别？&quot;&gt;&lt;a href=&quot;#strong-weak-unsafe-unretained-的区别？&quot; class=&quot;headerlink&quot; title=&quot;strong / weak / unsafe_unretained 的区别？&quot;&gt;&lt;/a&gt;strong / weak / unsafe_unretained 的区别？&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;weak只能修饰OC对象,使用weak不会使计数器加1,对象销毁时修饰的对象会指向nil&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;strong等价与retain,能使计数器加1,且不能用来修饰数据类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;unsafe_unretained等价与assign,可以用来修饰数据类型和OC对象,但是不会使计数器加1,且对象销毁时也不会将对象指向nil,容易造成野指针错误&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;如何为-Class-定义一个对外只读对内可读写的属性&quot;&gt;&lt;a href=&quot;#如何为-Class-定义一个对外只读对内可读写的属性&quot; class=&quot;headerlink&quot; title=&quot;如何为 Class 定义一个对外只读对内可读写的属性?&quot;&gt;&lt;/a&gt;如何为 Class 定义一个对外只读对内可读写的属性?&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;在头文件中将属性定义为readonly,在.m文件中将属性重新定义为readwrite&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;frame-和-bounds-的区别是什么？&quot;&gt;&lt;a href=&quot;#frame-和-bounds-的区别是什么？&quot; class=&quot;headerlink&quot; title=&quot;frame 和 bounds 的区别是什么？&quot;&gt;&lt;/a&gt;frame 和 bounds 的区别是什么？&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;frame相对于父视图,是父视图坐标系下的位置和大小。bounds相对于自身,是自身坐标系下的位置和大小。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;frame以父控件的左上角为坐标原点，bounds以自身的左上角为坐标原点&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Instancetype&quot;&gt;&lt;a href=&quot;#Instancetype&quot; class=&quot;headerlink&quot; title=&quot;Instancetype:&quot;&gt;&lt;/a&gt;Instancetype:&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@interface NSArray  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (id)constructAnArray;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;当我们使用如下方式初始化NSArray时：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[NSArray constructAnArray];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;根据Cocoa的方法命名规范，得到的返回类型就和方法声明的返回类型一样，是id&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface NSArray  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (instancetype)constructAnArray;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;当使用相同方式初始化NSArray时：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1. [NSArray constructAnArray];  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;得到的返回类型和方法所在类的类型相同，是NSArray*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;instancetype的作用，就是使那些非关联返回类型的方法返回所在类的类型！&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;①instancetype可以返回和方法所在类相同类型的对象，id只能返回未知类型的对象；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;②instancetype只能作为返回值，不能像id那样作为参数，比如下面的写法&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;请简单描述一下队列和多线程的使用原理&quot;&gt;&lt;a href=&quot;#请简单描述一下队列和多线程的使用原理&quot; class=&quot;headerlink&quot; title=&quot;请简单描述一下队列和多线程的使用原理&quot;&gt;&lt;/a&gt;请简单描述一下队列和多线程的使用原理&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;在iOS中队列分为以下几种：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;• 串行队列：队列中的任务只会顺序执行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t q = dispatch_queue_create(&amp;quot;...&amp;quot;, DISPATCH_QUEUE_SERIAL);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;• 并行队列： 队列中的任务通常会并发执行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t q = dispatch_queue_create(&amp;quot;......&amp;quot;, DISPATCH_QUEUE_CONCURRENT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;• 全局队列：是系统的，直接拿过来（GET）用就可以；与并行队列类似&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t q = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;• 主队列：每一个应用程序对应唯一一个主队列，直接GET即可；在多线程开发中，使用主队列更新UI&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t q = dispatch_get_main_queue();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;上面这四种是针对GCD来讲的，串行队列中的任务只能一个个地执行，在前一个没有执行完毕之前，下一个只能等待。并行队列可以并发地执行任务，因此多个任务之间执行的顺序不能确定，当添加一个新的任务时，交由GCD来判断是否要创建新的新的线程。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;static的作用&quot;&gt;&lt;a href=&quot;#static的作用&quot; class=&quot;headerlink&quot; title=&quot;static的作用&quot;&gt;&lt;/a&gt;static的作用&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;这个关键在实际开发中挺常用的。当我们使用实例成员变量不好处理时，我们将声明为静态变量，因此它有以下特性。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;参考答案：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;• 函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;• 在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;• 在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;• 在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;self-super&quot;&gt;&lt;a href=&quot;#self-super&quot; class=&quot;headerlink&quot; title=&quot;self super&quot;&gt;&lt;/a&gt;self super&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;下面的代码输出什么？ &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation Son : Father&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (id)init &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self = [super init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (self) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@&amp;quot;%@&amp;quot;, NSStringFromClass([self class]));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@&amp;quot;%@&amp;quot;, NSStringFromClass([super class]));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return self;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 输出&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSStringFromClass([self class]) = Son&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSStringFromClass([super class]) = Son&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这个题目主要是考察关于Objective-C中对self和super的理解。我们都知道：self是类的隐藏参数，指向当前调用方法的这个类的实例。那super呢？&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;很多人会想当然的认为“super和self类似，应该是指向父类的指针吧！”。这是很普遍的一个误区。其实 super是一个 Magic Keyword，它本质是一个编译器标示符，和self 是指向的同一个消息接受者！他们两个的不同点在于：super会告诉编译器，调用class 这个方法时，要去父类的方法，而不是本类里的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;上面的例子不管调用[self class]还是[super class]，接受消息的对象都是当前 Son ＊xxx 这个对象。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;当使用self调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用super时，则从父类的方法列表中开始找。然后调用父类的这个方法。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;通过self来调用方法时，会转换成：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;id objc_msgSend(id self, SEL op, ...)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;而通过super调用方法时，会转换成：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;id objc_msgSendSuper(struct objc_super *super, SEL op, ...)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;而第一个参数是 objc_super 这样一个结构体，其定义如下:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct objc_super &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       __unsafe_unretained id receiver;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       __unsafe_unretained Class super_class;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;什么是单例，如何设计单例？&quot;&gt;&lt;a href=&quot;#什么是单例，如何设计单例？&quot; class=&quot;headerlink&quot; title=&quot;什么是单例，如何设计单例？&quot;&gt;&lt;/a&gt;什么是单例，如何设计单例？&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;参考答案：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;单例就是全局都只有一个对象存在，而且是在整个App运行过程中都存在。每个App都会有单例，比如UIApplication。而我们在做用户数据存储时，通常都会用单例存储，因为应用在所有操作中，经常要求先登录。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;下面这种写法是最常用的写法，这个是线程安全的。 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (instancetype)shared &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  static HYBUserManager *sg_userManager = nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  static dispatch_once_t onceToken;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  dispatch_once(&amp;amp;onceToken, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (sg_userManager == nil) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      sg_userManager = [[HYBUserManager alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return sg_userManager;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;怎么用copy关键字？&quot;&gt;&lt;a href=&quot;#怎么用copy关键字？&quot; class=&quot;headerlink&quot; title=&quot;怎么用copy关键字？&quot;&gt;&lt;/a&gt;怎么用copy关键字？&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;分析：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;copy关键字只能应用于对象，不能用于基本类型。copy属性会复制一份，并且强引用之，但是对于集合类型，通常并不能达到深拷贝的目的。NSString、NSArray、NSDictionary等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，当然很多时候都使用了strong来声明。block也使用copy关键字来声明。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;参考答案：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;• copy关键字只能应用于对象，不能用于基本类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;• 对于字符串，理应始终使用copy，虽然使用strong一般情况下也没有关系&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;• 对于不可变集合类型，有可变和不可变类型，若要防止外部的修改影响所传过来的值，应该使用copy来声明，虽然大多情况下使用strong一定问题都没有。不过，实际开发中，我见到的几乎都是使用strong来声明的，包括笔者在内。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;• 对于可变集合类型，都应该使用strong来声明，不能使用copy，因为copy会生成一个不可变的类型，而不是可变的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;对于block，都应该使用copy来声明，原因是block来捕获上下文的信息。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;对数组中的元素去重复&quot;&gt;&lt;a href=&quot;#对数组中的元素去重复&quot; class=&quot;headerlink&quot; title=&quot;对数组中的元素去重复&quot;&gt;&lt;/a&gt;对数组中的元素去重复&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NSArray *array = @[@&amp;quot;12-11&amp;quot;, @&amp;quot;12-11&amp;quot;, @&amp;quot;12-11&amp;quot;, @&amp;quot;12-12&amp;quot;, @&amp;quot;12-13&amp;quot;, @&amp;quot;12-14&amp;quot;];//推荐的写法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;有如下几种方案：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;• 第一种方法：开辟新的内存空间，然后判断是否存在，若不存在则添加到数组中，得到最终结果的顺序不发生变化。效率分析：时间复杂度为O ( n2 )：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSMutableArray *resultArray = [[NSMutableArray alloc] initWithCapacity:array.count];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 外层一个循环&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for (NSString *item in array) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   // 调用-containsObject:本质也是要循环去判断，因此本质上是双层遍历&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   // 时间复杂度为O ( n^2 )而不是O (n)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (![resultArray containsObject:item]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      [resultArray addObject:item];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;resultArray: %@&amp;quot;, resultArray);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;原来集合操作可以通过valueForKeyPath来实现的，去重可以一行代码实现： &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;array = [array valueForKeyPath:@&amp;quot;@distinctUnionOfObjects.self&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;%@&amp;quot;, array);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;但是返回的结果是无序的，与原来的顺序不同。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;• 第二种方法：利用NSDictionary去重，字典在设置key-value时，若已存在则更新值，若不存在则插入值，然后获取allValues。若不要求有序，则可以采用此种方法。若要求有序，还得进行排序。效率分析：只需要一个循环就可以完成放入字典，若不要求有序，时间复杂度为O(n)。若要求排序，则效率与排序算法有关：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSMutableDictionary *resultDict = [[NSMutableDictionary alloc] initWithCapacity:array.count];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for (NSString *item in array) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [resultDict setObject:item forKey:item];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSArray *resultArray = resultDict.allValues;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;%@&amp;quot;, resultArray);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;如果需要按照原来的升序排序，可以这样：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;resultArray = [resultArray sortedArrayUsingComparator:^NSComparisonResult(id  _Nonnull obj1, id  _Nonnull obj2) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  NSString *item1 = obj1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  NSString *item2 = obj2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return [item1 compare:item2 options:NSLiteralSearch];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;%@&amp;quot;, resultArray);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;• 第三种方法：利用集合NSSet的特性(确定性、无序性、互异性)，放入集合就自动去重了。但是它与字典拥有同样的无序性，所得结果顺序不再与原来一样。如果不要求有序，使用此方法与字典的效率应该是差不多的。效率分析：时间复杂度为O (n)：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSSet *set = [NSSet setWithArray:array];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSArray *resultArray = [set allObjects];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;%@&amp;quot;, resultArray);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;如果要求有序，那就得排序，比如这里要升序排序：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;resultArray = [resultArray sortedArrayUsingComparator:^NSComparisonResult(id  _Nonnull obj1, id  _Nonnull obj2) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  NSString *item1 = obj1;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  NSString *item2 = obj2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  return [item1 compare:item2 options:NSLiteralSearch];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;%@&amp;quot;, resultArray);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;补充：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一直没有使用过有序集合，网友们反馈到可以直接使用有序集合，感谢大家：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSOrderedSet *set = [NSOrderedSet orderedSetWithArray:array];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;%@&amp;quot;, set.array);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;请写出有多少有方法给UIImageView添加圆角&quot;&gt;&lt;a href=&quot;#请写出有多少有方法给UIImageView添加圆角&quot; class=&quot;headerlink&quot; title=&quot;请写出有多少有方法给UIImageView添加圆角?&quot;&gt;&lt;/a&gt;请写出有多少有方法给UIImageView添加圆角?&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1、最直接的方法就是使用如下属性设置：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;imgView.layer.cornerRadius = 10;// 这一行代码是很消耗性能的imgView.clipsToBounds = YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;好处是使用简单，操作方便。坏处是离屏渲染（off-screen-rendering）需要消耗性能。对于图片比较多的视图上，不建议使用这种方法来设置圆角。通常来说，计算机系统中CPU、GPU、显示器是协同工作的。CPU计算好显示内容提交到GPU，GPU渲染完成后将渲染结果放入帧缓冲区。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;简单来说，离屏渲染，导致本该GPU干的活，结果交给了CPU来干，而CPU又不擅长GPU干的活，于是拖慢了UI层的FPS（数据帧率），并且离屏需要创建新的缓冲区和上下文切换，因此消耗较大的性能。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. 给UIImage添加生成圆角图片的扩展API：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (UIImage *)hyb_imageWithCornerRadius:(CGFloat)radius &amp;#123;  CGRect rect = (CGRect)&amp;#123;0.f, 0.f, self.size&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UIGraphicsBeginImageContextWithOptions(self.size, NO, UIScreen.mainScreen.scale);  CGContextAddPath(UIGraphicsGetCurrentContext(),                   [UIBezierPath bezierPathWithRoundedRect:rect cornerRadius:radius].CGPath);  CGContextClip(UIGraphicsGetCurrentContext());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self drawInRect:rect];  UIImage *image = UIGraphicsGetImageFromCurrentImageContext();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UIGraphicsEndImageContext();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;return image;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;然后调用时就直接传一个圆角来处理：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;imgView.image = [[UIImage imageNamed:@&amp;quot;test&amp;quot;] hyb_imageWithCornerRadius:4];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;持续收录一些较经典的面试题&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>骑行</title>
    <link href="http://yoursite.com/2016/06/23/%E9%AA%91%E8%A1%8C/"/>
    <id>http://yoursite.com/2016/06/23/骑行/</id>
    <published>2016-06-23T02:00:45.000Z</published>
    <updated>2016-08-04T07:19:33.000Z</updated>
    
    <content type="html">&lt;p&gt;骑车出去随手拍的一些照片&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw1024/bc254b75jw1f559ehq6z3j21kw23uqut.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw1024/bc254b75jw1f559em7dhmj21kw23u7wh.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw1024/bc254b75jw1f559end4p3j20qo0zkaph.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw1024/bc254b75jw1f559ev3xehj21kw23u4qp.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw1024/bc254b75jw1f559evsa81j20qo0zkai1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;骑车出去随手拍的一些照片&lt;br&gt;
    
    </summary>
    
      <category term="读书-生活" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6-%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>一些有道理的话</title>
    <link href="http://yoursite.com/2016/06/23/%E6%84%9F%E6%82%9F/"/>
    <id>http://yoursite.com/2016/06/23/感悟/</id>
    <published>2016-06-23T02:00:45.000Z</published>
    <updated>2016-08-04T07:19:04.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;收藏转载的一些个人感觉比较有道理的话&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;乐观的态度和对事物的专注度能让你解决大部分问题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;慢慢来比较快&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在你没有能力改变规则之前，那就遵守规则&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;买东西，就买能力范围内买最贵的，永远不会后悔&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;不想学东西的时候，人就和死差不多了。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这一生，情最难料。也难了&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;穷人才留破烂，越留越穷&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;人与人之间，在你觉得刚刚好的时候，对方会觉得吃了点亏，所以你得学会吃点亏，对方才会觉得刚刚好。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;梦想从来不是用来实现的，梦想是用来一寸一寸接近的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;阅读永远是一场孤独的旅程，考验的是你有没有决心和耐心走到生命的尽头。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;怕拒绝，选择沉默，错过了佳人。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;怕背叛，选择孤僻，错过了朋友。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;怕丢人，选择退缩，错过了经历。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;怕失败，选择安稳，错过了一切。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;专注于过提升自己的生活，而不是量入为出的日子&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;差距就在最简单的地方体现出来，并且决定着后面的发展&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;赢家从不抱怨也从来不做无意义的事情&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;有些事情你现在不做以后也不会做&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;抱怨不如去想如何解决，想如何解决不如动手去做&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一个人的精力毕竟是有限的，过于重视自己外在行为的优雅与否，必然带来内心世界的空洞与贫乏。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;总有一些本质上的东西是不会变的，比如认真。而人与人之间的区别，很大程度上也是由认真指数的多少来决定的。尤其对于男生而言，认真这点则显得更为重要。因为对人对事的认真程度，直接决定了你对其投入的时间、精力和感情的多与少；对工作的认真程度，决定了经济与物质；对感情（亲情、友情、爱情）的认真程度，决定了人际关系；对爱好的认真程度，决定了层次和趣味。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这世界最残忍的地方，不是无情，而是根本没有感情，他就这样冷漠的看你出生，看你欢笑，看你痛苦，看你变成一把灰。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;我们称之为路的 其实不过是彷徨。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;人生苦短，请去探索。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;斗米养恩 担米养仇&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;我愿死在前行的路上，不愿死在床上。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第一，成王败寇绝对是真理，少时看了不少成功学书籍，比如书里说要有主见要坚持，我常想那坚持的东西是错的呢？岂不是冥顽不灵？后来我想通了，坚持主见也好从善如流也好，这都不重要，关键还在于最后的结果。你成功了，坚持主见就是有魄力，失败了，就是冥顽不灵。没什么好解释的。赵括如果成功了，那就是英雄出少年，天纵奇才，未出茅庐而知天下事。既然失败了，那就是纸上谈兵，那就是白起的背景板。而成功学基本上就是你成功了，你说什么都有人听。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第二，每个人都是以自我为中心的，只是这个中心的半径大小不同。仔细观察人际交往的过程，就不难发现人们最感兴趣的话题永远是自己。有句话说的好，你生活中发生的99.9%的事别人根本不关心。所以，很多时候的人际交往都是自说自话。另一个启示就是和人交往时，多聊对方更容易获得信任与亲近感。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第三，人远比自己想象得自由，后面，还得加一句，但大多数人害怕自由，逃避自由，因此不自由。前半句貌似是福柯说的，也是《月亮河六便士》和《源泉》的主题，也是我多年来深信不疑的东西。后半句是我从村上的小说中提炼出的，大部分人说喜欢自由不过是说说罢了。君不见有几个人成了洛克，有几个人成了斯克里特兰德？自由意味着责任和勇气。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第四，‘我’其实是个第二人称。自我的定义，来源于他人。司汤达说过：“一个离群索居的人可以得到一切，唯独没有个性。‘ 我们通过周围的人对我们行为的反应不停修正着对自己的定义。阿兰德波顿的比喻就是”自我就像个变形虫，它的外壳可以灵活收缩，从而适应环境。’&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第五，喜欢独处与否跟性格无关。爱好独处的人完全可能乐观活泼，外向达观。对于某些人，独处是一种内在整合机制，甚至是建立强大内心的必需品。能不能忍受独处其实就是看你有没有自我。没有自我的人，内心极其空虚，需要过上热闹的生活，片刻的独处都会让他们意识到自己的贫乏，因此想方设法逃避，再无聊的消遣也比独处美好。而有些人能用这段独处时间发掘自己，发掘平凡生活中细小的美好，把小日子过得风生水起，跟人相处时又能绽放万丈光芒。这条主要是看叔本华的书时悟出来的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第六，很多人愤怒的不是不公平，而是自己没有分到一杯羹。不妨看看周围整天骂不公平又削尖脑袋想挤进既得利益群体的人吧。有的人痛恨的不是腐败，而是为什么自己不是受益的人。这个区别很微妙但很大。看《妖言水浒》时杨志在开封那段想到的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第七，喜欢古典乐的没资格歧视喜欢口水歌的（举个笠子而已，可以替换成任何东西）。因为大家都是消费者，古典乐和口水歌的确在艺术价值上有区别，生产者的水平也有区别，但消费者终归只是消费者，因为自己消费的东西比别人高就产生优越感就跟拿别人的东西炫耀一般，很可耻也很幼稚。只有你自己产出的东西才可以添加做为自己的价值。这一段话可以回答任何鄙视链的问题。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第八，人生中的重大问题（诸如爱情，理想，信念）是没有标准答案的，甚至可以说没有答案。但绝对有必要思考，因为只有思考了这些问题，你才能拥有一套自己的操作系统（三观），然后在面对人生中的小问题时才能少些疑惑。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第九，我们每个人都不是自己想象得那么与众不同。以前看到个有趣的调查，70%的司机认为自己技术高于平均水平。大家仔细揣摩一下其中的意味吧。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第十，强者不一定有罪，弱者不一定无辜。强弱，贫富跟道德不挂钩。当下，不少人一有事发生就把自己打扮成弱者的形态，迅速占领道德制高点。比如碰瓷。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第十一，人是由他做的事定义的，而不是他知道的道理定义的。就像我写下了这么多条，也完全说明不了我是什么样的人。这世界根本不在乎我是谁，我知道什么，只在乎我做了什么，我能做什么。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第十二条，有些人通过贬低、批评他人来减轻对自己处境的焦虑和不满。不管你说什么，他们都是负能量满满地大发议论。遇到这样的人，一定要尽早远离。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第十三条，真正喜欢的事不需要坚持。整天嚷嚷着要努力，要奋斗，其实多半不是真心喜欢眼下自己做的事。你觉得梵高会觉得画画是需要给自己打鸡血告诉自己咬牙坚持的吗？你会告诉自己坚持天天吃饭吗，坚持玩儿吗？这条是看克里希那穆提的书时领悟的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第十四条，想做一件事的时候，直接努力去做就行了，不用去听别人说有多难之类的抱怨。他说难是对他自己难，多半也是怕你成功让他难堪。如果你真的想做，那就做，大力出奇迹，够吊才会赢。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第十五条，如果你认为你看了这个问题下的顿悟自己就能顿悟，那你永远顿悟不了了。如果你觉得看了这些就比没看更好，那还是不要看了，知道，做不到，等于不知道。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;如果你想在一年内超越同龄人，每天多工作一小时。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;如果你想在十年内超越同龄人，每天多学习一小时。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;如果你想在一辈子超越同龄人，每天多运动一小时。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;优秀的来源是彻底地自我管理。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;通过积累普通人也可以做出不普通的事&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;百善孝为先，论心不论迹，论迹寒门无孝子；万恶淫为首，论迹不论心，论心世上无圣人。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;不如意事常八九，可与言者无二三。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;我所有的自负都来自我的自卑，所有的英雄气概都来自于我内心的软弱，所有的振振有词都因为心中满是怀疑。我假装无情，其实是痛恨自己的深情。我以为人生的意义在于四处游荡流亡，其实只是掩饰至今没有找到愿意驻足的地方。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;力量就是美&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;当你老了，回顾一生，就会发觉：什么时候出国读书，什么时候决定做第一份职业、何时选定了对象而恋爱、什么时候结婚，其实都是命运的巨变。只是当时站在三岔路口，眼见风云千樯，你作出选择的那一日，在日记上，相当沉闷和平凡，当时还以为是生命中普通的一天。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;想说的话要说出来,不说出来别人不会懂&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;明天再做是傻瓜&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;less is more的另一层含义是，既然只关注于核心因素，那么就将核心因素做到极至&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一切社会活动都是基于价值互换。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;小野二郎的事迹深深的激励了我，9岁入行，做了一辈子的寿司，现在90岁，是世界上年纪最大的米其林三星主厨。几十年如一日，每天不停的精进完善自己的技艺，用一辈子做好一件事。这是工匠精神的最好体现，成功就是坚持用一生，去不断提升和完善自己的技艺，使之达到完美的境界。我相信无论做哪一行，做什么事业，这就是成功的不二法则。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在成年人的社交关系中，对方会如何看待你、如何对待你，本质上只是取决于你个人的价值，你对别人的任何讨好行为不仅不会令你和对方的关系变得更好，反而会降低你在对方心目中的价值。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;社交关系绝不仅仅是你对别人好，别人也会对你好，你要记住，你对别人的付出能否获得别人的回报，最根本的是取决于你是谁，你是否有足够的价值。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;你是一个百万富翁，即便是随手将一个小孩从地上扶起来，小孩的父母都会对你感激涕零；你是一个乞丐，你天天跪着给这小孩的父母磕头，给他们掏粪，给他们打扫卫生，他们也不会感激你。因为他们认为你的价值太低，没有必要回报你。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第一个道理其实是悖论，就是无论我告诉你什么道理，当你的心智没有达到这个境界或接近的水平时或经历过一些事情的时候，你是不会理解这个道理的。或者你以为你知道这个道理，其实你不知道。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第二个很重要的道理是，除了自身的病患或亲友离去的痛苦是真实的，其他的痛苦都是你自己的价值观带给你的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第三个道理是与第二个有关联的，就是别人指责你的事情或批评的你的理由，往往最能伤害你的，是那些你也这样认为的事情。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第四个道理是其实人跟人之间差别其实不大，所以不要与别人去比较，人生就是一场长跑，你可能不会是第一名，但也不不太会是最后一名，和前面比你会有动力，和后面比你会有幸福。但重要的是享受过程。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第五个道理是永远不要与人去辩论，你也很难把别人辩服，因为立场不同，因为没有对错，只有规则，只有利益。人生就是一场游戏，懂得你在玩的游戏的游戏规则，然后玩好它。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;前面五个道理如果你真理解，你会觉得所谓别人的眼光，世俗的看法都不再那么重要，你内心的感觉，你的时间才最重要。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第六个道理是人身体的很多器官的受伤是超过一个界限之后不可逆的，比如眼睛过了假性就是真性近视，牙齿牙龈炎症过长一定会让你牙疼并拔牙的，脂肪肝时间过长就是肝硬化，而这些疾病的初期都是可逆的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第七个的道理是生活其实是一种运营，时间是你最宝贵的资源，还有钱，关系，都是你的一种投入，自己重视什么，事业，友谊，家庭上，就多投入些，种瓜得瓜，好好平衡各个关系是你要做好的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第八个道理是要感恩这个世界。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;巧者多劳 智者多忧 无能者无所求&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;精于心 简于形&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;收藏转载的一些个人感觉比较有道理的话&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="读书-生活" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6-%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>关于CocoaPods的使用总结</title>
    <link href="http://yoursite.com/2016/06/16/%E5%85%B3%E4%BA%8ECocoaPods%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/06/16/关于CocoaPods的使用总结/</id>
    <published>2016-06-16T08:27:20.000Z</published>
    <updated>2016-06-24T03:03:37.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;CocoaPods是iOS开发中一个管理第三方包的工具，个人感觉像Java中的Maven.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;参考这里&lt;a href=&quot;http://code4app.com/article/cocoapods-install-usage&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;进入项目的根目录(有proj文件的目录)，并在根目录下创建一个名叫Podfile的文件（没有任何后缀，编辑时最好用xcode打开）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例如下：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Ex1: 添加了多个依赖(可能有更规范的书写方式)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;platform :ios, &amp;apos;8.4&amp;apos; #手机的系统&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pod &amp;apos;AMap3DMap&amp;apos;  #3D地图SDK&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pod &amp;apos;AMap2DMap&amp;apos; #2D地图SDK (2D和3D不能同时使用)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pod &amp;apos;AMapSearch&amp;apos; #搜索服务SDK&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pod &amp;apos;AMapLocation&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pod &amp;apos;CocoaLumberjack&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Ex2:项目中使用的示例&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;platform :ios, &amp;apos;7.0&amp;apos; #手机的系统&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pod &amp;apos;AMap3DMap&amp;apos; #3D地图SDK&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pod &amp;apos;AMap2DMap&amp;apos; #2D地图SDK (2D和3D不能同时使用)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pod &amp;apos;AMapSearch&amp;apos; #搜索服务SDK&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pod &amp;apos;AMapLocation&amp;apos;, &amp;apos;~&amp;gt; 1.0.0&amp;apos;#定位SDK      // 导入特定版本（这个写法可能无效了）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pod &amp;apos;AMapLocation&amp;apos;, &amp;apos;1.0.0&amp;apos;  // 这个是正确写法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pod &amp;apos;FMDB&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pod &amp;apos;SVProgressHUD&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pod &amp;apos;Masonry&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pod &amp;apos;SDWebImage&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pod &amp;apos;AFNetworking&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;很重要：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;当用#号注释掉第三方包以后，再次执行 pod install --no-repo-update 会remove掉这个包&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pod install --verbose --no-repo-update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;更换第三方版本时，可以先在配置文件中#号注释掉当前版本，然后用pod install --no-repo-update去除掉相关包，再次执行pod install --no-repo-update导入当前版本的包&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;#异常及坑&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;异常：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;出现以下异常为没有CD到项目的最终根目录，这个要加以注意&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bogon:Ratings gwb$ pod install --no-repo-update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Analyzing dependencies&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[!] Could not automatically select an Xcode project. Specify one in your Podfile like so:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    xcodeproj &amp;apos;path/to/Project.xcodeproj&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;更新系统后CocoaPods无法使用的问题&quot;&gt;&lt;a href=&quot;#更新系统后CocoaPods无法使用的问题&quot; class=&quot;headerlink&quot; title=&quot;更新系统后CocoaPods无法使用的问题&quot;&gt;&lt;/a&gt;更新系统后CocoaPods无法使用的问题&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;系统更新到10.11.5，在mac上下载项目，在本地没法跑，显示pod进来的第三方包很多都红了，想从新Pod进来第三方包，遇到如下数个坑。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;安装过程如下&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ gem sources --remove https://rubygems.org///等有反应之后再敲入以下命令$ gem sources -a http://ruby.taobao.org/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;要想验证是否替换成功了，可以执行：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ gem sources -l&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;正常的输出是：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;*** CURRENT SOURCES ***&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;http://ruby.taobao.org/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这就不用说了，替换为淘宝源&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;同上&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo gem sources -a https://ruby.taobao.org/$ sudo gem sources -r https://rubygems.org/$ sudo gem sources -l&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;安装 CocoaPods。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo gem update$ sudo gem install -n /usr/local/bin cocoapods -v 0.39$ pod setup$ pod --version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在这里碰到的坑，默认安装了1.0.0版本&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;各种报错不能用，网上提供的解决办法试了很多都不管用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;无奈降低版本&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;重新安装 0.39版本能用了&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;另外碰到的几个问题都在下边记录了，怎么和git进行连接测试等&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Xocde 导出项目&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Authentication failed because no authentication credentials were provided.不知道什么原因，将项目路径的https替换成http就可以了&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;git进行连接测&quot;&gt;&lt;a href=&quot;#git进行连接测&quot; class=&quot;headerlink&quot; title=&quot;git进行连接测&quot;&gt;&lt;/a&gt;git进行连接测&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;在cmd或者终端下输入以下命令行：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global user.name trigkit4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;git config --global user.email 345823102@qq.com&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;当然，这是我的账户信息，你需要将他们换成你自己的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;创建本地ssh&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这是一种传输代码的方法，速度快又安全。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在终端或cmd输入以下命令行：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ssh-keygen -t rsa -C &amp;quot;345823102@qq.com&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;当然，邮箱依然换成你注册github时所用的邮箱。如下图所示&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;路径选择 : 使用该命令之后, 会出现提示选择ssh-key生成路径, 这里直接点回车默认即可, 生成的ssh-key在默认路径中;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;密码确认 : 这里我们不使用密码进行登录, 用密码太麻烦;就一路回车下去&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;将ssh配置到GitHub中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在mac os X 下前往文件夹，/Users/自己电脑用户名/.ssh。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;windows应该是（C:\Documents and Settings\Administrator\.ssh （或者 C:\Users\自己电脑用户名\.ssh）中）。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;然后用记事本打开id_rsa.pub，将里面的全部代码复制到github的SSH中。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;id_rsa.pub 文件内容 :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDS0qLtpontavr43AQntX4oBOsg2R3QlWubMYvfgJsIDX6NWd5RaIDLBLEMwIFLDcpvpQKvk5S/bTy4vTuWqeY6fkQ/tZBKksQn1WuYDcSfjLF8BuPMfdkboTh9NaKESKnsiWdranEVbmB5vOAHm8T+HFGdzG7Tz4ygzCnTwvdpBYrd/4jgeazws2d7CuMeuyb+FxdDTQy9YmJJm+82ypfR//bLyzRJo3SYadnPO3VdOAZCO1Isky+p/0nNN/obC4t2y2+oHBAqJV9h37f9S8UShgDmZoVLicRi4poni0i70xj+t/hnOsT8fmEc+vM9USyN+ndawz2oWjikKgln1jOB 345823102@qq.com&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;登陆github网站，点击Settings——SSH keys——点击右侧的Add SSH key ，接下去你懂得。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;验证是否配置成功 :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;复制如下代码:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ssh -T git@github.com&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;然后出现如下信息：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Warning: Permanently added the RSA host key for IP address &amp;apos;192.30.252.131&amp;apos; to the list of known hosts.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Hi hawx1993! You&amp;apos;ve successfully authenticated, but GitHub does not provide shell access.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;验证时可能让你输入YES，当出现以上信息时，说明配置成功，可以连接上GitHub;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;Cocoapods降低版本及卸载&quot;&gt;&lt;a href=&quot;#Cocoapods降低版本及卸载&quot; class=&quot;headerlink&quot; title=&quot;Cocoapods降低版本及卸载&quot;&gt;&lt;/a&gt;Cocoapods降低版本及卸载&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;有的时候我们需要降低Cocoapods的版本来解决第三方库的兼容问题.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一. 移除pod组件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这条指令会告诉你Cocoapods组件装在哪里 :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ which pod&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;你可以手动移除这个组件 :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo rm -rf &amp;lt;path&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;二. 移除 RubyGems 中的 Cocoapods程序包&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Q: RubyGems是什么?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A: RubyGems（简称 gems）是一个用于对 Ruby组件进行打包的 Ruby 打包系统。 它提供一个分发 Ruby 程序和库的标准格式，还提供一个管理程序包安装的工具。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;查看gems中本地程序包&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ gem list&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	*** LOCAL GEMS ***&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	activesupport (4.1.8, 3.2.21)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	bigdecimal (1.2.0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	CFPropertyList (2.2.8)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	claide (0.7.0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cocoapods (0.35.0, 0.34.1, 0.34.0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cocoapods-core (0.35.0, 0.34.1, 0.34.0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cocoapods-downloader (0.8.0, 0.7.2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cocoapods-plugins (0.3.2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cocoapods-trunk (0.4.1, 0.2.0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	cocoapods-try (0.4.2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	colored (1.2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	escape (0.0.4)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	fuzzy_match (2.0.4)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	i18n (0.6.11)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	io-console (0.4.2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	json (1.7.7)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	json_pure (1.8.1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	libxml-ruby (2.6.0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	minitest (5.4.3, 4.3.2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	molinillo (0.1.2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	multi_json (1.10.1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	nap (0.8.0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	netrc (0.7.8)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	nokogiri (1.5.6)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	open4 (1.3.4)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	psych (2.0.0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	rake (0.9.6)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	rdoc (4.0.0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	sqlite3 (1.3.7)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	test-unit (2.0.0.0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	thread_safe (0.3.4)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	tzinfo (1.2.2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	xcodeproj (0.20.2, 0.19.4)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;发现Cocoapods的程序包&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cocoapods (0.35.0, 0.34.1, 0.34.0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cocoapods-core (0.35.0, 0.34.1, 0.34.0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cocoapods-downloader (0.8.0, 0.7.2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cocoapods-plugins (0.3.2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cocoapods-trunk (0.4.1, 0.2.0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cocoapods-try (0.4.2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;移除程序包&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo gem uninstall cocoapods -v 0.35.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Successfully uninstalled cocoapods-0.35.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo gem uninstall cocoapods-core -v 0.35.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Successfully uninstalled cocoapods-core-0.35.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;然后安装指定版本的Cocoapods&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ sudo gem install cocoapods -v 0.34.4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;安装成功后&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$ pod --version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0.34.1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;CocoaPods是iOS开发中一个管理第三方包的工具，个人感觉像Java中的Maven.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>Objc概念知识点学习笔记</title>
    <link href="http://yoursite.com/2016/06/15/Objc%E6%A6%82%E5%BF%B5%E7%9F%A5%E8%AF%86%E7%82%B9%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/06/15/Objc概念知识点学习笔记/</id>
    <published>2016-06-15T08:07:24.000Z</published>
    <updated>2016-07-12T03:53:49.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;Objc概念知识点学习笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;UIApplication-amp-AppDelegate&quot;&gt;&lt;a href=&quot;#UIApplication-amp-AppDelegate&quot; class=&quot;headerlink&quot; title=&quot;UIApplication&amp;amp;AppDelegate&quot;&gt;&lt;/a&gt;UIApplication&amp;amp;AppDelegate&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;（1）UIApplication对象是应用程序的象征，一个UIApplication对象就代表一个应用程序。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（2）每一个应用都有自己的UIApplication对象，而且是单例的，如果试图在程序中新建一个UIApplication对象，那么将报错提示。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（3）通过[UIApplication sharedApplication]可以获得这个单例对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（4） 一个iOS程序启动后创建的第一个对象就是UIApplication对象，且只有一个（通过代码获取两个UIApplication对象，打印地址可以看出地址是相同的）。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;（5）利用UIApplication对象，能进行一些应用级别的操作，如：设置应用程序图标右上角的红色提醒数字、设置联网指示器的可见性、管理状态栏、openURL&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;下面介绍appdelagate&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在main.m的UIApplicationMain函数中，根据@&amp;quot;AppDelegate&amp;quot;这个类，创建一个delegate对象，并将该delegate对象赋值给UIApplication对象中的delegate属性&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;所有的移动操作系统都有个致命的缺点：app很容易受到打扰。比如一个来电或者锁屏会导致app进入后台甚至被终止。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;还有很多其它类似的情况会导致app受到干扰，在app受到干扰时，会产生一些系统事件，这时UIApplication会通知它的delegate对象，让delegate代理来处理这些系统事件。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;作用：当被打断的时候，通知代理进入到后台。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;响应者链&quot;&gt;&lt;a href=&quot;#响应者链&quot; class=&quot;headerlink&quot; title=&quot;响应者链&quot;&gt;&lt;/a&gt;响应者链&lt;/h4&gt;&lt;p&gt;事件分类&lt;br&gt;对于IOS设备用户来说，他们操作设备的方式主要有三种：触摸屏幕、晃动设备、通过遥控设施控制设备。对应的事件类型有以下三种：&lt;br&gt;1、触屏事件（Touch Event）&lt;br&gt;2、运动事件（Motion Event）&lt;br&gt;3、远端控制事件（Remote-Control Event）&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;响应者链（Responder Chain）&lt;br&gt;指的是有响应和处理事件能力的对象。响应者链就是由一系列的响应者对象构成的一个层次结构。&lt;br&gt;什么是事件的响应者&lt;br&gt;只要继承了UIResponder的对象就可以作为事件的响应者&lt;br&gt;其中AppDelegate类是创建一个iOS项目时自动创建的继承UIResponder的应用程序委托类&lt;br&gt;// 接口文件&lt;/p&gt;
&lt;p&gt; #import &lt;uikit uikit.h=&quot;&quot;&gt;&lt;br&gt; @interface AppDelegate : UIResponder &lt;uiapplicationdelegate&gt;&lt;/uiapplicationdelegate&gt;&lt;/uikit&gt;&lt;/p&gt;
&lt;p&gt; 响应者链&lt;br&gt;如果当前响应者无法响应用户事件，它将继续向上传递，直到找到请响应者，这个传递过程形成了一条有规律的链条，组成了响应者链（一个层次结构）如果一直找到AppDelegate类还是无法响应用户事件，那么这个事件将无法被响应，但如果在响应者链上传递的过程中，有某个响应者对该传递的事件有响应，该传递过程将立即停止。&lt;br&gt;    initial view若不能处理事件，则传到其父视图view&lt;br&gt;    view若不能处理，则传到其父视图，因为它还不是最上层视图&lt;br&gt;    这里view的父视图是view controller的view，因为这个view也不能处理事件，因此传给view controller&lt;br&gt;    若view controller也不能处理此事件，则传到window&lt;br&gt;    若window也不能处理此事件，则传到app单例对象Application&lt;br&gt;    若UIApplication单例对象也不能处理，则表示无效事件&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;什么是第一响应者&lt;br&gt;与用户交互的控件就是第一响应者，它将作为响应者链的开始，事件首先发送给第一响应者，然后再依次传递下去，直到该事件被某个响应者处理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;起始及事件分发&lt;br&gt;当一个触摸事件发生，首先接收到事件的对象是UIApplication&lt;br&gt;将事件放入UIApplication的活动队列中&lt;br&gt;UIApplication的单例对象，再从活动队列取出该事件，并传递给UIWindow&lt;br&gt;UIWindow的对象将调用-(nullable UIView &lt;em&gt;)hitTest:(CGPoint)point withEvent:(nullable UIEvent &lt;/em&gt;)event;方法&lt;br&gt;• 在这个方法中对其下一层的每一个视图调用- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent &lt;em&gt;)event;方法，用于判断当前点击的点是否位于当前视图中&lt;br&gt;（1）若返回NO，则表示不在当前视图中，-(nullable UIView &lt;/em&gt;)hitTest:(CGPoint)point withEvent:(nullable UIEvent &lt;em&gt;)event;方法返回nil;&lt;br&gt;（2）若返回YES，则说明该触摸事件发生在当前视图，然后当前视图再调用 -(nullable UIView &lt;/em&gt;)hitTest:(CGPoint)point withEvent:(nullable UIEvent &lt;em&gt;)event;方法;&lt;br&gt;（3）重复上述过程，直到- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent &lt;/em&gt;)event;方法返回YES，并使用它调用-(nullable UIView &lt;em&gt;)hitTest:(CGPoint)point withEvent:(nullable UIEvent &lt;/em&gt;)event;方法返回nil的时候，表示此视图就是这个触摸事的第一响应者。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/652024-2e717ff7875279f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;懒加载&quot;&gt;&lt;a href=&quot;#懒加载&quot; class=&quot;headerlink&quot; title=&quot;懒加载&quot;&gt;&lt;/a&gt;懒加载&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;也称为延迟加载，即在需要的时候才加载（效率低，占用内存小）。所谓懒加载，写的是其get方法.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (NSMutableArray *)fakeData&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      if (!_fakeData)//判断是否已经有了，若没有，则进行实例化&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.fakeData   = [NSMutableArray array];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return _fakeData;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;优点：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;防止对象被提前创建（内存优化，如加载plist文件等耗内存的操作）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;防止对象重复创建 （永远只加载一次）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;防止对象使用时,还没被创建&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可以在懒加载方法里面,进行初始化操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;懒加载代码示例&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[super viewDidLoad];&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (NSArray *)shopData&amp;#123;    if (!_shopData) &amp;#123;        _shopData = [NSArray arrayWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@&amp;quot;shop&amp;quot; ofType:@&amp;quot;plist&amp;quot;]];    &amp;#125;    return _shopData;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;iOS开发中需要的图片&quot;&gt;&lt;a href=&quot;#iOS开发中需要的图片&quot; class=&quot;headerlink&quot; title=&quot;iOS开发中需要的图片&quot;&gt;&lt;/a&gt;iOS开发中需要的图片&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1、产品设计图&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   可以以6的长宽比 750*1134来设计。这些图片用于描述app是什么样子的，这是app开发人员的开发参考。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2、产品切图&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;将设计师将设计稿切成可以用来开发的图&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    颜色值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    iOS颜色值取 RGB各颜色的值比如某个色值，给予iOS开发的色值为 R:12 G:34 B:56 给出的值就是 12,34,56(有时也要根据开发的习惯，有时也用十六进制)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    内部设计细节：1、所有能点击的图片不得小于44px（Retina需要88px）2、单独存在的部件必须是双数尺寸 3、两倍图以@2x作为命名后缀&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3、图标icon&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      需要四种尺寸：58*58、80*80、120*120、180*180&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4、启动图LaunchImage&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      需要四种尺寸：3.5英寸（640*960），4英寸（640*1136），4.7英寸（750*1134），5.5英寸（1242*2208）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5、引导图&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      这是用于用户第一次使用app或者app更新之后展示新特性的图&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6、App Store上架图&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      这个是用于在App Store上面 介绍app的，需要四种尺寸：3.5英寸（640*960），4英寸（640*1136），4.7英寸（750*1134），5.5英寸（1242*2208）&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;在-m中的声明-interface&quot;&gt;&lt;a href=&quot;#在-m中的声明-interface&quot; class=&quot;headerlink&quot; title=&quot;在.m中的声明@interface&quot;&gt;&lt;/a&gt;在.m中的声明@interface&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//in Header.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface Header&amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//in Header.m&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface Header()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这是个非常常见的设计,为什么在.m文件里面,也要出现一个接口声明呢?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这很类似于一个分类,但其实它不是一个分类(或者你也可以叫它anonymous Catogary),其实这是一个叫做class extension的东西&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;说说区别:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1.  首先 extension 可以重声明一个数据成员,比如一个数据成员是只读的,你可以把它变成可读写&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.  分类根本不同意你扩展数据成员,它只扩展一些方法, 但是在Clang/LLVM 2.0 compiler 以后, extension可以这么做.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.  有时候,你如果希望实现一些不公开的方法供自己使用,那你可以把它放入.m的extension里面.那么这些接口都是不公开的了&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;h-m属性&quot;&gt;&lt;a href=&quot;#h-m属性&quot; class=&quot;headerlink&quot; title=&quot;.h  .m属性&quot;&gt;&lt;/a&gt;.h  .m属性&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;属性在.h文件中和在.m中声明是有区别的。区别就是，在.h文件中声明的属性，外部类可以通过“类实例.属性”来调用但在.m中声明的则不可以，获取和设置的方法，只能是通过setValue:forKey和valueForKey来实现。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;awakeFromNib&quot;&gt;&lt;a href=&quot;#awakeFromNib&quot; class=&quot;headerlink&quot; title=&quot;awakeFromNib&quot;&gt;&lt;/a&gt;awakeFromNib&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;当.nib文件被加载的时候，会发送一个awakeFromNib的消息到.nib文件中的每个对象，每个对象都可以定义自己的awakeFromNib函数来响应这个消息，执行一些必要的操作。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;也就是说只有通过.nib文件创建view对象时才会执行awakeFromNib 。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一般的，当IB加载的时候，我们会通过调用自定义对象的awakeFromNib函数，来对界面进行补充。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;选择的时机：当你需要写一个UIView的子类并且想在load nib的时候做一些初始化工作的时候很有用。bundle在load nib后会给每个view对象发送一个awakeFromNib消息。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Weak-outlet&quot;&gt;&lt;a href=&quot;#Weak-outlet&quot; class=&quot;headerlink&quot; title=&quot;Weak outlet&quot;&gt;&lt;/a&gt;Weak outlet&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;当我们使用Outlet属性的时候，我们是在viewController里面使用，而这个Outlet属性是有view来进行强引用的，我们在viewController里面仅仅是对其使用，并没有必要拥有它，所以是weak的。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;interface&quot;&gt;&lt;a href=&quot;#interface&quot; class=&quot;headerlink&quot; title=&quot;@interface&quot;&gt;&lt;/a&gt;@interface&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1. 继承&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. 声明协议&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3. 定义实例变量（@interface后面加大括号那种）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4. 定义@property&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5. 声明方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.h里面的@interface，不消说，是典型的头文件，它是供其它Class调用的。它的@property和functions，都能够被其它Class“看到”。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;而.m里面的@interface，在OC里叫作Class Extension，是.h文件中@interface的补充。但是.m文件里的@interface，对外是不开放的，只在.m文件里可见。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;因此，我们将对外开放的方法、变量放到.h文件中，而将不想要对外开放的变量放到.m文件中（.m文件的方法可以不声明，直接用）。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;implementation&quot;&gt;&lt;a href=&quot;#implementation&quot; class=&quot;headerlink&quot; title=&quot;@implementation&quot;&gt;&lt;/a&gt;@implementation&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1. 继承&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. 定义实例变量&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3. 合成属性（@synthesize和@dynamic）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4. 实现方法（包括协议方法）&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;init&quot;&gt;&lt;a href=&quot;#init&quot; class=&quot;headerlink&quot; title=&quot;init&quot;&gt;&lt;/a&gt;init&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;所有类都继承自NSObject，而NSObject里面有init。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;所以所有类都可以拥有init这个方法。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;所以说init是最纯洁的初始化方法。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;IBAction-amp-IBOutlet&quot;&gt;&lt;a href=&quot;#IBAction-amp-IBOutlet&quot; class=&quot;headerlink&quot; title=&quot;IBAction &amp;amp; IBOutlet&quot;&gt;&lt;/a&gt;IBAction &amp;amp; IBOutlet&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;从界面上的一个控件 Control+drag 拖一个方法到代码的实现区，会得到类似：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(IBAction) touchCardButton:(UIButton*)sender;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这里的 IBAction 其实返回的是 void，类似 typedef IBAction void。IBAction 是为了让 Xcode 去区别方法是不是 target action，这样我们可以做到鼠标在上面的时候界面会高亮对应的控件之类的。但是编译器会忽略它，对编译器来说它就是 void。当你要改这个方法名的时候，有点麻烦的是你需要对着对应的控件点右键，然后叉掉方法绑定，然后重新连接。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从界面上的一个控件 Control+drag 拖一个方法到代码的属性区，会得到类似：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (weak, nonatomic) IBOutlet UILabel* flipsLabel;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;的UI属性。这里一定是一个 weak 的属性，因为这个属性是被 View 所 strong 持有的，对 Controller 来说只应该 weak 地指向它。这里的 IBOutlet 跟 IBAction 的意思差不多，主要是方便 Xcode用它，编译器会忽略它。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;方法多个参数的写法&quot;&gt;&lt;a href=&quot;#方法多个参数的写法&quot; class=&quot;headerlink&quot; title=&quot;方法多个参数的写法:&quot;&gt;&lt;/a&gt;方法多个参数的写法:&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(方法的数据类型)函数名:(参数1数据类型)参数1的数值的名字 参数2的名字: (参数2数据类型) 参数2值的名字 …&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;举个例子，一个方法的定义：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void) setKids: (NSString *)myOldestKidName secondKid: (NSString *) mySecondOldestKidName thirdKid: (NSString *) myThirdOldestKidName;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;实现这个函数的时候：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void) setKids: (NSString *)myOldestKidName secondKid: (NSString *) mySecondOldestKidName thirdKid: (NSString *) myThirdOldestKidName&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;大儿子 = myOldestKidName; 二儿子 = mySecondOldestKidName; 三儿子 = myThirdOldestKidName;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;调用的时候：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Kids *myKids = [[Kids alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[myKids setKids: @”张大力” secondKid: @”张二力” thirdKid: @”张小力”];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;Nil-nil-Null-NSNull&quot;&gt;&lt;a href=&quot;#Nil-nil-Null-NSNull&quot; class=&quot;headerlink&quot; title=&quot;Nil nil Null NSNull&quot;&gt;&lt;/a&gt;Nil nil Null NSNull&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;nil&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nil 是 ObjC 对象的字面空值，对应 id 类型的对象，或者使用 @interface 声明的 ObjC 对象。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;例如：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSString *someString = nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSURL *someURL = nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;id someObject = nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Nil&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Nil 是 ObjC 类类型的书面空值，对应 Class 类型对象。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;例如：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Class someClass = Nil;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Class anotherClass = [NSString class];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NULL&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NULL 是任意的 C 指针空值。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;例如：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int *pointerToInt = NULL;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;char *pointerToChar = NULL;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;struct TreeNode *rootNode = NULL;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSNull&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSNull 是一个代表空值的类，是一个 ObjC 对象。实际上它只有一个单例方法：+[NSNull null]，一般用于表示集合中值为空的对象。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;例子说明：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 因为 nil 被用来用为集合结束的标志，所以 nil 不能存储在 Foundation 集合里。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSArray *array = [NSArray arrayWithObjects:@&amp;quot;one&amp;quot;, @&amp;quot;two&amp;quot;, nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 错误的使用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSMutableDictionary *dict = [NSMutableDictionary dictionary];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[dict setObject:nil forKey:@&amp;quot;someKey&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 正确的使用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSMutableDictionary *dict = [NSMutableDictionary dictionary];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[dict setObject:[NSNull null] forKey:@&amp;quot;someKey&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[判断为空的方式]：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;![listi isKindOfClass:[NSNull class]]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;self-and&quot;&gt;&lt;a href=&quot;#self-and&quot; class=&quot;headerlink&quot; title=&quot;self and _&quot;&gt;&lt;/a&gt;self and _&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;所有使用self.xxx是更好的选择，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;因为这样可以兼容懒加载，同时也避免了使用下滑线的时候忽略了self这个指针，后者容易在BLock中造成循环引用。同时，使用 _是获取不到父类的属性，因为它只是对局部变量的访问。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;最后总结：self方法实际上是用了get和set方法间接调用，下划线方法是直接对变量操作。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;_xxx访问的是xxx的地址。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;self.xxx访问的是xxx的getter。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这两者并不是完全等价的，self.xxx是用objc_msgSend发消息，_xxx或者self-&amp;gt;xxx则是直接访问内存地址，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;一般建议在init里面用_xxx，其他地方用self.xxx&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;UIGestureRecognizerDelegate&quot;&gt;&lt;a href=&quot;#UIGestureRecognizerDelegate&quot; class=&quot;headerlink&quot; title=&quot;UIGestureRecognizerDelegate&quot;&gt;&lt;/a&gt;UIGestureRecognizerDelegate&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;可以定义各种手势的实现，如滑动返回等&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;UIResponder&quot;&gt;&lt;a href=&quot;#UIResponder&quot; class=&quot;headerlink&quot; title=&quot;UIResponder&quot;&gt;&lt;/a&gt;UIResponder&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;这个类定义了很多用来处理响应和时间处理的类。他的子类有UIApplication，UIView以及UIWindow等。IOS中分为两类事件：触摸事件，和移动事件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;处理触摸事件的主要方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1.touchesBegan:withEvent:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.touchesMoved:withEvent:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.touchesEnded:withEvent:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4.touchesCancelled:withEvent:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这些方法的参数与触摸它们的事件相关联，开始触摸以及触摸位置的改变都会发生触摸事件。因此iOS允许在多点触摸中响应者分别追踪和处理触摸。只要手指触摸屏幕，滑动，从屏幕离开，都会产生一个UIEvent对象，事件包括UITouch对象&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;处理移动事件的主要方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1.motionBegan:withEvent:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.motionEnded:withEvent:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.motionCancelled:withEvent:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;另外，canPerformAction:withSender: 方法允许响应程序来验证用户界面中的命令，而 undoManager 属性返回最近的在响应链中NSUndoManager 对象。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Objc概念知识点学习笔记&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>多线程基础</title>
    <link href="http://yoursite.com/2016/06/15/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2016/06/15/多线程基础/</id>
    <published>2016-06-15T06:46:00.000Z</published>
    <updated>2016-08-04T02:10:11.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;多线程在iOS的开发中应用的场景非常多，自己还不能整理完全，转一下别人的博客，自己稍作记录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/kenshincui/p/3983982.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;iOS多线程&lt;/p&gt;
&lt;p&gt;在iOS中每个进程启动后都会建立一个主线程（UI线程），这个线程是其他线程的父线程。由于在iOS中除了主线程，其他子线程是独立于Cocoa Touch的，所以只有主线程可以更新UI界面（新版iOS中，使用其他线程更新UI可能也能成功，但是不推荐）。iOS中多线程使用并不复杂，关键是如何控制好各个线程的执行顺序、处理好资源竞争问题。常用的多线程开发有三种方式：&lt;/p&gt;
&lt;p&gt;1.NSThread&lt;/p&gt;
&lt;p&gt;2.NSOperation&lt;/p&gt;
&lt;p&gt;3.GCD&lt;/p&gt;
&lt;h3 id=&quot;NSThread&quot;&gt;&lt;a href=&quot;#NSThread&quot; class=&quot;headerlink&quot; title=&quot;NSThread&quot;&gt;&lt;/a&gt;NSThread&lt;/h3&gt;&lt;p&gt;NSThread是轻量级的多线程开发，使用起来也并不复杂，但是使用NSThread需要自己管理线程生命周期。可以使用对象方法+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(id)argument直接将操作添加到线程中并启动，也可以使用对象方法- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(id)argument 创建一个线程对象，然后调用start方法启动线程。&lt;/p&gt;
&lt;h5 id=&quot;解决线程阻塞问题&quot;&gt;&lt;a href=&quot;#解决线程阻塞问题&quot; class=&quot;headerlink&quot; title=&quot;解决线程阻塞问题&quot;&gt;&lt;/a&gt;解决线程阻塞问题&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;在资源下载过程中，由于网络原因有时候很难保证下载时间，如果不使用多线程可能用户完成一个下载操作需要长时间的等待，这个过程中无法进行其他操作。下面演示一个采用多线程下载图片的过程，在这个示例中点击按钮会启动一个线程去下载图片，下载完成后使用UIImageView将图片显示到界面中。可以看到用户点击完下载按钮后，不管图片是否下载完成都可以继续操作界面，不会造成阻塞。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  NSThread实现多线程&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  MultiThread&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  Created by Kenshin Cui on 14-3-22.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;KCMainViewController.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface KCMainViewController ()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIImageView *_imageView;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation KCMainViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [super viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self layoutUI];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark 界面布局&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)layoutUI&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _imageView =[[UIImageView alloc]initWithFrame:[UIScreen mainScreen].applicationFrame];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _imageView.contentMode=UIViewContentModeScaleAspectFit;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addSubview:_imageView];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIButton *button=[UIButton buttonWithType:UIButtonTypeRoundedRect];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    button.frame=CGRectMake(50, 500, 220, 25);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [button setTitle:@&amp;quot;加载图片&amp;quot; forState:UIControlStateNormal];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //添加方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [button addTarget:self action:@selector(loadImageWithMultiThread) forControlEvents:UIControlEventTouchUpInside];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addSubview:button];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark 将图片显示到界面&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)updateImage:(NSData *)imageData&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIImage *image=[UIImage imageWithData:imageData];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _imageView.image=image;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark 请求图片数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(NSData *)requestData&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSURL *url=[NSURL URLWithString:@&amp;quot;http://images.apple.com/iphone-6/overview/images/biggest_right_large.png&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSData *data=[NSData dataWithContentsOfURL:url];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark 加载图片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)loadImage&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //请求数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSData *data= [self requestData];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /*将数据显示到UI控件,注意只能在主线程中更新UI,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     另外performSelectorOnMainThread方法是NSObject的分类方法，每个NSObject对象都有此方法，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     它调用的selector方法是当前调用控件的方法，例如使用UIImageView调用的时候selector就是UIImageView的方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     Object：代表调用方法的参数,不过只能传递一个参数(如果有多个参数请使用对象进行封装)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     waitUntilDone:是否线程任务完成执行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self performSelectorOnMainThread:@selector(updateImage:) withObject:data waitUntilDone:YES];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark 多线程下载图片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)loadImageWithMultiThread&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //方法1：使用对象方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //创建一个线程，第一个参数是请求的操作，第二个参数是操作方法的参数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    NSThread *thread=[[NSThread alloc]initWithTarget:self selector:@selector(loadImage) object:nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    //启动一个线程，注意启动一个线程并非就一定立即执行，而是处于就绪状态，当系统调度时才真正执行&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    [thread start];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //方法2：使用类方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [NSThread detachNewThreadSelector:@selector(loadImage) toTarget:self withObject:nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;程序比较简单，但是需要注意执行步骤：当点击了“加载图片”按钮后启动一个新的线程，这个线程在演示中大概用了5s左右，在这5s内UI线程是不会阻塞的，用户可以进行其他操作，大约5s之后图片下载完成，此时调用UI线程将图片显示到界面中（这个过程瞬间完成）。另外前面也提到过，更新UI的时候使用UI线程，这里调用了NSObject的分类扩展方法，调用UI线程完成更新。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h5 id=&quot;多个线程并发&quot;&gt;&lt;a href=&quot;#多个线程并发&quot; class=&quot;headerlink&quot; title=&quot;多个线程并发&quot;&gt;&lt;/a&gt;多个线程并发&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;上面这个演示并没有演示多个子线程操作之间的关系，现在不妨在界面中多加载几张图片，每个图片都来自远程请求。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;大家应该注意到不管是使用+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(id)argument、- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(id)argument 方法还是使用- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait方法都只能传一个参数，由于更新图片需要传递UIImageView的索引和图片数据，因此这里不妨定义一个类保存图片索引和图片数据以供后面使用。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;KCImageData.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  KCImageData.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  MultiThread&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  Created by Kenshin Cui on 14-3-22.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface KCImageData : NSObject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark 索引&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic,assign) int index;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark 图片数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic,strong) NSData *data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;接下来将创建多个UIImageView并创建多个线程用于往UIImageView中填充图片。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;KCMainViewController.m&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  NSThread实现多线程&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  MultiThread&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  Created by Kenshin Cui on 14-3-22.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;KCMainViewController.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;KCImageData.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define ROW_COUNT 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define COLUMN_COUNT 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define ROW_HEIGHT 100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define ROW_WIDTH ROW_HEIGHT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define CELL_SPACING 10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface KCMainViewController ()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSMutableArray *_imageViews;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation KCMainViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [super viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self layoutUI];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark 界面布局&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)layoutUI&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //创建多个图片控件用于显示图片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _imageViews=[NSMutableArray array];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (int r=0; r&amp;lt;ROW_COUNT; r++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for (int c=0; c&amp;lt;COLUMN_COUNT; c++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            UIImageView *imageView=[[UIImageView alloc]initWithFrame:CGRectMake(c*ROW_WIDTH+(c*CELL_SPACING), r*ROW_HEIGHT+(r*CELL_SPACING                           ), ROW_WIDTH, ROW_HEIGHT)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            imageView.contentMode=UIViewContentModeScaleAspectFit;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//            imageView.backgroundColor=[UIColor redColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [self.view addSubview:imageView];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [_imageViews addObject:imageView];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIButton *button=[UIButton buttonWithType:UIButtonTypeRoundedRect];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    button.frame=CGRectMake(50, 500, 220, 25);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [button setTitle:@&amp;quot;加载图片&amp;quot; forState:UIControlStateNormal];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //添加方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [button addTarget:self action:@selector(loadImageWithMultiThread) forControlEvents:UIControlEventTouchUpInside];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addSubview:button];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark 将图片显示到界面&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)updateImage:(KCImageData *)imageData&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIImage *image=[UIImage imageWithData:imageData.data];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIImageView *imageView= _imageViews[imageData.index];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    imageView.image=image;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark 请求图片数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(NSData *)requestData:(int )index&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSURL *url=[NSURL URLWithString:@&amp;quot;http://images.apple.com/iphone-6/overview/images/biggest_right_large.png&amp;quot;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSData *data=[NSData dataWithContentsOfURL:url];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark 加载图片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)loadImage:(NSNumber *)index&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //    NSLog(@&amp;quot;%i&amp;quot;,i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //currentThread方法可以取得当前操作线程&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&amp;quot;current thread:%@&amp;quot;,[NSThread currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int i=[index integerValue];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    NSLog(@&amp;quot;%i&amp;quot;,i);//未必按顺序输出&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSData *data= [self requestData:i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    KCImageData *imageData=[[KCImageData alloc]init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    imageData.index=i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    imageData.data=data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self performSelectorOnMainThread:@selector(updateImage:) withObject:imageData waitUntilDone:YES];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark 多线程下载图片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)loadImageWithMultiThread&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //创建多个线程用于填充图片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (int i=0; i&amp;lt;ROW_COUNT*COLUMN_COUNT; ++i) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        [NSThread detachNewThreadSelector:@selector(loadImage:) toTarget:self withObject:[NSNumber numberWithInt:i]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSThread *thread=[[NSThread alloc]initWithTarget:self selector:@selector(loadImage:) object:[NSNumber numberWithInt:i]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        thread.name=[NSString stringWithFormat:@&amp;quot;myThread%i&amp;quot;,i];//设置线程名称&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [thread start];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;通过NSThread的currentThread可以取得当前操作的线程，其中会记录线程名称name和编号number，需要注意主线程编号永远为1。多个线程虽然按顺序启动，但是实际执行未必按照顺序加载照片（loadImage:方法未必依次创建，可以通过在loadImage:中打印索引查看），因为线程启动后仅仅处于就绪状态，实际是否执行要由CPU根据当前状态调度。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从上面的运行效果大家不难发现，图片并未按顺序加载，原因有两个：第一，每个线程的实际执行顺序并不一定按顺序执行（虽然是按顺序启动）；第二，每个线程执行时实际网络状况很可能不一致。当然网络问题无法改变，只能尽可能让网速更快，但是可以改变线程的优先级，让15个线程优先执行某个线程。线程优先级范围为0~1，值越大优先级越高，每个线程的优先级默认为0.5。修改图片下载方法如下，改变最后一张图片加载的优先级，这样可以提高它被优先加载的几率，但是它也未必就第一个加载。因为首先其他线程是先启动的，其次网络状况我们没办法修改：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)loadImageWithMultiThread&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSMutableArray *threads=[NSMutableArray array];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int count=ROW_COUNT*COLUMN_COUNT;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //创建多个线程用于填充图片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (int i=0; i&amp;lt;count; ++i) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        [NSThread detachNewThreadSelector:@selector(loadImage:) toTarget:self withObject:[NSNumber numberWithInt:i]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSThread *thread=[[NSThread alloc]initWithTarget:self selector:@selector(loadImage:) object:[NSNumber numberWithInt:i]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        thread.name=[NSString stringWithFormat:@&amp;quot;myThread%i&amp;quot;,i];//设置线程名称&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if(i==(count-1))&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            thread.threadPriority=1.0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;else&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            thread.threadPriority=0.0;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [threads addObject:thread];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (int i=0; i&amp;lt;count; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSThread *thread=threads[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [thread start];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h5 id=&quot;线程状态&quot;&gt;&lt;a href=&quot;#线程状态&quot; class=&quot;headerlink&quot; title=&quot;线程状态&quot;&gt;&lt;/a&gt;线程状态&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;在线程操作过程中可以让某个线程休眠等待，优先执行其他线程操作，而且在这个过程中还可以修改某个线程的状态或者终止某个指定线程。为了解决上面优先加载最后一张图片的问题，不妨让其他线程先休眠一会等待最后一个线程执行。修改图片加载方法如下即可：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(NSData *)requestData:(int )index&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //对非最后一张图片加载线程休眠2秒&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (index!=(ROW_COUNT*COLUMN_COUNT-1)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [NSThread sleepForTimeInterval:2.0];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSURL *url=[NSURL URLWithString:_imageNames[index]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSData *data=[NSData dataWithContentsOfURL:url];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在这里让其他线程休眠2秒，此时你就会看到最后一张图片总是第一个加载（除非网速特别差）。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;线程状态分为isExecuting（正在执行）、isFinished（已经完成）、isCancellled（已经取消）三种。其中取消状态程序可以干预设置，只要调用线程的cancel方法即可。但是需要注意在主线程中仅仅能设置线程状态，并不能真正停止当前线程，如果要终止线程必须在线程中调用exist方法，这是一个静态方法，调用该方法可以退出当前线程。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;假设在图片加载过程中点击停止按钮让没有完成的线程停止加载，可以改造程序如下：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  NSThread实现多线程&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  MultiThread&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  Created by Kenshin Cui on 14-3-22.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;KCMainViewController.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;KCImageData.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define ROW_COUNT 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define COLUMN_COUNT 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define ROW_HEIGHT 100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define ROW_WIDTH ROW_HEIGHT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define CELL_SPACING 10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface KCMainViewController ()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSMutableArray *_imageViews;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSMutableArray *_imageNames;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSMutableArray *_threads;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation KCMainViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [super viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self layoutUI];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark 界面布局&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)layoutUI&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //创建多个图片空间用于显示图片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _imageViews=[NSMutableArray array];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (int r=0; r&amp;lt;ROW_COUNT; r++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for (int c=0; c&amp;lt;COLUMN_COUNT; c++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            UIImageView *imageView=[[UIImageView alloc]initWithFrame:CGRectMake(c*ROW_WIDTH+(c*CELL_SPACING), r*ROW_HEIGHT+(r*CELL_SPACING                           ), ROW_WIDTH, ROW_HEIGHT)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            imageView.contentMode=UIViewContentModeScaleAspectFit;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//            imageView.backgroundColor=[UIColor redColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [self.view addSubview:imageView];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [_imageViews addObject:imageView];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //加载按钮&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIButton *buttonStart=[UIButton buttonWithType:UIButtonTypeRoundedRect];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    buttonStart.frame=CGRectMake(50, 500, 100, 25);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [buttonStart setTitle:@&amp;quot;加载图片&amp;quot; forState:UIControlStateNormal];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [buttonStart addTarget:self action:@selector(loadImageWithMultiThread) forControlEvents:UIControlEventTouchUpInside];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addSubview:buttonStart];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //停止按钮&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIButton *buttonStop=[UIButton buttonWithType:UIButtonTypeRoundedRect];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    buttonStop.frame=CGRectMake(160, 500, 100, 25);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [buttonStop setTitle:@&amp;quot;停止加载&amp;quot; forState:UIControlStateNormal];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [buttonStop addTarget:self action:@selector(stopLoadImage) forControlEvents:UIControlEventTouchUpInside];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addSubview:buttonStop];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //创建图片链接&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _imageNames=[NSMutableArray array];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [_imageNames addObject:@    for (int i=0; i&amp;lt;IMAGE_COUNT; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [_imageNames addObject:[NSString stringWithFormat:@&amp;quot;http://images.cnblogs.com/cnblogs_com/kenshincui/613474/o_%i.jpg&amp;quot;,i]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark 将图片显示到界面&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)updateImage:(KCImageData *)imageData&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIImage *image=[UIImage imageWithData:imageData.data];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIImageView *imageView= _imageViews[imageData.index];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    imageView.image=image;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark 请求图片数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(NSData *)requestData:(int )index&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSURL *url=[NSURL URLWithString:_imageNames[index]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSData *data=[NSData dataWithContentsOfURL:url];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark 加载图片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)loadImage:(NSNumber *)index&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int i=[index integerValue];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSData *data= [self requestData:i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSThread *currentThread=[NSThread currentThread];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    如果当前线程处于取消状态，则退出当前线程&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (currentThread.isCancelled) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSLog(@&amp;quot;thread(%@) will be cancelled!&amp;quot;,currentThread);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [NSThread exit];//取消当前线程&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    KCImageData *imageData=[[KCImageData alloc]init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    imageData.index=i;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    imageData.data=data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self performSelectorOnMainThread:@selector(updateImage:) withObject:imageData waitUntilDone:YES];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark 多线程下载图片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)loadImageWithMultiThread&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int count=ROW_COUNT*COLUMN_COUNT;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _threads=[NSMutableArray arrayWithCapacity:count];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //创建多个线程用于填充图片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (int i=0; i&amp;lt;count; ++i) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSThread *thread=[[NSThread alloc]initWithTarget:self selector:@selector(loadImage:) object:[NSNumber numberWithInt:i]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        thread.name=[NSString stringWithFormat:@&amp;quot;myThread%i&amp;quot;,i];//设置线程名称&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [_threads addObject:thread];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //循环启动线程&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (int i=0; i&amp;lt;count; ++i) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSThread *thread= _threads[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [thread start];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark 停止加载图片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)stopLoadImage&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (int i=0; i&amp;lt;ROW_COUNT*COLUMN_COUNT; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSThread *thread= _threads[i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //判断线程是否完成，如果没有完成则设置为取消状态&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //注意设置为取消状态仅仅是改变了线程状态而言，并不能终止线程&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (!thread.isFinished) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [thread cancel];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;运行效果（点击加载大概1秒后点击停止加载）：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; NSThreadEffect3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;使用NSThread在进行多线程开发过程中操作比较简单，但是要控制线程执行顺序并不容易（前面万不得已采用了休眠的方法），另外在这个过程中如果打印线程会发现循环几次就创建了几个线程，这在实际开发过程中是不得不考虑的问题，因为每个线程的创建也是相当占用系统开销的。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;扩展--NSObject分类扩展方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;为了简化多线程开发过程，苹果官方对NSObject进行分类扩展(本质还是创建NSThread)，对于简单的多线程操作可以直接使用这些扩展方法。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)performSelectorInBackground:(SEL)aSelector withObject:(id)arg：在后台执行一个操作，本质就是重新创建一个线程执行当前方法。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait：在指定的线程上执行一个方法，需要用户创建一个线程对象。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait：在主线程上执行一个方法（前面已经使用过）。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;例如前面加载图多个图片的方法，可以改为后台线程执行：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)loadImageWithMultiThread&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int count=ROW_COUNT*COLUMN_COUNT;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (int i=0; i&amp;lt;count; ++i) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [self performSelectorInBackground:@selector(loadImage:) withObject:[NSNumber numberWithInt:i]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;NSOperation&quot;&gt;&lt;a href=&quot;#NSOperation&quot; class=&quot;headerlink&quot; title=&quot;NSOperation&quot;&gt;&lt;/a&gt;NSOperation&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;使用NSOperation和NSOperationQueue进行多线程开发类似于C#中的线程池，只要将一个NSOperation（实际开中需要使用其子类NSInvocationOperation、NSBlockOperation）放到NSOperationQueue这个队列中线程就会依次启动。NSOperationQueue负责管理、执行所有的NSOperation，在这个过程中可以更加容易的管理线程总数和控制线程之间的依赖关系。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSOperation有两个常用子类用于创建线程操作：NSInvocationOperation和NSBlockOperation，两种方式本质没有区别，但是是后者使用Block形式进行代码组织，使用相对方便。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSInvocationOperation&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;首先使用NSInvocationOperation进行一张图片的加载演示，整个过程就是：创建一个操作，在这个操作中指定调用方法和参数，然后加入到操作队列。其他代码基本不用修改，直接修加载图片方法如下：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)loadImageWithMultiThread&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /*创建一个调用操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     object:调用方法参数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSInvocationOperation *invocationOperation=[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(loadImage) object:nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //创建完NSInvocationOperation对象并不会调用，它由一个start方法启动操作，但是注意如果直接调用start方法，则此操作会在主线程中调用，一般不会这么操作,而是添加到NSOperationQueue中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    [invocationOperation start];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //创建操作队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSOperationQueue *operationQueue=[[NSOperationQueue alloc]init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //注意添加到操作队后，队列会开启一个线程执行此操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [operationQueue addOperation:invocationOperation];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSBlockOperation&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;下面采用NSBlockOperation创建多个线程加载图片。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  NSOperation实现多线程&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  MultiThread&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  Created by Kenshin Cui on 14-3-22.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;KCMainViewController.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;KCImageData.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define ROW_COUNT 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define COLUMN_COUNT 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define ROW_HEIGHT 100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define ROW_WIDTH ROW_HEIGHT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define CELL_SPACING 10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface KCMainViewController ()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSMutableArray *_imageViews;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSMutableArray *_imageNames;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation KCMainViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [super viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self layoutUI];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark 界面布局&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)layoutUI&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //创建多个图片控件用于显示图片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _imageViews=[NSMutableArray array];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (int r=0; r&amp;lt;ROW_COUNT; r++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for (int c=0; c&amp;lt;COLUMN_COUNT; c++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            UIImageView *imageView=[[UIImageView alloc]initWithFrame:CGRectMake(c*ROW_WIDTH+(c*CELL_SPACING), r*ROW_HEIGHT+(r*CELL_SPACING                           ), ROW_WIDTH, ROW_HEIGHT)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            imageView.contentMode=UIViewContentModeScaleAspectFit;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//            imageView.backgroundColor=[UIColor redColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [self.view addSubview:imageView];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [_imageViews addObject:imageView];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIButton *button=[UIButton buttonWithType:UIButtonTypeRoundedRect];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    button.frame=CGRectMake(50, 500, 220, 25);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [button setTitle:@&amp;quot;加载图片&amp;quot; forState:UIControlStateNormal];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //添加方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [button addTarget:self action:@selector(loadImageWithMultiThread) forControlEvents:UIControlEventTouchUpInside];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addSubview:button];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //创建图片链接&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _imageNames=[NSMutableArray array];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (int i=0; i&amp;lt;IMAGE_COUNT; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [_imageNames addObject:[NSString stringWithFormat:@&amp;quot;http://images.cnblogs.com/cnblogs_com/kenshincui/613474/o_%i.jpg&amp;quot;,i]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark 将图片显示到界面&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)updateImageWithData:(NSData *)data andIndex:(int )index&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIImage *image=[UIImage imageWithData:data];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIImageView *imageView= _imageViews[index];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    imageView.image=image;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark 请求图片数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(NSData *)requestData:(int )index&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSURL *url=[NSURL URLWithString:_imageNames[index]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSData *data=[NSData dataWithContentsOfURL:url];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark 加载图片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)loadImage:(NSNumber *)index&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int i=[index integerValue];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //请求数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSData *data= [self requestData:i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&amp;quot;%@&amp;quot;,[NSThread currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //更新UI界面,此处调用了主线程队列的方法（mainQueue是UI主线程）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [[NSOperationQueue mainQueue] addOperationWithBlock:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [self updateImageWithData:data andIndex:i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark 多线程下载图片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)loadImageWithMultiThread&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int count=ROW_COUNT*COLUMN_COUNT;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //创建操作队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSOperationQueue *operationQueue=[[NSOperationQueue alloc]init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    operationQueue.maxConcurrentOperationCount=5;//设置最大并发线程数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //创建多个线程用于填充图片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (int i=0; i&amp;lt;count; ++i) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //方法1：创建操作块添加到队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        //创建多线程操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        NSBlockOperation *blockOperation=[NSBlockOperation blockOperationWithBlock:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//            [self loadImage:[NSNumber numberWithInt:i]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        //创建操作队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//        [operationQueue addOperation:blockOperation];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //方法2：直接使用操队列添加操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [operationQueue addOperationWithBlock:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [self loadImage:[NSNumber numberWithInt:i]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;对比之前NSThread加载张图片很发现核心代码简化了不少，这里着重强调两点：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;使用NSBlockOperation方法，所有的操作不必单独定义方法，同时解决了只能传递一个参数的问题。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;调用主线程队列的addOperationWithBlock:方法进行UI更新，不用再定义一个参数实体（之前必须定义一个KCImageData解决只能传递一个参数的问题）。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;使用NSOperation进行多线程开发可以设置最大并发线程，有效的对线程进行了控制（上面的代码运行起来你会发现打印当前进程时只有有限的线程被创建，如上面的代码设置最大线程数为5，则图片基本上是五个一次加载的）。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;线程执行顺序&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;前面使用NSThread很难控制线程的执行顺序，但是使用NSOperation就容易多了，每个NSOperation可以设置依赖线程。假设操作A依赖于操作B，线程操作队列在启动线程时就会首先执行B操作，然后执行A。对于前面优先加载最后一张图的需求，只要设置前面的线程操作的依赖线程为最后一个操作即可。修改图片加载方法如下：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)loadImageWithMultiThread&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int count=ROW_COUNT*COLUMN_COUNT;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //创建操作队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSOperationQueue *operationQueue=[[NSOperationQueue alloc]init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    operationQueue.maxConcurrentOperationCount=5;//设置最大并发线程数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSBlockOperation *lastBlockOperation=[NSBlockOperation blockOperationWithBlock:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [self loadImage:[NSNumber numberWithInt:(count-1)]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //创建多个线程用于填充图片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (int i=0; i&amp;lt;count-1; ++i) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //方法1：创建操作块添加到队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //创建多线程操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NSBlockOperation *blockOperation=[NSBlockOperation blockOperationWithBlock:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [self loadImage:[NSNumber numberWithInt:i]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //设置依赖操作为最后一张图片加载操作&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [blockOperation addDependency:lastBlockOperation];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [operationQueue addOperation:blockOperation];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //将最后一个图片的加载操作加入线程队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [operationQueue addOperation:lastBlockOperation];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;运行效果：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSOperationEffect&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可以看到虽然加载最后一张图片的操作最后被加入到操作队列，但是它却是被第一个执行的。操作依赖关系可以设置多个，例如A依赖于B、B依赖于C…但是千万不要设置为循环依赖关系（例如A依赖于B，B依赖于C，C又依赖于A），否则是不会被执行的。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;GCD&quot;&gt;&lt;a href=&quot;#GCD&quot; class=&quot;headerlink&quot; title=&quot;GCD&quot;&gt;&lt;/a&gt;GCD&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;GCD(Grand Central Dispatch)是基于C语言开发的一套多线程开发机制，也是目前苹果官方推荐的多线程开发方法。前面也说过三种开发中GCD抽象层次最高，当然是用起来也最简单，只是它基于C语言开发，并不像NSOperation是面向对象的开发，而是完全面向过程的。对于熟悉C#异步调用的朋友对于GCD学习起来应该很快，因为它与C#中的异步调用基本是一样的。这种机制相比较于前面两种多线程开发方式最显著的优点就是它对于多核运算更加有效。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;GCD中也有一个类似于NSOperationQueue的队列，GCD统一管理整个队列中的任务。但是GCD中的队列分为并行队列和串行队列两类：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;串行队列：只有一个线程，加入到队列中的操作按添加顺序依次执行。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;并发队列：有多个线程，操作进来之后它会将这些队列安排在可用的处理器上，同时保证先进来的任务优先处理。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;其实在GCD中还有一个特殊队列就是主队列，用来执行主线程上的操作任务（从前面的演示中可以看到其实在NSOperation中也有一个主队列）。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;串行队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;使用串行队列时首先要创建一个串行队列，然后调用异步调用方法，在此方法中传入串行队列和线程操作即可自动执行。下面使用线程队列演示图片的加载过程，你会发现多张图片会按顺序加载，因为当前队列中只有一个线程。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  GCD实现多线程&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  MultiThread&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  Created by Kenshin Cui on 14-3-22.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;KCMainViewController.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;KCImageData.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define ROW_COUNT 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define COLUMN_COUNT 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define ROW_HEIGHT 100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define ROW_WIDTH ROW_HEIGHT&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#define CELL_SPACING 10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface KCMainViewController ()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSMutableArray *_imageViews;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSMutableArray *_imageNames;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation KCMainViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)viewDidLoad &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [super viewDidLoad];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self layoutUI];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark 界面布局&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)layoutUI&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //创建多个图片控件用于显示图片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _imageViews=[NSMutableArray array];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (int r=0; r&amp;lt;ROW_COUNT; r++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for (int c=0; c&amp;lt;COLUMN_COUNT; c++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            UIImageView *imageView=[[UIImageView alloc]initWithFrame:CGRectMake(c*ROW_WIDTH+(c*CELL_SPACING), r*ROW_HEIGHT+(r*CELL_SPACING                           ), ROW_WIDTH, ROW_HEIGHT)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            imageView.contentMode=UIViewContentModeScaleAspectFit;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//            imageView.backgroundColor=[UIColor redColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [self.view addSubview:imageView];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [_imageViews addObject:imageView];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIButton *button=[UIButton buttonWithType:UIButtonTypeRoundedRect];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    button.frame=CGRectMake(50, 500, 220, 25);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [button setTitle:@&amp;quot;加载图片&amp;quot; forState:UIControlStateNormal];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //添加方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [button addTarget:self action:@selector(loadImageWithMultiThread) forControlEvents:UIControlEventTouchUpInside];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addSubview:button];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //创建图片链接&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    _imageNames=[NSMutableArray array];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (int i=0; i&amp;lt;ROW_COUNT*COLUMN_COUNT; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [_imageNames addObject:[NSString stringWithFormat:@&amp;quot;http://images.cnblogs.com/cnblogs_com/kenshincui/613474/o_%i.jpg&amp;quot;,i]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark 将图片显示到界面&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)updateImageWithData:(NSData *)data andIndex:(int )index&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIImage *image=[UIImage imageWithData:data];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIImageView *imageView= _imageViews[index];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    imageView.image=image;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark 请求图片数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(NSData *)requestData:(int )index&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSURL *url=[NSURL URLWithString:_imageNames[index]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSData *data=[NSData dataWithContentsOfURL:url];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark 加载图片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)loadImage:(NSNumber *)index&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //如果在串行队列中会发现当前线程打印变化完全一样，因为他们在一个线程中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&amp;quot;thread is :%@&amp;quot;,[NSThread currentThread]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int i=[index integerValue];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //请求数据&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSData *data= [self requestData:i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //更新UI界面,此处调用了GCD主线程队列的方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_queue_t mainQueue= dispatch_get_main_queue();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_sync(mainQueue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [self updateImageWithData:data andIndex:i];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark 多线程下载图片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)loadImageWithMultiThread&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int count=ROW_COUNT*COLUMN_COUNT;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /*创建一个串行队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     第一个参数：队列名称&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     第二个参数：队列类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_queue_t serialQueue=dispatch_queue_create(&amp;quot;myThreadQueue1&amp;quot;, DISPATCH_QUEUE_SERIAL);//注意queue对象不是指针类型&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //创建多个线程用于填充图片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (int i=0; i&amp;lt;count; ++i) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //异步执行队列任务&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dispatch_async(serialQueue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [self loadImage:[NSNumber numberWithInt:i]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //非ARC环境请释放&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//    dispatch_release(seriQueue);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;运行效果：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;GCDEffect1 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在上面的代码中更新UI还使用了GCD方法的主线程队列dispatch_get_main_queue()，其实这与前面两种主线程更新UI没有本质的区别。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;并发队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;并发队列同样是使用dispatch_queue_create()方法创建，只是最后一个参数指定为DISPATCH_QUEUE_CONCURRENT进行创建，但是在实际开发中我们通常不会重新创建一个并发队列而是使用dispatch_get_global_queue()方法取得一个全局的并发队列（当然如果有多个并发队列可以使用前者创建）。下面通过并行队列演示一下多个图片的加载。代码与上面串行队列加载类似，只需要修改照片加载方法如下：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)loadImageWithMultiThread&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int count=ROW_COUNT*COLUMN_COUNT;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    /*取得全局队列&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     第一个参数：线程优先级&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     第二个参数：标记参数，目前没有用，一般传入0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    dispatch_queue_t globalQueue=dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //创建多个线程用于填充图片&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    for (int i=0; i&amp;lt;count; ++i) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        //异步执行队列任务&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dispatch_async(globalQueue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [self loadImage:[NSNumber numberWithInt:i]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;运行效果：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;GCDEffect2 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;细心的朋友肯定会思考，既然可以使用dispatch_async()异步调用方法，是不是还有同步方法，确实如此，在GCD中还有一个dispatch_sync()方法。假设将上面的代码修改为同步调用，可以看到如下效果：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;GCDEffect3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可以看点击按钮后按钮无法再次点击，因为所有图片的加载全部在主线程中（可以打印线程查看），主线程被阻塞，造成图片最终是一次性显示。可以得出结论：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在GDC中一个操作是多线程执行还是单线程执行取决于当前队列类型和执行方法，只有队列类型为并行队列并且使用异步方法执行时才能在多个线程中执行。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;串行队列可以按顺序执行，并行队列的异步方法无法确定执行顺序。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UI界面的更新最好采用同步方法，其他操作采用异步方法。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;其他任务执行方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;GCD执行任务的方法并非只有简单的同步调用方法和异步调用方法，还有其他一些常用方法：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_apply():重复执行某个任务，但是注意这个方法没有办法异步执行（为了不阻塞线程可以使用dispatch_async()包装一下再执行）。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_once():单次执行一个任务，此方法中的任务只会执行一次，重复调用也没办法重复执行（单例模式中常用此方法）。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_time()：延迟一定的时间后执行。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_barrier_async()：使用此方法创建的任务首先会查看队列中有没有别的任务要执行，如果有，则会等待已有任务执行完毕再执行；同时在此方法后添加的任务必须等待此方法中任务执行后才能执行。（利用这个方法可以控制执行顺序，例如前面先加载最后一张图片的需求就可以先使用这个方法将最后一张图片加载的操作添加到队列，然后调用dispatch_async()添加其他图片加载任务）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_group_async()：实现对任务分组管理，如果一组任务全部完成可以通过dispatch_group_notify()方法获得完成通知（需要定义dispatch_group_t作为分组标识）。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;几种延时执行的方法&quot;&gt;&lt;a href=&quot;#几种延时执行的方法&quot; class=&quot;headerlink&quot; title=&quot;几种延时执行的方法&quot;&gt;&lt;/a&gt;几种延时执行的方法&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;假如延时1秒时间执行下面的方法。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)delayMethod&amp;#123;    NSLog(@&amp;quot;execute&amp;quot;);&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1.performSelector方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self performSelector:@selector(delayMethod) withObject:nil afterDelay:1.0f];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;此方式要求必须在主线程中执行，否则无效。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;是一种非阻塞的执行方式，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;暂时未找到取消执行的方法。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.定时器:NSTimer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[NSTimer scheduledTimerWithTimeInterval:1.0f target:self selector:@selector(delayMethod) userInfo:nil repeats:NO];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;此方式要求必须在主线程中执行，否则无效。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;是一种非阻塞的执行方式，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可以通过NSTimer类的- (void)invalidate;取消执行。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3. sleep方式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[NSThread sleepForTimeInterval:1.0f];[self delayMethod];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;此方式在主线程和子线程中均可执行。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;是一种阻塞的执行方式，建议方放到子线程中，以免卡住界面&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;没有找到取消执行的方法。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4.GCD方式&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;double delayInSeconds = 1.0;__block ViewController* bself = self;dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC));dispatch_after(popTime, dispatch_get_main_queue(), ^(void)&amp;#123;    [bself delayMethod];&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;此方式在可以在参数中选择执行的线程。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;是一种非阻塞的执行方式，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;没有找到取消执行的方法&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;多线程在iOS的开发中应用的场景非常多，自己还不能整理完全，转一下别人的博客，自己稍作记录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/kenshincui/p/3983982.html&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS-ObjectiveC" scheme="http://yoursite.com/categories/iOS-ObjectiveC/"/>
    
    
  </entry>
  
  <entry>
    <title>Block</title>
    <link href="http://yoursite.com/2016/06/15/Block/"/>
    <id>http://yoursite.com/2016/06/15/Block/</id>
    <published>2016-06-15T03:59:08.000Z</published>
    <updated>2016-08-04T02:16:27.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;block在iOS编程中有着非常重要的作用，目前对block的理解只存在于表面的应用上，希望以后不断补充这篇介绍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;block是什么&quot;&gt;&lt;a href=&quot;#block是什么&quot; class=&quot;headerlink&quot; title=&quot;block是什么&quot;&gt;&lt;/a&gt;block是什么&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;简单定义：能持有作用域变量的匿名函数&lt;/li&gt;
&lt;li&gt;匿名函数就是没有名称的函数，C 语言的标准不允许存在这样的函数，而通过 Block，源代码中就可以使用匿名函数了。&lt;/li&gt;
&lt;li&gt;能持有作用域变量就是指 Block 能够获得其所在作用域的变量。其中其所在作用域的变量就包括：局部变量（自动变量）、函数的参数、静态局部变量、静态全局变量、全局变量。&lt;/li&gt;
&lt;li&gt;block的作用：用来保存某一段代码。可以在恰当的时间取出来调用。功能点类似于函数和方法，是iOS中一种比较特殊的数据类型&lt;/li&gt;
&lt;li&gt;Block 能够让我们创建明显的代码片段，并且可以像参数那样传递给方法或函数。在 Objective-C 中&lt;/li&gt;
&lt;li&gt;Block 就像对象一样，能够被添加到集合中（比如：NSArray、NSDictionary）。Block 能够获得其所在作用域的变量&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Block-语法形式&quot;&gt;&lt;a href=&quot;#Block-语法形式&quot; class=&quot;headerlink&quot; title=&quot;Block 语法形式&quot;&gt;&lt;/a&gt;Block 语法形式&lt;/h3&gt;&lt;p&gt;Block 的语法遵循如下形式：&lt;br&gt;^ 返回值类型 参数列表 表达式&lt;/p&gt;
&lt;p&gt;一些示例：&lt;br&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw1024/bc254b75jw1f4vvaa9wcij20fg06cjsr.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;^(传入参数列){行为主体};&lt;/p&gt;
&lt;p&gt;^(int a){return a*a;}; &lt;/p&gt;
&lt;p&gt;int result = ^(int a){return a*a;};&lt;br&gt;NSLog(@”%d”, result);&lt;/p&gt;
&lt;p&gt;// 一个最简单的 block：&lt;br&gt;^{&lt;br&gt;    NSLog(@”This is a block”);&lt;br&gt;}&lt;br&gt;// 不省略的 block：&lt;br&gt;^void (void) {&lt;br&gt;    NSLog(@”This is a block”);&lt;br&gt;}&lt;br&gt;// 普通的 block：&lt;br&gt;^int (int a, int b) {&lt;br&gt;    NSLog(@”a is %d, b is %d”, a, b);&lt;br&gt;    return a + b;&lt;br&gt;}&lt;/p&gt;
&lt;h3 id=&quot;一些简单的使用&quot;&gt;&lt;a href=&quot;#一些简单的使用&quot; class=&quot;headerlink&quot; title=&quot;一些简单的使用&quot;&gt;&lt;/a&gt;一些简单的使用&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;* 最简单的 Block&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;声明和定义一个不返回任何值，不接受任何参数的 Block：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 完整的写法：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//// 声明&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void (^simpleBlock)(void); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//// 定义&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;simpleBlock = ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&amp;quot;This is a block&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//// 声明、定义一起&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void (^simpleBlock)(void) = ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&amp;quot;This is a block&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 调用 block&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;simpleBlock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 带参数和返回值的 Block&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;下面的 Block，接受两个 double 参数，返回一个 double 值：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 声明&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;double (^multiplyTwoValues)(double, double);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 定义&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;double (^multiplyTwoValues)(double, double) =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                          ^(double firstValue, double secondValue) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                              return firstValue * secondValue;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                          &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 调用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;double result = multiplyTwoValues(2,4);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSLog(@&amp;quot;The result is %f&amp;quot;, result);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* Block 作为参数时的缩写&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Block 作为参数时的缩写如 Block 语法规则所约定那样。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Block 没有参数，则 `()` 可以省略：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[UIView animateViewDuration:5.0 animation:^() &amp;#123; // 这个 block 没有参数，这里的 () 就可以省略。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	view.opacity = 0.5;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 如果 Block 中返回值的类型根据 return 后的内容能明显推出，那么可以省略：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSSet* mySet = ...;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSSet* matches = [mySet objectsPassingTest:^BOOL(id obj, ...) &amp;#123; // 根据return语句，这个block的返回值明显是BOOL，所以这里可以省略BOOL。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return [obj isKindOfClass:[UIView class]]; // 返回值是 BOOL，很明显。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 把 Block 传递给方法或函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 调用带 block 参数的方法：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (IBAction)fetchRemoteInformation:(id)sender &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self showProgressIndicator];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    XYZWebTask *task = ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [task beginTaskWithCallbackBlock:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [self hideProgressIndicator];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 声明带 block 参数的方法：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)beginTaskWithCallbackBlock:(void (^)(void))callbackBlock;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 方法的具体实现：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)beginTaskWithCallbackBlock:(void (^)(void))callbackBlock &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	callbackBlock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;苹果的建议是在一个方法中最好只使用一个 block 变量，并且如果这个方法如果还带有其他非 block 变量，那么 block 变量应该放在最后一个。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 使用 typedef 来简化 Block 定义&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;上面的 Block 类型的变量在使用时，记述方式会一眼看上去有点不够简洁，这时候我们也可以用 typedef 来解决这个问题。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// typedef 一个 block&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;typedef void (^XYZSimpleBlock)(void);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 使用 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;XYZSimpleBlock anotherBlock = ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 使用 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)beginFetchWithCallbackBlock:(XYZSimpleBlock)callbackBlock &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	callbackBlock();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;来看一个用 typedef 简化复杂 Block 定义的例子，下面的定义的名为 complexBlock 的变量是一个 block，这个 block 接受一个 block 作为参数，并且返回一个 block：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 简化前：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void (^(^complexBlock)(void (^)(void)))(void) = ^ (void (^aBlock)(void)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 使用上面 typedef 的 XYZSimpleBlock 简化后：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;XYZSimpleBlock (^betterBlock)(XYZSimpleBlock) = ^ (XYZSimpleBlock aBlock) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* 定义属性来持有 Block&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;使用 copy，因为 Block 要持有它原本所在作用域的其他外面的变量：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface XYZObject : NSObject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (copy) void (^blockProperty)(void);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// setter 方法和调用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;self.blockProperty = ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;self.blockProperty();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 使用 typedef 简化&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;typedef void (^XYZSimpleBlock)(void);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface XYZObject : NSObject&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (copy) XYZSimpleBlock blockProperty;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;block的使用场景&quot;&gt;&lt;a href=&quot;#block的使用场景&quot; class=&quot;headerlink&quot; title=&quot;block的使用场景&quot;&gt;&lt;/a&gt;block的使用场景&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;* Block 简化枚举&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// NSArray 的一个方法，接受一个 block 作为参数，这个 block 会在该方法里每枚举一个对象时被调用一次：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)enumerateObjectsUsingBlock:(void (^)(id obj, NSUInteger idx, BOOL *stop))block;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 这个 block 接受三个参数，前两个是当前的对象和其 index，后面的 BOOL 值可以用来控制什么时候停止该枚举。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSArray *array = ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[array enumerateObjectsUsingBlock:^ (id obj, NSUInteger idx, BOOL *stop) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&amp;quot;Object at index %lu is %@&amp;quot;, idx, obj);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[array enumerateObjectsUsingBlock:^ (id obj, NSUInteger idx, BOOL *stop) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (...) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        *stop = YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* Block 简化并发调用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Block 和 Operation Queue 一起用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* Block 和 GCD 一起用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dispatch_async(queue, ^&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSLog(@&amp;quot;Block for asynchronous execution&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;GCD主要使用block来代替委托模式,使程序变得简洁,同时运行效率也得到提高.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   static int clickNum = 0;   self.Mylabel = [[UILabel alloc]init];   while (clickNum &amp;lt;20) &amp;#123;   dispatch_async(dispatch_get_main_queue(), ^&amp;#123;   self.Mylabel.text = [NSString stringWithFormat:@&amp;quot;%d&amp;quot;,clickNum++];//UI的绘制必须在主线程中   &amp;#125;);   [NSThread sleepForTimeInterval:1];     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cocoaTouch框架下动画效果的Block的调用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[UIView transitionWithView:self.view                          duration:0.2                           options:UIViewAnimationOptionTransitionFlipFromLeft                        animations:^&amp;#123; [self.view addSubview:yellowView.view]; &amp;#125;                        completion:NULL];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* Block 的使用场景小结&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Enumeration (像我们上面看到的 NSArray 的枚举接口)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;View Animations (animations)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Sorting (在排序时在 Block 中实现比较逻辑)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Notification (当某些事件被触发时，执行对应的 Block)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Error handlers (作为错误事件的 Handler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Completion handlers (作为某个任务完成时的 Handler)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Multithreading (在 Grand Central Dispatch (GCD) API 中使用)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;一些补充&quot;&gt;&lt;a href=&quot;#一些补充&quot; class=&quot;headerlink&quot; title=&quot;一些补充&quot;&gt;&lt;/a&gt;一些补充&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;* 函数内部使用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在函数内部定义并实现的block有点类似于java的匿名内部类，这种block也只能作用于当前函数。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;示例：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)testBlock&amp;#123;    void (^blockTest)(int) = ^(int num)&amp;#123;        NSLog(@&amp;quot;num:%d&amp;quot;,num);    &amp;#125;;    blockTest(2);&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;关于回调&quot;&gt;&lt;a href=&quot;#关于回调&quot; class=&quot;headerlink&quot; title=&quot;关于回调&quot;&gt;&lt;/a&gt;关于回调&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫回调函数，你把电话留给店员就叫登记回调函数，店里后来有货了叫做触发了回调关联的事件，店员给你打电话叫做调用回调函数，你到店里去取货叫做响应回调事件.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;callback(回调)就是一段「代码」，我们会通过某种途径，将这段「代码」和一个特定的事件(event)联系起来，当特定事件(event)发生后，这段「代码」被执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;为什么要有「回调-callback-」&quot;&gt;&lt;a href=&quot;#为什么要有「回调-callback-」&quot; class=&quot;headerlink&quot; title=&quot;为什么要有「回调(callback)」&quot;&gt;&lt;/a&gt;为什么要有「回调(callback)」&lt;/h3&gt;&lt;p&gt;「非事件驱动」型程序&lt;br&gt;「事件驱动(event-driven)」型程序&lt;br&gt;「非事件驱动」型程序。&lt;br&gt;这类程序，遵循这样一个流程：启动程序 -&amp;gt; 执行程序(代码) -&amp;gt; 退出程序。程序会在执行完所有代码后，立刻退出，中途不会有任何事件(event)发生(除非有bug)。&lt;/p&gt;
&lt;p&gt;「事件驱动(event-driven)」型程序&lt;br&gt;这类程序，遵循这样一个流程：启动程序 -&amp;gt; 等待事件(event) -&amp;gt; 事件被触发 -&amp;gt; 执行callback(回调) -&amp;gt; 继续等待事件(event) -&amp;gt; 人为退出程序。&lt;/p&gt;
&lt;p&gt;打个比方，我想用淘宝APP帮手机充值，一打开APP，它并不会马上跳到充值页面，是要等待我的点击事件，当点击了充值的按钮，才会跳到充值页面(执行了callback)。&lt;/p&gt;
&lt;p&gt;所以，大家应该很容易联想到，iOS的应用几乎都是「事件驱动(event-driven)」的，应用一经启动，就在等待事件的发生，当发生某个事件(比如点击了某个按钮)，应用就会执行某段代码(callback)进行响应。&lt;/p&gt;
&lt;p&gt;这里的「事件(event)」，是非常宽泛的，可以是使用者的一次点击、可以是系统的一次通知、可以是服务器返回的一次数据、可以是蓝牙外设连接成功后，发送给手机的一条指令等等。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;实例1-数据更新触发回调&quot;&gt;&lt;a href=&quot;#实例1-数据更新触发回调&quot; class=&quot;headerlink&quot; title=&quot;实例1 数据更新触发回调&quot;&gt;&lt;/a&gt;实例1 数据更新触发回调&lt;/h3&gt;&lt;p&gt;在个人主页我们需要显示用户的昵称、头像、性别、签名，然后点击编辑按钮，跳转到编辑个人信息页面，编辑完个人信息之后，点击返回到主页的时候，我们需要根据用户设定的值来更新相应的信息。&lt;br&gt;个人主页&lt;br&gt;|&lt;br&gt;|&lt;br&gt;编辑用户信息&lt;br&gt;|&lt;br&gt;|&lt;br&gt;实现代码如下(同block传值)：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;personalHomePage.m文件  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;**************************&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)editPersonalInfo&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    EditPersonalInfoController *edit = [[SGEditPersonalInfoController alloc]init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __weak typeof(self)weakself = self;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    edit.updateUserInfoBlock = ^(NSString *userName, NSString *userSex, NSString *userSign ,UIImage *userImage)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        weakself.userHeaderImageView.image = [userImage circleImage];//用户头像&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        weakself.nickNameLabel.text = userName;//昵称&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        weakself.signLabel.text = userSign;//签名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        weakself.sexImageView.image = ([userSex isEqualToString:@&amp;quot;女&amp;quot;]) ? [UIImage imageNamed:@&amp;quot;icon_female&amp;quot;] : [UIImage imageNamed:@&amp;quot;icon_male&amp;quot;];//性别&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;EditPersonalInfoController.h文件  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;***********************************&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface EditPersonalInfoController :UITableViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property(nonatomic, copy)void(^updateUserInfoBlock)(NSString *userName, NSString *userSex, NSString *userSign ,UIImage *userImage) ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;EditPersonalInfoController.m文件  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;***********************************&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)personalInfoHadChanged&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (self.updateUserInfoBlock) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.updateUserInfoBlock(self.userName, self.userSex, self.userSign, self.userImage);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;为了方便叙述，我们做如下规定： personalHomePage类为A，EditPersonalInfoController为B&lt;/p&gt;
&lt;p&gt;1、首先我们在A页面的editPersonalInfo方法里面跳转到B页面，在这个方法里面我们登记回调函数（block），这个回调函数的作用就是更新A页面的信息。&lt;/p&gt;
&lt;p&gt;2、首先B页面需要申明回调函数，就是@property(nonatomic, copy)void(^updateUserInfoBlock)(NSString &lt;em&gt;userName, NSString &lt;/em&gt;userSex, NSString &lt;em&gt;userSign ,UIImage &lt;/em&gt;userImage) ; &lt;/p&gt;
&lt;p&gt;，然后B页面在个人信息被更改，这个时候触发了回调关联的事件，调用方法personalInfoHadChanged方法，在方法里面来调用回调函数，参数就是自己页面更改的信息。&lt;/p&gt;
&lt;p&gt;3、一旦回调函数被调用，A页面就响应回调事件，作用就是根据B页面传递过来的参数更改A页面的各个控件的值。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;   edit.updateUserInfoBlock = ^(NSString *userName, NSString *userSex, NSString *userSign ,UIImage *userImage)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       weakself.userHeaderImageView.image = [userImage circleImage];//用户头像&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       weakself.nickNameLabel.text = userName;//昵称&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       weakself.signLabel.text = userSign;//签名&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       weakself.sexImageView.image = ([userSex isEqualToString:@&amp;quot;女&amp;quot;]) ? [UIImage imageNamed:@&amp;quot;icon_female&amp;quot;] : [UIImage imageNamed:@&amp;quot;icon_male&amp;quot;];//性别&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;实例2&lt;br&gt;网络错误View（一个通用的显示网络连接错误的页面）&lt;/p&gt;
&lt;p&gt;我们需要给该view添加一个Tap手势，当用户点击的时候我们就触发回调函数，让使用该viwe的控制器去重新加载数据。&lt;/p&gt;
&lt;p&gt;代码实现：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NetworkErrorPromptView.h文件  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;**********************************&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface NetworkErrorPromptView : UIView&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property(copy,nonatomic)void(^reloadBlock)();//申明回调函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NetworkErrorPromptView.m文件  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;**********************************&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation NetworkErrorPromptView&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(instancetype)initWithFrame:(CGRect)frame&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (self == [super initWithFrame:frame]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self = [[[NSBundle mainBundle] loadNibNamed:NSStringFromClass([self class]) owner:nil options:nil] firstObject];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [self addGestureRecognizer:[[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(reload)]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return self;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)reload&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (self.reloadBlock)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.reloadBlock();//调用回调函数&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;假设在一个UITableViewController里面使用了该view，使用懒加载初始化该view&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(NetworkErrorPromptView*)errorView&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (!_errorView) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _errorView = [[SGNetworkErrorPromptView alloc]init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _errorView.frame = CGRectMake(0, 0, self.tableView.w, self.tableView.h);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        __weak typeof(self) weakself = self;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        _errorView.reloadBlock = ^&amp;#123;//登记回调函数，被触发就调用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            [weakself.tableView.mj_header beginRefreshing];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return _errorView;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;PS：&lt;br&gt;实例1和实例2非常类似，只是触发回调函数的方式不一样而已，大家理解了实例1，实例2应该不难理解。 所以我就不再一步步的讲解，只是在使用和触发回调函数的地方做了注释&lt;/p&gt;
&lt;h3 id=&quot;iOS有四种回调模式&quot;&gt;&lt;a href=&quot;#iOS有四种回调模式&quot; class=&quot;headerlink&quot; title=&quot;iOS有四种回调模式&quot;&gt;&lt;/a&gt;iOS有四种回调模式&lt;/h3&gt;&lt;p&gt;1 Target-action/目标动作对&lt;/p&gt;
&lt;p&gt;2 Helper objects/辅助对象–&amp;gt;delegates&amp;amp;data sources&lt;/p&gt;
&lt;p&gt;3 Notifications/通告&lt;/p&gt;
&lt;p&gt;4 Blocks&lt;/p&gt;
&lt;p&gt;我们上面讲解的是使用block实现回调，因为block的语法看起来有些怪异，所以很多人刚开始使用block实现回调函数就容易出错。&lt;/p&gt;
&lt;p&gt;其实block我们可以理解为简版的delegate模式，delegate模式我相信大家理解起来不困难吧，我们经常使用UITableViewController就有很多代理方法。&lt;/p&gt;
&lt;p&gt;代理模式就是A页面在特定状态（我们上面说的实例1和2）委托B页面去做某一件事（触发回调函数）。&lt;/p&gt;
&lt;p&gt;仔细想一下是不是就是block啊。&lt;/p&gt;
&lt;p&gt;如果你不熟悉block的使用，完全可以使用delegate来代替block，用多了就理解回调函数了，然后你想用delegate还是block亦或是notification都可以。（notification少用，影响性能）&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;p&gt;我们知道如何使用回调函数，那么我们什么时候才需要用到回调函数呢？&lt;/p&gt;
&lt;p&gt;结合上面的实例1和2，我们不难发现，以下场景需要使用回调函数。&lt;/p&gt;
&lt;p&gt;如果我们的代码逻辑就是从上到下按顺序执行，中途不需要去做其他的逻辑，那就没必要使用回调函数了。&lt;/p&gt;
&lt;p&gt;如果我们需要让只有当某一特定条件满足的时候（数据被更新，用户点击事件），我们才会去执行一段逻辑。这个时候我们就需要使用回调函数来实现了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;block在iOS编程中有着非常重要的作用，目前对block的理解只存在于表面的应用上，希望以后不断补充这篇介绍。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS-ObjectiveC" scheme="http://yoursite.com/categories/iOS-ObjectiveC/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS中的MVC概念</title>
    <link href="http://yoursite.com/2016/06/15/iOS%E4%B8%AD%E7%9A%84MVC%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2016/06/15/iOS中的MVC概念/</id>
    <published>2016-06-15T03:41:21.000Z</published>
    <updated>2016-06-24T02:05:22.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;在转一篇对MVC的总结文章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.samirchen.com/mvc-in-ios/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;原版&lt;/a&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;Model&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Model 是 What your application is(but not how it is desplayed)，各种数据以及它们之间的逻辑等都是Model，Model是独立于UI的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Controller&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Controller 是 How your Model is presented to the user (UI logic)，即UI逻辑，Controller来把Mode的数据和逻辑表达出来，绘制、展示到屏幕上。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;View&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;View 是 Your Controller’s minions，是Controller要用到的各种基础性的UI元素（Genetic UI Element），是Controller表达Model数据和逻辑用到的工具。&lt;/p&gt;
&lt;p&gt;总的来说，就是 Controller 用 View 来把 Model 表达到屏幕上。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;M、V、C之间如何对话&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Controller —&amp;gt; Model (OK)&lt;/p&gt;
&lt;p&gt;Controller 对相应的 Model 说话是很正常的。&lt;/p&gt;
&lt;p&gt;Controller —&amp;gt; Vew (OK)&lt;/p&gt;
&lt;p&gt;Controller 对相应的 View 说话也是很正常的。&lt;/p&gt;
&lt;p&gt;Model &amp;lt;—&amp;gt; View (Never)&lt;/p&gt;
&lt;p&gt;Model 和 View 之间则永远不要对话！&lt;/p&gt;
&lt;p&gt;View —&amp;gt; Controller (Limited)&lt;/p&gt;
&lt;p&gt;View 一般不要对 Controller 直接说话。但有时候，确实有这个需要，所以有以下几种方式让View对Controller说话：&lt;/p&gt;
&lt;p&gt;action - target&lt;/p&gt;
&lt;p&gt;Controller 在自己上面放了 target 明确告诉 View 的 action 去和这个 target 对话。比如一个 button 的 touch 动作触发时去告诉 Controller 的 target 这个 action，让 Controller 在这个 action 中做点什么。其实 View 这时候是不知道关于这个 target 背后的这个 Controller 的任何信息的。所以&lt;/p&gt;
&lt;p&gt;It is a blind, simple, structured way for the view to communicate with the controller.&lt;/p&gt;
&lt;p&gt;delegate&lt;/p&gt;
&lt;p&gt;View 和 Controller 对话还有更复杂的方式，比如当一个 ScrollView 被滑动了，滑动停止时，View 需要告诉 Controller 滑动停止了，像我们常见的 will，should，did 类的方法，它们就是在 Controller 里设置了代理 Delegate 去响应这些消息，对 View 来说，它也不知道 Controller 的具体信息，它只是知道 Controller 能响应它的那些 will，should，did 类的消息。要使用 Delegate 模式，就涉及到 protocal。&lt;/p&gt;
&lt;p&gt;A protocal is a blind way to talk to another object.&lt;/p&gt;
&lt;p&gt;datasource&lt;/p&gt;
&lt;p&gt;View 不持有它所显示的数据，这些数据应该是属于 Model 的。View 常常通过 datasource 来询问数据，它通常会向 datasource 询问 count，data at * index 之类的消息，其实 datasource 就是另一种 delegate，很明显 Controller 应该作为 View 的 datasource delegate，而不是 Model。当 View 询问数据相关的消息时，Controller 则先去询问 Model 然后再作为 datasource delegate 来响应 View。&lt;/p&gt;
&lt;p&gt;Data source is just a kind of delegate, it’s a specific kind of delegate for getting data.&lt;/p&gt;
&lt;p&gt;Model —&amp;gt; Controller (Limited)&lt;/p&gt;
&lt;p&gt;Model 一般也不要对 Controller 直接对话。但有时候也有需求，所以提供了一些机制来满足这些需求：&lt;/p&gt;
&lt;p&gt;Notification &amp;amp; KVO(Key Value Observing)&lt;/p&gt;
&lt;p&gt;有时候 Model 中的某些东西改变了，比如数据改变了、网络连通了等，它需要告诉 Controller。这时候我们用 “radio station”，类似广播机制去通知任何对这信息感兴趣的对象，这就是常用的 Notification(通知中心) &amp;amp; KVO(Key Value Observing，键值观察)。这就相当于 Model 在广播里吼 “我Model这某时某刻某些东东发生变动了，大家快来看啊！”，这时 Controller 就调到那个广播频道听到了，知道 Model 那某些东东发生变化了，然后它对此感兴趣就通过 Control—&amp;gt;Model 这个途径去 Model 那取那些发生变化的数据。&lt;/p&gt;
&lt;p&gt;MVC对话示意图&lt;br&gt;&lt;img src=&quot;http://www.samirchen.com/images/mvc-in-ios/mvc-communication.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在转一篇对MVC的总结文章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.samirchen.com/mvc-in-ios/&quot;&gt;原版&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS应用程序的生命周期</title>
    <link href="http://yoursite.com/2016/06/15/iOS%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2016/06/15/iOS应用程序的生命周期/</id>
    <published>2016-06-15T01:34:12.000Z</published>
    <updated>2016-06-24T02:06:38.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;本文介绍iOS应用程序的生命周期&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/mw1024/bc254b75jw1f4vo55m8hkj20yx14ktez.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw1024/bc254b75jw1f4vo77jo3yj20ft07xacb.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;启动过程&quot;&gt;&lt;a href=&quot;#启动过程&quot; class=&quot;headerlink&quot; title=&quot;启动过程&quot;&gt;&lt;/a&gt;启动过程&lt;/h3&gt;&lt;p&gt;上面两张图都描了一个应用的生命周期。&lt;br&gt;首先是打开程序执行main函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;main函数做了什么呢？&lt;br&gt;int main(int argc, char * argv[]) {&lt;br&gt;  @autoreleasepool {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  }&lt;br&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;原型函数如下：&lt;br&gt;UIKIT_EXTERN int UIApplicationMain(int argc, char &lt;em&gt;argv[], NSString &lt;/em&gt;principalClassName, NSString *delegateClassName);&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前两个参数：argc和argv：是ISO C标准的main函数的参数，直接传递给UIApplicationMain进行相关处理。参数包含应用程序何时从系统启动等信息。这些参数是由UIKit的基础设施解析，否则可以忽略不计。 &lt;/p&gt;
&lt;p&gt;后两个参数：分别表示程序的主要类(principal class)和代理类(delegate class)。如果主要类(principal class)为nil，将从Info.plist中获取，如果Info.plist中不存在对应的key，则默认为UIApplication；如果代理类(delegate class)将在新建工程时创建。代理类关乎着应用程序的生命周期。&lt;/p&gt;
&lt;p&gt;Main&lt;br&gt;↓&lt;br&gt;创建Uiapplicaiton 对象（如果为nil,则用UIApplication类作为默认值），并创建一个delegate（NSStringFromClass([AppDelegate class])，一般新建项目时候会自动生成，当然也可以更改别的类为代理对象）&lt;br&gt;对象，并将该对象赋值给UIApplication对象中的delegate属性&lt;br&gt;↓&lt;br&gt;开启事件循环   Main Runloop   (可以暂时理解为一个死循环，按照顺序进行事件处理)&lt;br&gt;↓&lt;br&gt;监听（用户交互时产生的事件，由UIApplication对象来分发给control objects对应的target objects来处理并且管理整个事件循环，而一些关于app运行时重要事件委托给app delegate来处理。）&lt;/p&gt;
&lt;p&gt;以上就是启动过程。&lt;/p&gt;
&lt;h3 id=&quot;启动过后的处理过程&quot;&gt;&lt;a href=&quot;#启动过后的处理过程&quot; class=&quot;headerlink&quot; title=&quot;启动过后的处理过程&quot;&gt;&lt;/a&gt;启动过后的处理过程&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw1024/bc254b75jw1f4vo551h0sj20ed09l75c.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;UIApplication对象&lt;br&gt;交互时产生的事件交由UIApplication对象来分发给control objects(UIControl)对应的target objects来处理并且管理整个事件循环，而一些关于app运行时重要事件委托给app delegate来处理。&lt;/p&gt;
&lt;p&gt;App delegate对象&lt;br&gt;App delegate对象遵循UIApplicationDelegate协议，响应app运行时重要事件(app启动、app内存不足、app终止、切换到另一个app、切回app)，主要用于app在启动时初始化一些重要数据结构；例如，初始化UIWindow，设置一些属性，为window添加rootViewController。&lt;/p&gt;
&lt;p&gt;View controller对象&lt;br&gt;View Controller有一个view属性是view层次结构中的根view，你可以添加子view来构建复杂的view；controller有一些viewDidLoad、viewWillAppear等方法来管理view的生命周期；由于它继承UIResponder，所有还会响应和处理用户事件。&lt;/p&gt;
&lt;p&gt;Documents和data model对象&lt;br&gt;data model对象主要用来存储数据。例如，饿了么app在搜索切换地址后，有历史记录搜索地址历史，当app下次启动时，读取和显示搜索地址历史。&lt;/p&gt;
&lt;p&gt;document对象(继承UIDocument)用来管理一些或所有的data model对象。document对象并不是必须的，但提供一种方便的方式来分组属于单个文件或多个文件的数据。&lt;/p&gt;
&lt;p&gt;UIWindow对象&lt;br&gt;UIWindow对象位于view层次结构中的最顶层，它充当一个基本容器而不显示内容，如果想显示内容，添加一个content view到window。&lt;br&gt;它也是继承UIResponder，所以它也是会响应和处理用户事件。&lt;/p&gt;
&lt;p&gt;View、control、layer对象&lt;br&gt;View对象可以通过addSubview和removeFromSuperview 等方法管理view的层次结构，使用layoutSubviews、layoutIfNeeded和setNeedsLayout等方法布局view的层次结构，当你发现系统提供view已经满足不了你想要的外观需求时，可以重写drawRect方法或通过layer属性来构造复杂的图形外观和动画。还有一点，UIView也是继承UIResponder，所以也能够处理用户事件。&lt;/p&gt;
&lt;p&gt;Control对象通常就是处理特定类型用户交互的View，常用的有button、switch、text field等。&lt;br&gt;除了使用View和Control来构建view层次结构来影响app外观之外，还可以使用Core Animation框架的Layer对象来渲染view外观和构建复杂的动画。&lt;/p&gt;
&lt;p&gt;apppdelegate中的APP运行重要事件：&lt;br&gt;application:willFinishLaunchingWithOptions: - 这个方法是你在启动时的第一次机会来执行代码&lt;br&gt;application:didFinishLaunchingWithOptions: - 这个方法允许你在显示app给用户之前执行最后的初始化操作&lt;br&gt;applicationDidBecomeActive: - app已经切换到active状态后需要执行的操作&lt;br&gt;applicationWillResignActive: - app将要从前台切换到后台时需要执行的操作&lt;br&gt;applicationDidEnterBackground: - app已经进入后台后需要执行的操作&lt;br&gt;applicationWillEnterForeground: - app将要从后台切换到前台需要执行的操作，但app还不是active状态&lt;br&gt;applicationWillTerminate: - app将要结束时需要执行的操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw1024/bc254b75jw1f4vo55b1w3j20h60bvwfp.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;相关的操作事件被系统生成并通过UIKit的指定端口分发。事件在内部排成队列，一个个的分发到Main run loop 去做处理。UIApplication对象是第一个接收到时间的对象，它决定事件如何被处理。触摸事件分发到主窗口，窗口再分发到对应出发触摸事件的View。其他的事件通过其他途径分发给其他对象变量做处理。&lt;/p&gt;
&lt;p&gt;下面是appdeleate和viewcontroller的关系&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw1024/bc254b75jw1f4vop8bk54j20c30agaaj.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文介绍iOS应用程序的生命周期&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>UIView简介和常用方法</title>
    <link href="http://yoursite.com/2016/06/12/UIView%E7%AE%80%E4%BB%8B%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2016/06/12/UIView简介和常用方法/</id>
    <published>2016-06-12T05:55:40.000Z</published>
    <updated>2016-08-04T02:19:45.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;UIView表示屏幕上的一块矩形区域，负责渲染区域的内容，并且响应该区域内发生的触摸事件。&lt;/p&gt;
&lt;p&gt;继承关系：NSObject—UIResponder—UIView&lt;/p&gt;
&lt;p&gt;屏幕上能够看见的都是UIView&lt;br&gt;每一个UIView都是容器&lt;/p&gt;
&lt;p&gt;bounds的x,y永远为0(以自身左上角为原点)，frame的x,y以父视图的左上角为原点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;常见属性&quot;&gt;&lt;a href=&quot;#常见属性&quot; class=&quot;headerlink&quot; title=&quot;常见属性&quot;&gt;&lt;/a&gt;常见属性&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property frame&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property bounds&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property center&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property transform&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property alpha&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property backgroundColor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property contentStretch&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;UIView层的操作常用方法&quot;&gt;&lt;a href=&quot;#UIView层的操作常用方法&quot; class=&quot;headerlink&quot; title=&quot;UIView层的操作常用方法&quot;&gt;&lt;/a&gt;UIView层的操作常用方法&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(void)removeFromSuperview; // 从父视图中移除&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(void)addSubview:(UIView *)view; // 添加一个子视图&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(void)insertSubview:(UIView *)view belowSubview:(UIView *)slibingSubview; // 插入一个view到某个view的下层&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(void)insertSubview:(UIView *)view aboveSubview:(UIView *)slibingSubview; // 插入一个view到某个view的上层&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(void)insertSubview:(UIView *)view atIndex:(NSInteger)index; // 插入一个view到特定层&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(void)bringSubviewToFront:(UIView *)view; // 将某个view放在最上层&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(void)sendSubviewToBack:(UIView *)view; // 将某个view放在最下层&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(BOOL)isDescendantOfView(UIView *)view; // 是否是某个视图的子孙视图&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(void)exchangeSubviewAtIndex:(NSInteger)index1 withSubviewAtIndex:(NSInteger)index2; // 交换两个层的view&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(UIView *)viewWithTag:(NSInteger)view; // 取到指定tag值的view&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;UIView的加载过程&quot;&gt;&lt;a href=&quot;#UIView的加载过程&quot; class=&quot;headerlink&quot; title=&quot;UIView的加载过程&quot;&gt;&lt;/a&gt;UIView的加载过程&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw1024/bc254b75jw1f4usac93ohj20mi0vsac7.jpg&quot; alt=&quot;view&quot;&gt;&lt;br&gt;我们可以知道如果是从 Storyboard 或 Nib 文件中加载 View Controller，我们都不要去重载 loadView，它会自动加载 view 属性以及它的各个 Subviews。只有当我们自己代码创建 View Controller 的时候，我们可能需要去重载 loadView。当然，如果我们不重载，那么默认情况下 loadView 会创建一个光秃秃的 UIView 对象赋给 view 属性。&lt;br&gt;loadView:先寻找有关可用的nib文件的信息，根据这个信息来加载nib文件，如果没有有关nib文件的信息，默认实现会创建一个空白的UIView对象，然后让这个对象成为controller的主view&lt;br&gt;首先访问view属性&lt;br&gt;如果存在view，加载。若不存在，则UIViewController调用loadView方法&lt;br&gt;loadView方法执行如下操作&lt;br&gt;如果覆盖了该方法，必须创建view给UIViewController的view属性&lt;br&gt;如果没有复写该方法，UIViewController会默认调用initWithNibName:bundle:方法初始化并加载view&lt;br&gt;通过viewDidLoad方法来执行一些其他任务&lt;/p&gt;
&lt;h3 id=&quot;UIViewController生命周期&quot;&gt;&lt;a href=&quot;#UIViewController生命周期&quot; class=&quot;headerlink&quot; title=&quot;UIViewController生命周期&quot;&gt;&lt;/a&gt;UIViewController生命周期&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(void)viewDidLoad; //视图加载完成&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(void)viewWillAppear:(BOOL)animated; // 将要显示&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(void)viewDidAppear:(BOOL)animated; // 显示完成&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(void)viewWillDisappear:(BOOL)animated; // 将要移除&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(void)viewDidDisappear:(BOOL)animated; // 已经移除&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;详细版本：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1. -[ViewController initWithCoder:]或-[ViewController initWithNibName:Bundle]:首先从归档文件中加载UIViewController对象。即使是纯代码，也会把nil作为参数传给后者。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	2. -[UIView awakeFromNib]:作为第一个方法的助手，方便处理一些额外的设置。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	3. -[ViewController loadView]:创建或加载一个view并把它赋值给UIViewController的view属性&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	4. -[ViewController viewDidLoad]:此时整个视图层次(view hierarchy)已经被放到内存中，可以移除一些视图，修改约束，加载数据等&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	5. -[ViewController viewWillAppear:]:视图加载完成，并即将显示在屏幕上,还没有设置动画，可以改变当前屏幕方向或状态栏的风格等。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	6. -[ViewController viewWillLayoutSubviews]：即将开始子视图位置布局&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	7. -[ViewController viewDidLayoutSubviews]：用于通知视图的位置布局已经完成&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	8. -[ViewController viewDidAppear:]：视图已经展示在屏幕上，可以对视图做一些关于展示效果方面的修改。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	9. -[ViewController viewWillDisappear:]：视图即将消失&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	10. -[ViewController viewDidDisappear:]：视图已经消失&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;如果考虑UIViewController可能在某个时刻释放整个view。那么再次加载视图时显然会从步骤3开始。因为此时的UIViewController对象依然存在。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;UIView、UIWindow、UIScreen、UIViewController-之间的层级关系&quot;&gt;&lt;a href=&quot;#UIView、UIWindow、UIScreen、UIViewController-之间的层级关系&quot; class=&quot;headerlink&quot; title=&quot;UIView、UIWindow、UIScreen、UIViewController 之间的层级关系&quot;&gt;&lt;/a&gt;UIView、UIWindow、UIScreen、UIViewController 之间的层级关系&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw1024/bc254b75jw1f4usaaorkrj20y00i8gni.jpg&quot; alt=&quot;&quot;&gt; &lt;/p&gt;
&lt;h3 id=&quot;UIView的bounds-frame和center属性&quot;&gt;&lt;a href=&quot;#UIView的bounds-frame和center属性&quot; class=&quot;headerlink&quot; title=&quot;UIView的bounds,frame和center属性&quot;&gt;&lt;/a&gt;UIView的bounds,frame和center属性&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/mw1024/bc254b75jw1f4usab9jhfj20dk0abwf7.jpg&quot; alt=&quot;bound&quot;&gt;&lt;br&gt;看着上图，对照一下就很清楚了&lt;br&gt;View B’s bounds= ((0,0),(200,250))&lt;br&gt;View B’s frame= ((140,65),(320,320))&lt;br&gt;View B’s center= (300,225)&lt;/p&gt;
&lt;h3 id=&quot;常用方法收录&quot;&gt;&lt;a href=&quot;#常用方法收录&quot; class=&quot;headerlink&quot; title=&quot;常用方法收录&quot;&gt;&lt;/a&gt;常用方法收录&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;===获取指定的subViewfor(UIView *view in subviews)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if(view.tag == 998)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//根据tag判断&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;if([view isKindOfClass:[UIImageView class]])&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//根据类型判断&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;===做一个与屏幕同等大小的UIView&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;方法一：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; #pragma mark - Setup&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)setupUI &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Use full screen layout.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;self.edgesForExtendedLayout = UIRectEdgeAll;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;self.automaticallyAdjustsScrollViewInsets = YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;self.extendedLayoutIncludesOpaqueBars = YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;self.view.backgroundColor = [UIColor whiteColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// Title.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;self.title = @&amp;quot;Detail&amp;quot;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;方法二：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGRect rect = [[UIScreen mainScreen] bounds];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGSize size = rect.size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGFloat width = size.width;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGFloat height = size.height; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CGRectMake(origin.x，origin.y，size.width. Size.height)在代码中定义矩形&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Frame:     该view在父view坐标系统中的位置和大小。（参照点是，父亲的坐标系统）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bounds：该view在本地坐标系统中的位置和大小。   （参照点是，本地坐标系统，就相当于ViewB自己的坐标系统，以0,0点为起点）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;center： 该view的中心点在父view坐标系统中的位置和大小。（参照点是，父亲的坐标系统）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;===UIView添加UITableView      TestTableViewController *viewController = [[TestTableViewController alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      [self addChildViewController:viewController];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      [self.view addSubview:viewController.view];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      [viewController didMoveToParentViewController:self];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      [如果不添加controller 则viewController 则不具备跳转等controller功能]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;===设置uiView的位置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;aView.frame = CGRectMake( 100, 200, aView.frame.size.width, aView.frame.size.height ); // set new position exactly&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;===remove view from superView&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for (UIView* subView in [self.view.subviews])&amp;#123;    if ([subView isKindOfClass:[ZeldaView class]])        [subView removeFromSuperview];&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;===添加一条分割线&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UIView *navDividingLine = [[UIView alloc] initWithFrame:CGRectMake(0,159,self.view.bounds.size.width,1)];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        navDividingLine.backgroundColor = [UIColor groupTableViewBackgroundColor];  //这个颜色就是默认表格线的颜色&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [navDividingLine sizeToFit];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [self.view addSubview:navDividingLine];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;UIView设置圆角&quot;&gt;&lt;a href=&quot;#UIView设置圆角&quot; class=&quot;headerlink&quot; title=&quot;UIView设置圆角&quot;&gt;&lt;/a&gt;UIView设置圆角&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;    1、比较简单的情况，UIView四个角都是圆角：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIView *aView = [[UIView alloc] init];        aView.frame = CGRectMake(0, 0, 300, 200);    aView.backgroundColor = [UIColor redColor];        //设置圆角边框        aView.layer.cornerRadius = 8;        aView.layer.masksToBounds = YES;        //设置边框及边框颜色        aView.layer.borderWidth = 8;        aView.layer.borderColor =[ [UIColor grayColor] CGColor];        [self.view addSubview:aView];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    2、设置四个角中的某个或者某几个为圆角&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIView *aView = [[UIView alloc] init];        aView.frame = CGRectMake(0, 0, 300, 200);    aView.backgroundColor = [UIColor redColor];        [self.view addSubview:aView];        //设置所需的圆角位置以及大小    UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:aView.bounds byRoundingCorners:UIRectCornerBottomLeft | UIRectCornerBottomRight cornerRadii:CGSizeMake(10, 10)];    CAShapeLayer *maskLayer = [[CAShapeLayer alloc] init];    maskLayer.frame = aView.bounds;    maskLayer.path = maskPath.CGPath;    aView.layer.mask = maskLayer;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;其中，UIRectCornerBottomLeft，UIRectCornerBottomRight是可以选择的角。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;typedef NS_OPTIONS(NSUInteger, UIRectCorner) &amp;#123;    UIRectCornerTopLeft     = 1 &amp;lt;&amp;lt; 0,    UIRectCornerTopRight    = 1 &amp;lt;&amp;lt; 1,    UIRectCornerBottomLeft  = 1 &amp;lt;&amp;lt; 2,    UIRectCornerBottomRight = 1 &amp;lt;&amp;lt; 3,    UIRectCornerAllCorners  = ~0UL&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;上面的枚举是可以供选择的角，分别是：“左上角”、“右上角”、“左下角”、“右下角”。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;UIView表示屏幕上的一块矩形区域，负责渲染区域的内容，并且响应该区域内发生的触摸事件。&lt;/p&gt;
&lt;p&gt;继承关系：NSObject—UIResponder—UIView&lt;/p&gt;
&lt;p&gt;屏幕上能够看见的都是UIView&lt;br&gt;每一个UIView都是容器&lt;/p&gt;
&lt;p&gt;bounds的x,y永远为0(以自身左上角为原点)，frame的x,y以父视图的左上角为原点&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS-UI" scheme="http://yoursite.com/categories/iOS-UI/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS常用分类</title>
    <link href="http://yoursite.com/2016/06/06/iOS%E5%B8%B8%E7%94%A8%E5%88%86%E7%B1%BB/"/>
    <id>http://yoursite.com/2016/06/06/iOS常用分类/</id>
    <published>2016-06-06T09:57:07.000Z</published>
    <updated>2016-07-12T03:59:40.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;有一些分类在开发中经常应用，做一个收录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;UIView&quot;&gt;&lt;a href=&quot;#UIView&quot; class=&quot;headerlink&quot; title=&quot;UIView&quot;&gt;&lt;/a&gt;UIView&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;建立类别&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;建立一个名为Layout的UIView类别，类别的代码如下：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1. UIView+Layout.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.h 文件定义了 x, y, width, height 等方便读写的属性，代码如下：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;lt;UIKit/UIKit.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface UIView (Layout)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (assign, nonatomic) CGFloat    top;@property (assign, nonatomic) CGFloat    bottom;@property (assign, nonatomic) CGFloat    left;@property (assign, nonatomic) CGFloat    right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (assign, nonatomic) CGFloat    x;@property (assign, nonatomic) CGFloat    y;@property (assign, nonatomic) CGPoint    origin;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (assign, nonatomic) CGFloat    centerX;@property (assign, nonatomic) CGFloat    centerY;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property (assign, nonatomic) CGFloat    width;@property (assign, nonatomic) CGFloat    height;@property (assign, nonatomic) CGSize    size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2. UIView+Layout.m&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.m 文件实现各个属性的setter和getter方法，代码如下：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;UIView+Layout.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation UIView (Layout)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@dynamic top;@dynamic bottom;@dynamic left;@dynamic right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@dynamic width;@dynamic height;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@dynamic size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@dynamic x;@dynamic y;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (CGFloat)top&amp;#123;    return self.frame.origin.y;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)setTop:(CGFloat)top&amp;#123;    CGRect frame = self.frame;    frame.origin.y = top;    self.frame = frame;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (CGFloat)left&amp;#123;    return self.frame.origin.x;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)setLeft:(CGFloat)left&amp;#123;    CGRect frame = self.frame;    frame.origin.x = left;    self.frame = frame;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (CGFloat)bottom&amp;#123;    return self.frame.size.height + self.frame.origin.y;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)setBottom:(CGFloat)bottom&amp;#123;    CGRect frame = self.frame;    frame.origin.y = bottom - frame.size.height;    self.frame = frame;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (CGFloat)right&amp;#123;    return self.frame.size.width + self.frame.origin.x;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)setRight:(CGFloat)right&amp;#123;    CGRect frame = self.frame;    frame.origin.x = right - frame.size.width;    self.frame = frame;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (CGFloat)x&amp;#123;    return self.frame.origin.x;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)setX:(CGFloat)value&amp;#123;    CGRect frame = self.frame;    frame.origin.x = value;    self.frame = frame;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (CGFloat)y&amp;#123;    return self.frame.origin.y;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)setY:(CGFloat)value&amp;#123;    CGRect frame = self.frame;    frame.origin.y = value;    self.frame = frame;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (CGPoint)origin&amp;#123;    return self.frame.origin;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)setOrigin:(CGPoint)origin&amp;#123;    CGRect frame = self.frame;    frame.origin = origin;    self.frame = frame;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (CGFloat)centerX&amp;#123;    return self.center.x;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)setCenterX:(CGFloat)centerX&amp;#123;    CGPoint center = self.center;    center.x = centerX;    self.center = center;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (CGFloat)centerY&amp;#123;    return self.center.y;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)setCenterY:(CGFloat)centerY&amp;#123;    CGPoint center = self.center;    center.y = centerY;    self.center = center;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (CGFloat)width&amp;#123;    return self.frame.size.width;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)setWidth:(CGFloat)width&amp;#123;    CGRect frame = self.frame;    frame.size.width = width;    self.frame = frame;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (CGFloat)height&amp;#123;    return self.frame.size.height;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)setHeight:(CGFloat)height&amp;#123;    CGRect frame = self.frame;    frame.size.height = height;    self.frame = frame;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (CGSize)size&amp;#123;    return self.frame.size;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)setSize:(CGSize)size&amp;#123;    CGRect frame = self.frame;    frame.size = size;    self.frame = frame;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;二、使用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;类别创建完成以后，view的布局就显得轻松很多了&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;例如原来你要修改y坐标时要这样写：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;view.frame = CGRectMake(view.frame.origin.x, 100, view.frame.size.width, view.frame.size.height);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;而现在只需要这样写：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;view.y = 100;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;十六进制的颜色值转换为UIColor&quot;&gt;&lt;a href=&quot;#十六进制的颜色值转换为UIColor&quot; class=&quot;headerlink&quot; title=&quot;十六进制的颜色值转换为UIColor&quot;&gt;&lt;/a&gt;十六进制的颜色值转换为UIColor&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UIColor+Hex.h里面中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;lt;UIKit/UIKit.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface UIColor (Hex)+ (UIColor *) colorWithHexString: (NSString *)color;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;UIColor+Hex.m里面中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;UIColor+Hex.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation UIColor (Hex)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#pragma mark - 颜色转换 iOS中十六进制的颜色转换为UIColor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+ (UIColor *) colorWithHexString: (NSString *)hexString&amp;#123;    NSString *cString = [[hexString stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]] uppercaseString];        //hexString应该6到8个字符    if ([cString length] &amp;lt; 6) &amp;#123;        return [UIColor clearColor];    &amp;#125;        //如果hexString 有@&amp;quot;0X&amp;quot;前缀    if ([cString hasPrefix:@&amp;quot;0X&amp;quot;])        cString = [cString substringFromIndex:2];        //如果hexString 有@&amp;quot;#&amp;quot;&amp;quot;前缀    if ([cString hasPrefix:@&amp;quot;#&amp;quot;])        cString = [cString substringFromIndex:1];    if ([cString length] != 6)        return [UIColor clearColor];        //RGB转换    NSRange range;    range.location = 0;    range.length = 2;        //R    NSString *rString = [cString substringWithRange:range];        //G    range.location = 2;    NSString *gString = [cString substringWithRange:range];        //B    range.location = 4;    NSString *bString = [cString substringWithRange:range];        //    unsigned int r, g, b;    [[NSScanner scannerWithString:rString] scanHexInt:&amp;amp;r];    [[NSScanner scannerWithString:gString] scanHexInt:&amp;amp;g];    [[NSScanner scannerWithString:bString] scanHexInt:&amp;amp;b];        return [UIColor colorWithRed:((float) r / 255.0f) green:((float) g / 255.0f) blue:((float) b / 255.0f) alpha:1.0f];&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;使用方法：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//1、添加头文件#import &amp;quot;UIColor+Hex.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//2、在需要的地方 [UIColor colorWithHexString:@&amp;quot;十六进制&amp;quot;]//eg:[self.view setBackgroundColor:[UIColor colorWithHexString:@&amp;quot;#11489B&amp;quot;]];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;更改图片颜色&quot;&gt;&lt;a href=&quot;#更改图片颜色&quot; class=&quot;headerlink&quot; title=&quot;更改图片颜色&quot;&gt;&lt;/a&gt;更改图片颜色&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  UIImage+Tint.h&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  Ratings&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  Created by gwb on 15/10/10.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  Copyright (c) 2015年 gwb. All rights reserved.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;lt;UIKit/UIKit.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface UIImage (Tint)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (UIImage *) imageWithTintColor:(UIColor *)tintColor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (UIImage *) imageWithGradientTintColor:(UIColor *)tintColor;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  UIImage+Tint.m&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  Ratings&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  Created by gwb on 15/10/10.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//  Copyright (c) 2015年 gwb. All rights reserved.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;UIImage+Tint.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation UIImage (Tint)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (UIImage *) imageWithTintColor:(UIColor *)tintColor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return [self imageWithTintColor:tintColor blendMode:kCGBlendModeDestinationIn];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (UIImage *) imageWithGradientTintColor:(UIColor *)tintColor&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return [self imageWithTintColor:tintColor blendMode:kCGBlendModeOverlay];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (UIImage *) imageWithTintColor:(UIColor *)tintColor blendMode:(CGBlendMode)blendMode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //We want to keep alpha, set opaque to NO; Use 0.0f for scale to use the scale factor of the device’s main screen.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIGraphicsBeginImageContextWithOptions(self.size, NO, 0.0f);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [tintColor setFill];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CGRect bounds = CGRectMake(0, 0, self.size.width, self.size.height);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIRectFill(bounds);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //Draw the tinted image in context&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self drawInRect:bounds blendMode:blendMode alpha:1.0f];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (blendMode != kCGBlendModeDestinationIn) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        [self drawInRect:bounds blendMode:kCGBlendModeDestinationIn alpha:1.0f];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIImage *tintedImage = UIGraphicsGetImageFromCurrentImageContext();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIGraphicsEndImageContext();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return tintedImage;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;有一些分类在开发中经常应用，做一个收录。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS页面流</title>
    <link href="http://yoursite.com/2016/06/06/iOS%E9%A1%B5%E9%9D%A2%E6%B5%81/"/>
    <id>http://yoursite.com/2016/06/06/iOS页面流/</id>
    <published>2016-06-06T06:09:27.000Z</published>
    <updated>2016-06-24T02:06:53.000Z</updated>
    
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;开始学iOS编程的时候对页面之间如何跳转，传值等问题一直没太闹清楚，用这篇文章整理一下，大部分内容转载自这位阿里大神的博客（&lt;a href=&quot;http://www.samirchen.com/），个人能力有限，希望在不断的记录中踏实前进。&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.samirchen.com/），个人能力有限，希望在不断的记录中踏实前进。&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;页面流&quot;&gt;&lt;a href=&quot;#页面流&quot; class=&quot;headerlink&quot; title=&quot;页面流&quot;&gt;&lt;/a&gt;页面流&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/mw1024/bc254b75jw1f4usactd4rj20k20j4gns.jpg&quot; alt=&quot;页面流&quot;&gt;&lt;/p&gt;
&lt;p&gt;一个手机上的app，通常会有多个页面，我们从页面A跳转到页面B，再从页面B跳到页面C，然后我们从页面C跳回到B，或者直接从页面C跳回到页面A，这些跳转，就是我们页面流的逻辑。看看上面的图，可以知道，我们这里主要讨论的是iOS中基于 Navigation方式 + Modal方式 的页面流逻辑。&lt;/p&gt;
&lt;p&gt;那么什么是 Navigation式 的跳转？什么又是 Modal式 的跳转呢？&lt;/p&gt;
&lt;p&gt;Navigation式 的跳转就是上图中蓝色的实线箭头所表示的跳转方式，它所推动的整个视图流就如同一个树状结构，非常清晰，多用于主干视图的展现。iOS 在管理它们时用到了 UINavigationController，其机制就如同栈一样。在图中所有被 Navigation式 地管理着的 View Controller 我都把背景标为了蓝色。&lt;/p&gt;
&lt;p&gt;Modal式 的跳转就是上图中绿色的虚线箭头所表示的跳转方式，它多用于场景式的视图的展现，所以作为 Modal 跳转的目的 VC 通常是用于展示数据的视图或者功能性视图等等，这样的视图可能会在主干中的多种情况下被调用，就比如图中的 VCM1 被 VCN2 和 VCN3 都用到了。在我们实际使用中，通常拍照页面对应的VC就会被用作是Modal式的。在图中所有被 Modal式 地管理着的 View Controller 我都把背景标为了绿色。&lt;/p&gt;
&lt;h2 id=&quot;页面之间的跳转及传参（暂列出几种，剩下的会在以后逐步添加。）&quot;&gt;&lt;a href=&quot;#页面之间的跳转及传参（暂列出几种，剩下的会在以后逐步添加。）&quot; class=&quot;headerlink&quot; title=&quot;页面之间的跳转及传参（暂列出几种，剩下的会在以后逐步添加。）&quot;&gt;&lt;/a&gt;页面之间的跳转及传参（暂列出几种，剩下的会在以后逐步添加。）&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;在设置根控制器的时候可以传参：&quot;&gt;&lt;a href=&quot;#在设置根控制器的时候可以传参：&quot; class=&quot;headerlink&quot; title=&quot;在设置根控制器的时候可以传参：&quot;&gt;&lt;/a&gt;在设置根控制器的时候可以传参：&lt;/h4&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;NavigationController的初始化&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在图中，我们的入口是先创建一个 UINavigationController，并把它的初始VC设置为 VCN1，同时可以在这里传参，代码如下：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 在 AppDelegate.m 中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	VCN1* vcn1 = [[VCN1 alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	vcn1.stringPara = @&amp;quot;value&amp;quot;; // 传参&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	UINavigationController* mainNavigationController = [[UINavigationController alloc] initWithRootViewController:vcn1];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	[mainNavigationController setNavigationBarHidden:YES];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	[self.window setRootViewController:mainNavigationController];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	self.window.backgroundColor = [UIColor whiteColor];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	[self.window makeKeyAndVisible];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	return YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;Navigation-Push-传参&quot;&gt;&lt;a href=&quot;#Navigation-Push-传参&quot; class=&quot;headerlink&quot; title=&quot;Navigation-Push 传参&quot;&gt;&lt;/a&gt;Navigation-Push 传参&lt;/h4&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;在图中，蓝色实线正向的箭头就表示的是 Navigation 的 Push 动作，比如：VCN1-&amp;gt;VCN2; VCN1-&amp;gt;VCN3-&amp;gt;VCN4; VCN5-&amp;gt;VCN6; VCN5-&amp;gt;VCN7-&amp;gt;VCN8 等跳转。一般来说，我们都是一级一级往前Push的，不应该有 VCN1-&amp;gt;VCN4 这样的正向跳跃式Push的需求，要不然图就不这样画了，页面流就不这样设计了。在Push动作中传参是非常简单直接的，因为你这里创建了你要跳达的VC，直接设置其参数属性就可以了。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;例如，VCN1-&amp;gt;VCN2 的跳转代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 在 VCN1.m 中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void) goVCN2:(id)sender &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	VCN2* vcn2 = [[VCN2 alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	vcn2.stringPara = @&amp;quot;value&amp;quot;; // 传参&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	[self.navigationController pushViewController:vcn2 animated:YES]; // 这里的self.navigationController就是MainNavigationController。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在做了以上Push后，VCN2 就会被压到由MainNavigationController管理的栈的栈顶。这个栈就是 self.navigationController.viewControllers。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Push动作是很简单的，基本上所有的Push代码都类似上面这样写。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;以下为push传值的两个实例：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;实例一和实例二都是一个意思，主要是在.m中有可接收的属性，再用push的方式进行传值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;实例一：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;首先SecondViewController视图中需要有一个属性用来存储传递过来的值：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property(nonatomic,retain) NSString *firstValue ;//属性传值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;然后MainViewController视图需要引用SecondViewController视图的头文件，在视图中的按钮点击事件中，通过SecondViewController的对象将需要传递的值存在firstValue中:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(void)buttonAction:(UIButton *)button&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SecondViewController *second = &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[[SecondViewController alloc]init];//用下一个视图的属性接受想要传过去的值,属性传值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;second.firstValue = _txtFiled.text;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self.navigationController pushViewController:second animated:YES];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;页面跳转之后，就能在SecondViewController视图中，通过存值的属性，取用刚才传递过来的值：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//显示传过来的值[_txtFiled setText:_firstValue];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;实例二：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;属性传值 将A页面所拥有的信息通过属性传递到B页面使用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;B页面定义了一个naviTitle属性，在A页面中直接通过属性赋值将A页面中的值传到B页面。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A页面DetailViewController.h文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;lt;UIKit/UIKit.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;DetailViewController.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface RootViewController :UIViewController&amp;lt;ChangeDelegate&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UITextField *tf;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A RootViewController.m页面实现文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;RootViewController.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;DetailViewController.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface RootViewController ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation RootViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//核心代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)loadView&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    UIButton *btn = [UIButton buttonWithType:UIButtonTypeRoundedRect];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    btn.frame = CGRectMake(0, 0, 100, 30);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [btn setTitle:@&amp;quot;Push&amp;quot; forState:0];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [btn addTarget:self action:@selector(pushAction:) forControlEvents:UIControlEventTouchUpInside];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.view addSubview:btn];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)pushAction:(id)sender&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    tf = (UITextField *)[self.viewviewWithTag:1000];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //导航push到下一个页面&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //pushViewController 入栈引用计数+1，且控制权归系统&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    DetailViewController *detailViewController = [[DetailViewControlleralloc]init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //属性传值，直接属性赋值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    detailViewController.naviTitle =tf.text;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    //导航push到下一个页面&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [self.navigationControllerpushViewController:detailViewController animated:YES];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    [detailViewControllerrelease];   &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;B页面DetailViewController.h文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;lt;UIKit/UIKit.h&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface DetailViewController :UIViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   UITextField *textField;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   NSString *_naviTitle;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@property(nonatomic,retain)NSString *naviTitle;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;B页面.m实现文件&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#import &amp;quot;DetailViewController.h&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@interface DetailViewController ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@end&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@implementation DetailViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;@synthesize naviTitle =_naviTitle;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void)loadView&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    self.view = [[[UIViewalloc]initWithFrame:CGRectMake(0,0, 320,480)]autorelease];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   self.title = self.naviTitle ;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h4 id=&quot;Navigation-Pop-传参&quot;&gt;&lt;a href=&quot;#Navigation-Pop-传参&quot; class=&quot;headerlink&quot; title=&quot;Navigation-Pop 传参&quot;&gt;&lt;/a&gt;Navigation-Pop 传参&lt;/h4&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;在图中，蓝色实线反向的箭头就表示的是 Navigation 的 Pop 动作，比如：VCN2-&amp;gt;VCN1; VCN4-&amp;gt;VCN3 等跳转，Pop的跳转需求相对Push就复杂一点了，因为我们还可能有类似 VCN4-&amp;gt;VCN1; VCN8-&amp;gt;VCN5 这样的反向跳跃式Pop的需求，这种需求是合理的。比如：我们由“设置页面”进入“登陆页面”，由“登陆页面”进入“注册页面”，等注册完成了，我们想从“注册页面”直接跳回“登陆页面”这是合理的。所以这里Pop动作就分为：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1）逐级Pop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;逐级Pop是很简单，但是要往回传参就没Push那样方便了，你需要去 self.navigationController.viewControllers 中去找到你要跳达的VC，然后设置其参数。例如，VCN2-&amp;gt;VCN1 的跳转代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 在 VCN2.m 中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void) back:(id)sender &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    NSInteger *preVCIndex = self.navigationController.viewControllers.count - 2;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if (preVCIndex &amp;gt;= 0) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        UIViewController *preVC = [self.navigationController.viewControllers objectAtIndex:preVCIndex];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if ([preVC isKindOfClass:[VCN1 class]]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        	VCN1* vcn1 = (VCN1*) preVC;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        	vcn1.stringPara = @&amp;quot;value&amp;quot;; // 传参&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	[self.navigationController popViewControllerAnimated:YES];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;做了以上的Pop后，VCN2 就会被弹出由MainNavigationController管理的栈。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2）跳跃式Pop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;要完成跳跃式Pop，可以去遍历 self.navigationController.viewControllers 找到你想跳达的页面，然后Pop过去就可以了，传参也在这时设置即可。例如，VCN4-&amp;gt;VCN1 的跳转代码&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 在 VCN4.m 中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void) backToVCN1:(id)sender &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	// 这里要稍微复杂一点&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	for (UIViewController* vc in self.navigationController.viewControllers) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	if ([vc isKindOfClass:[VCN1 class]]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    		vcn1.stringPara = @&amp;quot;value&amp;quot;; // 传参&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        	[self.navigationController popToViewController:vc animated:YES];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;做了以上的跳跃式Pop后，self.navigationController.viewControllers 这个栈中所有在 VCN1 上面的 VC 都会被弹出。通过这种方式，可以跳到栈中任意的页面。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;如果你想直接回到栈底，比如在我们的图中 VCN4-&amp;gt;VCN1 就是回到栈底的情况，你还可以这样做：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 在 VCN4.m 中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void) backToVCN1:(id)sender &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if ([[self.navigationController.viewControllers firstObject] isKindOfClass:[VCN1 class]]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	VCN1* vcn1 = (VCN1*) [self.navigationController.viewControllers firstObject];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	vcn1.stringPara = @&amp;quot;value&amp;quot;; // 传参&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	[self.navigationController popToRootViewControllerAnimated:YES];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h5 id=&quot;Modal-Present&quot;&gt;&lt;a href=&quot;#Modal-Present&quot; class=&quot;headerlink&quot; title=&quot;Modal-Present&quot;&gt;&lt;/a&gt;Modal-Present&lt;/h5&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;在图中，绿色虚线正向的箭头就表示的是 Modal 的 Present 动作，比如：VCN2-&amp;gt;VCM1; VCM1-&amp;gt;VCM2; VCN4-&amp;gt;VCN5; VCN6-&amp;gt;VCM3 等跳转。Present 也是一级一级往前的。在Present动作中传参，也跟Push类似，因为在这里你要创建你想要展示的页面，这时候设置其参数属性即可。但是在我们的图中出现了几种不同Present的情况：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1）Navigation页面流中的某个页面Present一个Modal的页面&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;例如，VCN2-&amp;gt;VCM1 的跳转代码：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 在 VCN2.m 中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void) goVCM1:(id)sender &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	VCM1* vcm1 = [[VCM1 alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	[vcm1 setModalTransitionStyle:UIModalTransitionStyleCoverVertical];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	vcm1.stringPara = @&amp;quot;value&amp;quot;; // 传参&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	[self.navigationController presentViewController:vcm1 animated:YES completion:nil]; // Present modal vc, not pop. 这里用 self.navigationController present 和 用 self present 的效果都是一样的。但是倾向与用前者，后面说明为什么。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2）一个Modal的页面Present另一个Modal的页面&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;例如，VCM1-&amp;gt;VCM2 的跳转代码：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 在 VCM1.m 中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void) goVCM2:(id)sender &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	VCM2* vcm2 = [[VCM2 alloc] init];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	[vcm2 setModalTransitionStyle:UIModalTransitionStyleCoverVertical];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	vcm2.stringPara = @&amp;quot;value&amp;quot;; // 传参&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	[self presentViewController:vcm2 animated:YES completion:nil]; // Present modal vc, not pop. 这里只能用 self present 了。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3）一个Navigation页面流中的某个页面Present另一个Navigation页面流&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这个过程其实就是再创建一个UINavigationController，指定它的 root vc，然后 Present 出来即可，但是注意这里Present的是这个新创建的 UINavigationController。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;例如，VCN4-&amp;gt;SubNavigationVC.VCN5 的跳转代码：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 在 VCN4.m 中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void) goSubNavigationVC:(id)sender &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	VCN5* vcn5 = [[VCN5 alloc] init]; // 这个是 subNavigationController 的 root vc。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	vcn5.stringPara = @&amp;quot;value&amp;quot;; // 传参&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	UINavigationController* subNavigationController = [[UINavigationController alloc] initWithRootViewController:vcn5];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	subNavigationController.navigationBarHidden = YES;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	[self.navigationController presentViewController:subNavigationController animated:YES completion:nil]; // 这里 present 的是 subNavigationController。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h5 id=&quot;Modal-Dismiss&quot;&gt;&lt;a href=&quot;#Modal-Dismiss&quot; class=&quot;headerlink&quot; title=&quot;Modal-Dismiss&quot;&gt;&lt;/a&gt;Modal-Dismiss&lt;/h5&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;这种情况稍复杂，现在很多利用block回传待添加。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在图中，绿色虚线反向的箭头就表示的是 Modal 的 Dismiss 动作，比如：VCM1-&amp;gt;VCN2; VCM2-&amp;gt;VCM1; VCM3-&amp;gt;VCN6 等跳转。Dismiss 这个动作其实写起来是很简单的，但是想要往回传参通常就会复杂一点了，尤其是在不同的情况下。这里的关键点就在于搞清楚当前所在VC的 presentingViewController 这个属性到底指向着谁。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;也就是说，当前的VC1如果是被另一个VC2给Present出来的，那么VC1中self.presentingViewController就是VC2。如果当前的VC1不是被谁Present出来的，但是VC1的某个祖先VC是被另一个VC给Present出来的，那么VC1中self.presentingViewController就是Present当前这个VC1的最近的祖先的那个VC。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;那么下面，我们就根据self.presentingViewController这个属性含义，结合我们图中的几种情况做一下具体的说明：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1）Navigation页面流中的某个页面Present一个Modal的页面后Dismiss&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在 VCM1-&amp;gt;VCN2 这种情况下，在VCM1中，self.presentingViewController是谁呢？一般，我们会认为是 VCN2，但事实上不是VCN2 而是 MainNavigationVC，这是很容易弄错的地方。所以这里想要传参回去的话，就要去 MainNavigationVC 的 viewContollers 栈中找到 VCN2，设置其参数属性。这里就要提到我们在上面介绍 Modal-Present 的时候提到的 VCN2-&amp;gt;VCM1 的跳转代码，在那段代码里我们是用 self.navigationController present...，其实这里不管用 self.navigationController present... 还是用 self present...，到VCM1后，VCM1的presentingViewController都是MainNavigationVC，所以我们选择写清楚点，用前者。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2）一个Modal的页面Present另一个Modal的页面后Dismiss&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在 VCM2-&amp;gt;VCM1 这种情况下，VCM1是被VCM2Present出来的，所以VCM2 的 presentingViewController 就是 VCM1，所以跳转代码如下：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 在 VCM2.m 中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void) back:(id)sender &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if ([self.presentingViewController isKindOfClass:[VCM1 class]]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		VCM1* vcm1 = (VCM1*) [self.presentingViewController isKindOfClass:[VCM1 class]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		vcm1.stringPara = @&amp;quot;value&amp;quot;; // 传参&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	[self.presentingViewController dismissViewControllerAnimated:YES completion:nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;如果我们Present了多层的Modal式VC，而我们想直接跳跃式地Dismiss返回，比如：VCM4-&amp;gt;VCM1 这种情况，VCM4 的 presentingViewController 是 VCM2，而 VCM2 的 presentingViewController 是 VCM1，所以 VCM4-&amp;gt;VCM1 的跳转代码：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 在 VCM4.m 中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void) backToVCM1:(id)sender &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if ([self.presentingViewController.presentingViewController isKindOfClass:[VCM1 class]]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		VCM1* vcm1 = (VCM1*) [self.presentingViewController.presentingViewController isKindOfClass:[VCM1 class]];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		vcm1.stringPara = @&amp;quot;value&amp;quot;; // 传参&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	[self.presentingViewController.presentingViewController dismissViewControllerAnimated:YES completion:nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这样写其实是比较不美观的，尤其是当层次更多更深的时候，如果真有那种情况，那就建议把多层次的Modal式页面流直接改成Navigation式管理更好。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3）一个Navigation页面流中的某个页面Present另一个Navigation页面流后Dismiss&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在 SubNavigationVC.VCN5-&amp;gt;VCN4 的情况下，VCN5 其实不是被谁Present出来的，但是它的父VC(self.parentViewController)是SubNavigationVC，而SubNavigationVC是被MainNavigationVC给Prsent出来的，所以VCN5的presentingViewController就是MainNavigationVC。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SubNavigationVC.VCN5-&amp;gt;VCN4 的跳转代码：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 在 VCN5.m 中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-(void) back:(id)sender &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	// self.presentingViewController是MainNavigationVC&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	if ([self.presentingViewController isKindOfClass:[UINavigationController class]]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	UINavigationController* mainNavigationController = (UINavigationController*) self.presentingViewController;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	if ([[mainNavigationController.viewControllers lastObject] isKindOfClass:[VCN4 class]]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        	VCN4* vcn4 = (VCN4*) [mainNavigationController.viewControllers lastObject];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        	vcn4.stringPara = @&amp;quot;value&amp;quot;; // 传参&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	[self.presentingViewController dismissViewControllerAnimated:YES completion:nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;其实所有由SubNavigationVC管理的这些VC(包括VCN5，VCN6，VCN7，VCN8)的presentingViewController都是MainNavigationVC。所以我们可以直接从这些VC中任意一个直接跳到MainNavigationVC的栈顶的VCN4页面。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;补充&quot;&gt;&lt;a href=&quot;#补充&quot; class=&quot;headerlink&quot; title=&quot;补充&quot;&gt;&lt;/a&gt;补充&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;===Navigation方式+Modal方式 的页面流逻辑其实已经能够满足我们大多时候的使用场景，如果你发现仍然不能满足，那建议首先考虑考虑项目的视图流的设计是不是合理。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Navigation式的跳转只要牢牢盯住所在 VC 的 self.navigationController，理解其像栈一样管理页面流的方式，然后好好使用 self.navigationController.viewControllers 这个 VC栈 就好了。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Modal式的跳转只要牢牢盯住所在 VC 的 self.presentingViewController 就好了，一定要搞清楚它是哪个，这里是很容易弄混而造成代码逻辑错误的。从Navigation页面流Present出来的Modal页面，这个Modal页面的presentingViewController是对应的的UINavigationController，而不是其中的那个具体的页面。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;===关于基于Storyboard来实现页面跳转和传参的方式多是基于Segue来实现的&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;===DismissViewController&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这个是控制页面消失的方法，调用方法当前页面消失，适用于presentViewController的反操作。需求是连续dismiss两次回到最开始的页面。方法：[self dismissViewControllerAnimated:YES completion:^&amp;#123;[self.navigationController popViewControllerAnimated:NO]&amp;#125;];在回调的逻辑中填写你自己需要的跳转方法就可以了&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;====页面PopViewController的回退调用block&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这种回调的block是跟随着动画的，在uitableView中实验了，对于重新加载数据不好用，但是对于一般的回退，很有用[CATransaction begin];[CATransaction setCompletionBlock:^&amp;#123;    // handle completion here&amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self.navigationController popViewControllerAnimated:YES];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[CATransaction commit];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;自己研究的方法是，在pop之前给一个全局变量赋值，然后在新的页面viewWillAppear()中，进行判断然后书写相应逻辑进行刷新等操作。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;===StoryBoard使用segue页面间传递数据:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void) prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    if ([segue.identifier isEqualToString:@&amp;quot;SubLevelSegue&amp;quot;]) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SubLevelViewController *mySubLevelViewController = segue.destinationViewController;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        UITableViewCell *cell = sender;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mySubLevelViewController.title = cell.textLabel.text;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &amp;#123;     UIViewController *destination = segue.destinationViewController;       if ([destination respondsToSelector:@selector(setDelegate:)]) &amp;#123;            [destination setValue:self forKey:@&amp;quot;delegate&amp;quot;];        &amp;#125;        if ([destination respondsToSelector:@selector(setSelection:)]) &amp;#123;            // prepare selection info          NSIndexPath *indexPath = [self.tableView indexPathForCell:sender];                   id object = self.tasks[indexPath.row];                NSDictionary *selection = @&amp;#123;   @&amp;quot;indexPath&amp;quot; : indexPath,   @&amp;quot;object&amp;quot; : object&amp;#125;;            [destination setValue:selection forKey:@&amp;quot;selection&amp;quot;];    &amp;#125; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;===iOS PresentViewControlle后,直接返回根视图&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;在开发中：用[self presentViewController:VC animated:YES completion:nil];实现跳转，多次跳转后，直接返回第一个。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;例如：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;A presentViewController B&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;B presentViewController C&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;C 直接回到A：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;返回第一个视图核心代码如下：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[self.presentingViewController.presentingViewController dismissViewControllerAnimated:YES completion:nil];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;===关于几种逆向传值的方法接下来会补充：&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
</content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;开始学iOS编程的时候对页面之间如何跳转，传值等问题一直没太闹清楚，用这篇文章整理一下，大部分内容转载自这位阿里大神的博客（&lt;a href=&quot;http://www.samirchen.com/），个人能力有限，希望在不断的记录中踏实前进。&quot;&gt;http://www.samirchen.com/），个人能力有限，希望在不断的记录中踏实前进。&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="编程" scheme="http://yoursite.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
</feed>
