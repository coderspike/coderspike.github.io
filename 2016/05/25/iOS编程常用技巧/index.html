<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> iOS编程常用技巧&一些知识点 · coder-gwb</title><meta name="description" content="iOS编程常用技巧&amp;一些知识点 - null"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/categories/编程" target="_self" class="nav-list-link">编程</a></li><li class="nav-list-item"><a href="/categories/读书" target="_self" class="nav-list-link">读书</a></li><li class="nav-list-item"><a href="/categories/生活" target="_self" class="nav-list-link">生活</a></li><li class="nav-list-item"><a href="https://github.com/coderspike" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">iOS编程常用技巧&一些知识点</h1><div class="post-info">2016年5月25日</div><div class="post-content"><blockquote>
<p>在编写iOS程序时，有一些通用的代码，在这里做一个收录，都是转自各路大神的博客，不停维护中～</p>
</blockquote>
<h5 id="项目中的controller太多，不知道具体运行的是哪一个。"><a href="#项目中的controller太多，不知道具体运行的是哪一个。" class="headerlink" title="项目中的controller太多，不知道具体运行的是哪一个。"></a>项目中的controller太多，不知道具体运行的是哪一个。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">建立UIViewController的Category</span><br><span class="line">-(void)viewDidAppear:(BOOL)animated &#123;</span><br><span class="line">    NSLog(@&quot;===%@===&quot;,NSStringFromClass([self class]));</span><br><span class="line">&#125;</span><br><span class="line">这样在运行时就可以知道运行的是哪一个了。</span><br></pre></td></tr></table></figure>
<h6 id="如何将状态栏中的字体颜色变白"><a href="#如何将状态栏中的字体颜色变白" class="headerlink" title="如何将状态栏中的字体颜色变白"></a>如何将状态栏中的字体颜色变白</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 、将info.plist中的 View-based status bar appearance  设为 NO</span><br><span class="line">2、在对应的viewcontrolle.m里添加</span><br><span class="line"> //设置状态栏颜色    [[UIApplication sharedApplication] setStatusBarStyle:UIStatusBarStyleLightContent animated:NO];</span><br><span class="line">就设置成功了。</span><br></pre></td></tr></table></figure>
<h5 id="获取状态栏和导航栏高度、宽度信息"><a href="#获取状态栏和导航栏高度、宽度信息" class="headerlink" title="获取状态栏和导航栏高度、宽度信息"></a>获取状态栏和导航栏高度、宽度信息</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">iPhone开发当中，有时需要获取状态栏和导航栏高度、宽度信息，方便布局其他控件。下面介绍一下如何获取这些信息(可直接将结果放在全局宏中方便使用)：</span><br><span class="line">    // 状态栏(statusbar)  </span><br><span class="line">    CGRect rectStatus = [[UIApplication sharedApplication] statusBarFrame];  </span><br><span class="line">    NSLog(@&quot;status width - %f&quot;, rectStatus.size.width);   </span><br><span class="line">    NSLog(@&quot;status height - %f&quot;, rectStatus.size.height); </span><br><span class="line">      </span><br><span class="line">    // 导航栏（navigationbar）  </span><br><span class="line">    CGRect rectNav = self.navigationController.navigationBar.frame;  </span><br><span class="line">    NSLog(@&quot;nav width - %f&quot;, rectNav.size.width);   </span><br><span class="line">    NSLog(@&quot;nav height - %f&quot;, rectNav.size.height);</span><br></pre></td></tr></table></figure>
<h5 id="检测是否为手机号"><a href="#检测是否为手机号" class="headerlink" title="检测是否为手机号"></a>检测是否为手机号</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)validateMobile:(NSString *)mobileNum&#123;    NSString *regex = @&quot;^1[3|5|7|8][0-9]\\d&#123;8&#125;$&quot;;    NSPredicate *pred = [NSPredicate predicateWithFormat:@&quot;SELF MATCHES %@&quot;, regex];        if(![pred evaluateWithObject:mobileNum])    &#123;        return NO;    &#125;        else    &#123;        return YES;    &#125;&#125;</span><br></pre></td></tr></table></figure>
<h5 id="抽取controller"><a href="#抽取controller" class="headerlink" title="抽取controller"></a>抽取controller</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">当一个项目里有大量的controller时，可以抽取出一个通用的basicController这样可以总体的设置某些属性。</span><br><span class="line">#import &quot;SDBasicViewContoller.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation SDBasicViewContoller</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    self.view.backgroundColor = [UIColor whiteColor];</span><br><span class="line">    </span><br><span class="line">    [self.navigationItem.backBarButtonItem setTitleTextAttributes:@&#123;NSFontAttributeName : [UIFont systemFontOfSize:5]&#125; forState:UIControlStateNormal];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//这样的话可以通用的设置整体的属性</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h5 id="返回按钮只留下白色箭头"><a href="#返回按钮只留下白色箭头" class="headerlink" title="返回按钮只留下白色箭头"></a>返回按钮只留下白色箭头</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[UIBarButtonItem appearance] setBackButtonTitlePositionAdjustment:UIOffsetMake(0, -60)                                                        forBarMetrics:UIBarMetricsDefault];</span><br></pre></td></tr></table></figure>
<h5 id="获取当前时间"><a href="#获取当前时间" class="headerlink" title="获取当前时间"></a>获取当前时间</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSDate *timeDate=[NSDate date];    NSDateFormatter * dateformatter=[[NSDateFormatter alloc] init];    [dateformatter setDateFormat:@&quot;YYYYMMddHHmmsssss&quot;];    NSString *locationString=[dateformatter stringFromDate:timeDate];</span><br></pre></td></tr></table></figure>
<h5 id="判断一个类是否存在"><a href="#判断一个类是否存在" class="headerlink" title="判断一个类是否存在"></a>判断一个类是否存在</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">我们在开发的过程中难免会用到低版本中没有的类，如果我们想让我们的应用尽可能的兼容多个版本，我们需要考虑。</span><br><span class="line">Class pkClass=NSClassFromString(@&quot;PKAddPassesViewController&quot;);</span><br><span class="line">    if (pkClass) &#123;</span><br><span class="line">     NSLog(@&quot;available&quot;);</span><br><span class="line">// 如果可以使用，我们可以使用passkit的一些功能</span><br><span class="line">    &#125;else</span><br><span class="line">    &#123;  NSLog(@&quot;unavailable&quot;);</span><br><span class="line">如果不可以，我们就要提示用户，或者进行一些其他的处理</span><br><span class="line">  &#125;</span><br><span class="line">NSString *pkClassStr=NSStringFromClass([PKAddPassesViewController class]);</span><br><span class="line">    if (pkClassStr) &#123;</span><br><span class="line">        NSLog(@&quot;available&quot;);</span><br><span class="line">// 如果可以使用，我们可以使用passkit的一些功能</span><br><span class="line">    &#125;else &#123;</span><br><span class="line"> NSLog(@&quot;unavailable&quot;);</span><br><span class="line">如果不可以，我们就要提示用户，或者进行一些其他的处理</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h5 id="退出应用"><a href="#退出应用" class="headerlink" title="退出应用"></a>退出应用</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">带有一些动画效果：</span><br><span class="line">AppDelegate *app = [UIApplication sharedApplication].delegate;UIWindow *window = app.window;     [UIView animateWithDuration:0.4f animations:^&#123;     window.alpha = 0;     CGFloat y = window.bounds.size.height;     CGFloat x = window.bounds.size.width / 2;     window.frame = CGRectMake(x, y, 0, 0);&#125; completion:^(BOOL finished) &#123;     exit(0);&#125;];</span><br></pre></td></tr></table></figure>
<h5 id="截屏"><a href="#截屏" class="headerlink" title="截屏"></a>截屏</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-(void)snapshot</span><br><span class="line">&#123;</span><br><span class="line">    //开启上下文</span><br><span class="line">    UIGraphicsBeginImageContext(self.view.bounds.size);</span><br><span class="line">    //拿到上下文</span><br><span class="line">    CGContextRef context=UIGraphicsGetCurrentContext();</span><br><span class="line">    [self.view.layer renderInContext:context];</span><br><span class="line">    UIImage *image=UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">    UIGraphicsEndImageContext();</span><br><span class="line">    //保存到相册</span><br><span class="line">    UIImageWriteToSavedPhotosAlbum(image, self, @selector(image:didFinishSavingWithError:contextInfo:), nil);</span><br><span class="line">&#125;</span><br><span class="line">- (void)image:(UIImage *)image didFinishSavingWithError:(NSError *)error contextInfo:(void *)contextInfo</span><br><span class="line">&#123;</span><br><span class="line">    if (!error) &#123;</span><br><span class="line">        NSLog(@&quot;save success&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="判断邮箱格式"><a href="#判断邮箱格式" class="headerlink" title="判断邮箱格式"></a>判断邮箱格式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">判断邮箱格式是否正确的代码：</span><br><span class="line">	// 利用正则表达式验证 -( BOOL )isValidateEmail:( NSString  *)email  </span><br><span class="line">	&#123;  </span><br><span class="line">	NSString  *emailRegex =  @&quot;[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]&#123;2,4&#125;&quot; ;  </span><br><span class="line">	NSPredicate  *emailTest = [ NSPredicate   predicateWithFormat : @&quot;SELF MATCHES%@&quot; ,emailRegex];  </span><br><span class="line">	return  [emailTest  evaluateWithObject :email];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">点语法的本质是getter/setter方法调用于</span><br><span class="line"></span><br><span class="line">setter/getter里面不能使用self，会造死循环</span><br><span class="line"></span><br><span class="line">SEL其实是对方法的一种包装，将方法包装成一个SEL类型的数据，去找对应的方法地址。找到地址就可以调用方法。其实消息就是SEL</span><br><span class="line"></span><br><span class="line">僵尸对象：所占用内存已经被回收的对象，僵尸对象不能再使用</span><br><span class="line"></span><br><span class="line">野指针：指向僵尸对象(不可用内存)的指针，给野指针发消息会报错(EXEC_BAD_ACCESS)</span><br><span class="line"></span><br><span class="line">空指针：没有指向任何东西的指针(存的东西是0, NULL, nil)，给空指针发消息不报错</span><br><span class="line">BOOL类型property一般指定getter方法格式为isMethod, e.g.:@property (getter=isRich) BOOL rich;</span><br><span class="line"></span><br><span class="line">当一个对象调用autorelease方法时，会将整个对象方放到栈顶的释放池</span><br><span class="line"></span><br><span class="line">创建对象时不要直接调用类名，一般用self.e.g.</span><br><span class="line"></span><br><span class="line">类的本质是对象。是Class类型的对象，简称类对象。 typedef struct objc_class *Class. 类名就代表着类对象，每个类只有一个类对象</span><br><span class="line"></span><br><span class="line">NSUserDefaults 里面不能够存储UIViewController实例或者其示例数组</span><br><span class="line"></span><br><span class="line">创建视图控制器的时候，最好不要在初始化方法中做与视图相关的操作(getter)，可能引发循环调用</span><br><span class="line"></span><br><span class="line">ARC的特点：</span><br><span class="line">不允许调用release、retain、retainCount方法</span><br><span class="line">允许重写dealloc、但是不允许调用[super dealloc]</span><br><span class="line">@property的参数</span><br><span class="line">strong: 相当于retain(适用于OC对象类型)</span><br><span class="line">weak: 相当于assign(适用于OC对象类型)</span><br><span class="line">assign: 适用于非OC对象类型</span><br><span class="line">MRC的retain改为strong(循环引用的时使用：一端用strong，一端用weak)</span><br><span class="line"></span><br><span class="line">weak &amp; Outlet:</span><br><span class="line">当我们使用Outlet属性的时候，我们是在viewController里面使用，而这个Outlet属性是有view来进行强引用的，我们在viewController里面仅仅是对其使用，并没有必要拥有它，所以是weak的。</span><br><span class="line"></span><br><span class="line">.h .m属性:</span><br><span class="line">属性在.h文件中和在.m中声明是有区别的。区别就是，在.h文件中声明的属性，外部类可以通过“类实例.属性”来调用但在.m中声明的则不可以，获取和设置的方法，只能是通过setValue:forKey和valueForKey来实现。</span><br><span class="line"></span><br><span class="line">awakeFromNib：</span><br><span class="line">当.nib文件被加载的时候，会发送一个awakeFromNib的消息到.nib文件中的每个对象，每个对象都可以定义自己的awakeFromNib函数来响应这个消息，执行一些必要的操作。</span><br><span class="line">也就是说只有通过.nib文件创建view对象时才会执行awakeFromNib 。</span><br><span class="line">一般的，当IB加载的时候，我们会通过调用自定义对象的awakeFromNib函数，来对界面进行补充。</span><br><span class="line">选择的时机：当你需要写一个UIView的子类并且想在load nib的时候做一些初始化工作的时候很有用。bundle在load nib后会给每个view对象发送一个awakeFromNib消息。</span><br><span class="line"></span><br><span class="line">@interace</span><br><span class="line">1. 继承</span><br><span class="line">2. 声明协议</span><br><span class="line">3. 定义实例变量（@interface后面加大括号那种）</span><br><span class="line">4. 定义@property</span><br><span class="line">5. 声明方法</span><br><span class="line">.h里面的@interface，不消说，是典型的头文件，它是供其它Class调用的。它的@property和functions，都能够被其它Class“看到”。</span><br><span class="line">而.m里面的@interface，在OC里叫作Class Extension，是.h文件中@interface的补充。但是.m文件里的@interface，对外是不开放的，只在.m文件里可见。</span><br><span class="line">因此，我们将对外开放的方法、变量放到.h文件中，而将不想要对外开放的变量放到.m文件中（.m文件的方法可以不声明，直接用）。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@implementation</span><br><span class="line"></span><br><span class="line">1. 继承</span><br><span class="line">2. 定义实例变量</span><br><span class="line">3. 合成属性（@synthesize和@dynamic）</span><br><span class="line">实现方法（包括协议方法）</span><br><span class="line"></span><br><span class="line">@selector设置string为方法:</span><br><span class="line">NSString *selName = [NSString stringWithFormat@&quot;button%i&quot;, i];SEL selector = NSSelectorFromString(selName);</span><br><span class="line">[button1 addTarget:self action:selector forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在输出系统中封装的结构体和类时尝试调用NSStringFromXXX经常可以输出</span><br></pre></td></tr></table></figure>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">所有 init开头的方法都是构造函数，withxxx 就是带不同参数的构造函数。</span><br><span class="line">在前面的代码中我们已经看到如果要初始化一个类需要调用init方法，那么下面看一下如何自定义构造方法</span><br><span class="line">Person.h</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">@interface Person : NSObject</span><br><span class="line">@property NSString *name;@property int age;</span><br><span class="line">-(id)initWithName:(NSString *)name andAge:(int )age;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">Person.m</span><br><span class="line">#import &quot;Person.h&quot;</span><br><span class="line">@implementation Person</span><br><span class="line">//自定义构造方法-(id)initWithName:(NSString *)name andAge:(int)age&#123;    if(self=[super init])&#123; //super代表父类，这是苹果推荐的写法        self.name=name;        self.age=age;    &#125;    return self;&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">main.m</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;#import &quot;Person.h&quot;</span><br><span class="line">int main(int argc, const char * argv[]) &#123;        Person *p=[[Person alloc]initWithName:@&quot;Kenshin&quot; andAge:28];    NSLog(@&quot;name=%@,age=%i&quot;,p.name,p.age);    //结果：name=Kenshin,age=28    return 0;&#125;</span><br><span class="line">在ObjC中super代表父类，通过调用父类的方法给当前对象赋值，然后判断这个对象是否为nil，如果不为空则依次给name、age属性赋值。</span><br></pre></td></tr></table></figure>
<h5 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对于NSString，NSDictionary，NSArray和NSNumber类，当需要创建这些类的不可变实例时，应该使用这些类的字面值表示形式。</span><br><span class="line"></span><br><span class="line">NSArray *names = @[@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;];</span><br><span class="line">NSDictionary *productManagers = @&#123;@&quot;iPhone&quot; : @&quot;Kate&quot;, @&quot;iPad&quot; : @&quot;Kamal&quot;, @&quot;Mobile Web&quot; : @&quot;Bill&quot;&#125;;</span><br><span class="line">NSNumber *shouldUseLiterals = @YES;</span><br><span class="line">NSNumber *buildingZIPCode = @10018;555</span><br></pre></td></tr></table></figure>
<h5 id="应用中的数据存储"><a href="#应用中的数据存储" class="headerlink" title="应用中的数据存储"></a>应用中的数据存储</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">集中存储的方式：</span><br><span class="line">1 属性列表</span><br><span class="line">2 Preference（NSUserDefaults）</span><br><span class="line">3 键值归档（NSKeyeArchiver,NSCoding）</span><br><span class="line">4 SQLite数据库</span><br><span class="line">5 Core Data </span><br><span class="line"></span><br><span class="line">NSUserDefaults只支持： NSString, NSNumber, NSDate, NSArray, NSDictionary.</span><br><span class="line">NSUserDefaults适合存储轻量级的本地数据，比如要保存一个登陆界面的数据，用户名、密码之类的，个人觉得使用NSUserDefaults是首选。下次再登陆的时候就可以直接从NSUserDefaults里面读取上次登陆的信息咯。</span><br><span class="line">用NSUserDefaults存储的数据下次程序运行的时候依然存在，它把数据存储在什么地方了？如何能够清除？</span><br><span class="line">其实它存储在应用程序内置的一个plist文件里。</span><br></pre></td></tr></table></figure>
<h5 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">===描述一下iOS的内存管理，在开发中对于内存的使用和优化包含哪些方面。我们在开发中应该注意哪些问题。</span><br><span class="line">参考答案：</span><br><span class="line"></span><br><span class="line">内存管理准则：谁强引用过，谁就在不再使用时使引用计数减一。</span><br><span class="line">对于内存的使用和优化常见的有以下方面：</span><br><span class="line">重用问题：如UITableViewCells、UICollectionViewCells、UITableViewHeaderFooterViews设置正确的reuseIdentifier，充分重用。</span><br><span class="line">尽量把views设置为不透明：当opque为NO的时候，图层的半透明取决于图片和其本身合成的图层为结果，可提高性能。</span><br><span class="line">不要使用太复杂的XIB/Storyboard：载入时就会将XIB/storyboard需要的所有资源，包括图片全部载入内存，即使未来很久才会使用。那些相比纯代码写的延迟加载，性能及内存就差了很多。</span><br><span class="line">选择正确的数据结构：学会选择对业务场景最合适的数组结构是写出高效代码的基础。比如，数组: 有序的一组值。使用索引来查询很快，使用值查询很慢，插入/删除很慢。字典: 存储键值对，用键来查找比较快。集合: 无序的一组值，用值来查找很快，插入/删除很快。</span><br><span class="line">gzip/zip压缩：当从服务端下载相关附件时，可以通过gzip/zip压缩后再下载，使得内存更小，下载速度也更快。</span><br><span class="line">延迟加载：对于不应该使用的数据，使用延迟加载方式。对于不需要马上显示的视图，使用延迟加载方式。比如，网络请求失败时显示的提示界面，可能一直都不会使用到，因此应该使用延迟加载。</span><br><span class="line">数据缓存：对于cell的行高要缓存起来，使得reload数据时，效率也极高。而对于那些网络数据，不需要每次都请求的，应该缓存起来，可以写入数据库，也可以通过plist文件存储。</span><br><span class="line">处理内存警告：一般在基类统一处理内存警告，将相关不用资源立即释放掉</span><br><span class="line">重用大开销对象：一些objects的初始化很慢，比如NSDateFormatter和NSCalendar，但又不可避免地需要使用它们。通常是作为属性存储起来，防止反复创建。</span><br><span class="line">避免反复处理数据：许多应用需要从服务器加载功能所需的常为JSON或者XML格式的数据。在服务器端和客户端使用相同的数据结构很重要。</span><br><span class="line">使用Autorelease Pool：在某些循环创建临时变量处理数据时，自动释放池以保证能及时释放内存。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">===深复制和浅复制的区别：</span><br><span class="line">浅复制只复制指向对象的指针，而不复制引用对象的本身。深层复制复制对象的本身。</span><br><span class="line">意思就是说我有个A对象，复制一份后得到A_copy对象，对于浅复制来说，A和A_copy指向的是同一个内存资源，复制的只不过是一个指针，对象本身的资源还是只有一份，当对A_copy执行修改操作时，我们发现A引用的对象同样被修改，深复制对象中存在了两份独立的对象本身，浅复制好比你和你的影子，你完蛋，影子也完蛋，深复制好比克隆人，你完蛋，克隆人还活着。</span><br><span class="line"></span><br><span class="line">===什么情况使用 weak 关键字，相比 assign 有什么不同？</span><br><span class="line">什么情况使用 weak 关键字？</span><br><span class="line">在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性。</span><br><span class="line">自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。在下文也有论述：《IBOutlet连出来的视图属性为什么可以被设置成weak?》</span><br><span class="line">不同点：</span><br><span class="line">weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。 而assign 的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或 NSlnteger 等)的简单赋值操作。</span><br><span class="line">assigin 可以用非 OC 对象,而 weak 必须用于 OC 对象</span><br><span class="line"></span><br><span class="line">===怎么用 copy 关键字？</span><br><span class="line">用途：</span><br><span class="line">NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；</span><br><span class="line">block 也经常使用 copy 关键字</span><br><span class="line"></span><br><span class="line">@property 的本质是什么？</span><br><span class="line">@property = ivar + getter + setter;</span><br><span class="line">下面解释下：</span><br><span class="line">“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。</span><br><span class="line">“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 Objective-C 2.0 的一部分。 而在正规的 Objective-C 编码风格中，存取方法有着严格的命名规范。 正因为有了这种严格的命名规范，所以 Objective-C 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示:</span><br><span class="line">编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。 所以你也可以这么说：</span><br><span class="line">@property = getter + setter;</span><br><span class="line">例如下面这个类：</span><br><span class="line">@interface Person : NSObject@property NSString *firstName;@property NSString *lastName;@end</span><br><span class="line">上述代码写出来的类与下面这种写法等效：</span><br><span class="line">@interface Person : NSObject- (NSString *)firstName;- (void)setFirstName:(NSString *)firstName;- (NSString *)lastName;- (void)setLastName:(NSString *)lastName;@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">===ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</span><br><span class="line">对应基本数据类型默认关键字是atomic,readwrite,assign</span><br><span class="line">对于普通的 Objective-C 对象atomic,readwrite,strong</span><br><span class="line"></span><br><span class="line">===一个objc对象的isa的指针指向什么？有什么作用？</span><br><span class="line">指向他的类对象,从而可以找到对象上的方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">===objc中的类方法和实例方法有什么本质区别和联系？</span><br><span class="line">类方法：</span><br><span class="line">	类方法是属于类对象的</span><br><span class="line">	类方法只能通过类对象调用</span><br><span class="line">	类方法中的self是类对象</span><br><span class="line">	类方法可以调用其他的类方法</span><br><span class="line">	类方法中不能访问成员变量</span><br><span class="line">	类方法中不定直接调用对象方法</span><br><span class="line">实例方法：</span><br><span class="line">	实例方法是属于实例对象的</span><br><span class="line">	实例方法只能通过实例对象调用</span><br><span class="line">	实例方法中的self是实例对象</span><br><span class="line">	实例方法中可以访问成员变量</span><br><span class="line">	实例方法中直接调用实例方法</span><br><span class="line">	实例方法中也可以调用类方法(通过类名)</span><br><span class="line"></span><br><span class="line">===iOS 的沙盒目录结构是怎样的？ App Bundle 里面都有什么？</span><br><span class="line">	1.沙盒结构</span><br><span class="line">	Application：存放程序源文件，上架前经过数字签名，上架后不可修改</span><br><span class="line">	Documents：常用目录，iCloud备份目录，存放数据,这里不能存缓存文件,否则上架不被通过</span><br><span class="line">	Library</span><br><span class="line">	Caches：存放体积大又不需要备份的数据,SDWebImage缓存路径就是这个</span><br><span class="line">	Preference：设置目录，iCloud会备份设置信息</span><br><span class="line">	tmp：存放临时文件，不会被备份，而且这个文件下的数据有可能随时被清除的可能</span><br><span class="line">	2.App Bundle 里面有什么</span><br><span class="line">	Info.plist:此文件包含了应用程序的配置信息.系统依赖此文件以获取应用程序的相关信息</span><br><span class="line">	可执行文件:此文件包含应用程序的入口和通过静态连接到应用程序target的代码</span><br><span class="line">	资源文件:图片,声音文件一类的</span><br><span class="line">	其他:可以嵌入定制的数据资源</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">===Objective-C 如何对已有的方法，添加自己的功能代码以实现类似记录日志这样的功能？</span><br><span class="line">	这题目主要考察的是runtime如何交换方法</span><br><span class="line">	先在分类中添加一个方法,注意不能重写系统方法,会覆盖</span><br><span class="line">	+ (NSString *)myLog&#123;    // 这里写打印行号,什么方法,哪个类调用等等&#125;</span><br><span class="line">	然后交换方法</span><br><span class="line">	// 加载分类到内存的时候调用+ (void)load&#123;    // 获取imageWithName方法地址    Method description = class_getClassMethod(self, @selector(description));</span><br><span class="line">	// 获取imageWithName方法地址    Method myLog = class_getClassMethod(self, @selector(myLog));</span><br><span class="line">	// 交换方法地址，相当于交换实现方式    method_exchangeImplementations(description, myLog);&#125;</span><br><span class="line"></span><br><span class="line">===strong / weak / unsafe_unretained 的区别？</span><br><span class="line">weak只能修饰OC对象,使用weak不会使计数器加1,对象销毁时修饰的对象会指向nil</span><br><span class="line">strong等价与retain,能使计数器加1,且不能用来修饰数据类型</span><br><span class="line">unsafe_unretained等价与assign,可以用来修饰数据类型和OC对象,但是不会使计数器加1,且对象销毁时也不会将对象指向nil,容易造成野指针错误</span><br><span class="line"></span><br><span class="line">===如何为 Class 定义一个对外只读对内可读写的属性?</span><br><span class="line">在头文件中将属性定义为readonly,在.m文件中将属性重新定义为readwrite</span><br><span class="line"></span><br><span class="line">===frame 和 bounds 的区别是什么？</span><br><span class="line">frame相对于父视图,是父视图坐标系下的位置和大小。bounds相对于自身,是自身坐标系下的位置和大小。</span><br><span class="line">frame以父控件的左上角为坐标原点，bounds以自身的左上角为坐标原点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">====Instancetype:</span><br><span class="line"></span><br><span class="line">@interface NSArray  </span><br><span class="line">+ (id)constructAnArray;  </span><br><span class="line">@end  </span><br><span class="line">当我们使用如下方式初始化NSArray时：</span><br><span class="line">[NSArray constructAnArray];  </span><br><span class="line">根据Cocoa的方法命名规范，得到的返回类型就和方法声明的返回类型一样，是id</span><br><span class="line"></span><br><span class="line">@interface NSArray  </span><br><span class="line">+ (instancetype)constructAnArray;  </span><br><span class="line">@end  </span><br><span class="line">当使用相同方式初始化NSArray时：</span><br><span class="line">1. [NSArray constructAnArray];  </span><br><span class="line">得到的返回类型和方法所在类的类型相同，是NSArray*</span><br><span class="line">instancetype的作用，就是使那些非关联返回类型的方法返回所在类的类型！</span><br><span class="line">①instancetype可以返回和方法所在类相同类型的对象，id只能返回未知类型的对象；</span><br><span class="line">②instancetype只能作为返回值，不能像id那样作为参数，比如下面的写法</span><br></pre></td></tr></table></figure>
</div></article></div></section><footer><div class="paginator"><a href="/2016/05/27/Foundation学习笔记/" class="prev">PREV</a><a href="/2016/05/25/自定义UINavigationController/" class="next">NEXT</a></div><div data-thread-key="2016/05/25/iOS编程常用技巧/" data-title="iOS编程常用技巧&amp;一些知识点" data-url="http://yoursite.com/2016/05/25/iOS编程常用技巧/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"true"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2016 <a href="http://yoursite.com"></a>, unless otherwise noted.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>