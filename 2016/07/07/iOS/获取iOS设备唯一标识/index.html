<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>获取iOS设备唯一标识 | spike</title>
  <meta name="author" content="John Doe">
  
  <meta name="description" content="之前碰到过获取设备唯一标识的情况，很多方法都已经作废了，转载一篇文章，很好的总结了能用的方法。(自己还未测试)">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="获取iOS设备唯一标识"/>
  <meta property="og:site_name" content="spike"/>

  
    <meta property="og:image" content="undefined"/>
  

  
    <link rel="alternative" href="/atom.xml" title="spike" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">  
  <link rel="stylesheet" href="/css/sidenav.css" media="screen" type="text/css">  
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  

</head>

<body id="body" data-spy="scroll" data-target=".toc">
  <div class="container" id="container">
	<div class="content">
	  <div class="page-header">		
  <h1><a class="brand" href="/">spike</a><span class="split"></span><span class="title">获取iOS设备唯一标识</span><span class="date" id="title-date"><i class="fa fa-clock-o"></i> 2016-07-07</span></h1>
</div>		

<div class="row page">
  <!-- cols -->	
  
  

  
	<div class="col-md-12">
	  

	  <!-- content -->
	  <blockquote>
<p>之前碰到过获取设备唯一标识的情况，很多方法都已经作废了，转载一篇文章，很好的总结了能用的方法。(自己还未测试)</p>
</blockquote>
<a id="more"></a>
<p><a href="http://blog.ximu.site/uuid/" target="_blank" rel="external">原始文章</a></p>
<h2 id="IDFA"><a href="#IDFA" class="headerlink" title="IDFA"></a>IDFA</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">全名：advertisingIdentifier</span><br><span class="line">获取代码：</span><br><span class="line">  #import &lt;AdSupport/AdSupport.h&gt;</span><br><span class="line">  NSString *adId = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString];</span><br><span class="line">来源：iOS6.0及以后</span><br><span class="line">说明：直译就是广告id， 在同一个设备上的所有App都会取到相同的值，是苹果专门给各广告提供商用来追踪用户而设的，用户可以在 设置|隐私|广告追踪 里重置此id的值，或限制此id的使用，故此id有可能会取不到值，但好在Apple默认是允许追踪的，而且一般用户都不知道有这么个设置，所以基本上用来监测推广效果，是戳戳有余了。</span><br><span class="line">注意：由于idfa会出现取不到的情况，故绝不可以作为业务分析的主id，来识别用户。</span><br></pre></td></tr></table></figure>
<h2 id="IDFV"><a href="#IDFV" class="headerlink" title="IDFV"></a>IDFV</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">全名：identifierForVendor</span><br><span class="line">获取代码： </span><br><span class="line">NSString *idfv = [[[UIDevice currentDevice] identifierForVendor] UUIDString]; </span><br><span class="line"></span><br><span class="line">来源：iOS6.0及以后</span><br><span class="line">说明：顾名思义，是给Vendor标识用户用的，每个设备在所属同一个Vender的应用里，都有相同的值。其中的Vender是指应用提供商，但准确点说，是通过BundleID的反转的前两部分进行匹配，如果相同就是同一个Vender，例如对于com.taobao.app1, com.taobao.app2 这两个BundleID来说，就属于同一个Vender，共享同一个idfv的值。和idfa不同的是，idfv的值是一定能取到的，所以非常适合于作为内部用户行为分析的主id，来标识用户，替代OpenUDID。</span><br><span class="line">注意：如果用户将属于此Vender的所有App卸载，则idfv的值会被重置，即再重装此Vender的App，idfv的值和之前不同。</span><br></pre></td></tr></table></figure>
<h2 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h2><p>我们可以获取到UUID，然后把UUID保存到KeyChain里面。</p>
<p>这样以后即使APP删了再装回来，也可以从KeyChain中读取回来。使用group还可以可以保证同一个开发商的所有程序针对同一台设备能够获取到相同的不变的UDID。</p>
<p>但是刷机或重装系统后uuid还是会改变。</p>
<h3 id="把下面两个类文件放到你的项目中"><a href="#把下面两个类文件放到你的项目中" class="headerlink" title="把下面两个类文件放到你的项目中"></a>把下面两个类文件放到你的项目中</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KeychainItemWrapper.h文件  </span><br><span class="line">********************************</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line">@interface KeychainItemWrapper : NSObject</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableDictionary *keychainItemData;        // The actual keychain item data backing store.</span><br><span class="line">    NSMutableDictionary *genericPasswordQuery;    // A placeholder for the generic keychain item query used to locate the item.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@property (nonatomic, retain) NSMutableDictionary *keychainItemData;</span><br><span class="line">@property (nonatomic, retain) NSMutableDictionary *genericPasswordQuery;</span><br><span class="line"></span><br><span class="line">// Designated initializer.</span><br><span class="line">- (id)initWithAccount:(NSString *)account service:(NSString *)service accessGroup:(NSString *) accessGroup;</span><br><span class="line"></span><br><span class="line">- (id)initWithIdentifier: (NSString *)identifier accessGroup:(NSString *) accessGroup;</span><br><span class="line">- (void)setObject:(id)inObject forKey:(id)key;</span><br><span class="line">- (id)objectForKey:(id)key;</span><br><span class="line"></span><br><span class="line">// Initializes and resets the default generic keychain item data.</span><br><span class="line">- (void)resetKeychainItem;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KeychainItemWrapper.h文件  </span><br><span class="line">********************************</span><br><span class="line"></span><br><span class="line">#import &quot;KeychainItemWrapper.h&quot;</span><br><span class="line">#import &lt;Security/Security.h&gt;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"></span><br><span class="line">These are the default constants and their respective types,  </span><br><span class="line">available for the kSecClassGenericPassword Keychain Item class:</span><br><span class="line"></span><br><span class="line">kSecAttrAccessGroup            -       CFStringRef  </span><br><span class="line">kSecAttrCreationDate        -       CFDateRef  </span><br><span class="line">kSecAttrModificationDate    -        CFDateRef  </span><br><span class="line">kSecAttrDescription            -       CFStringRef  </span><br><span class="line">kSecAttrComment                -       CFStringRef  </span><br><span class="line">kSecAttrCreator                -       CFNumberRef  </span><br><span class="line">kSecAttrType                -        CFNumberRef  </span><br><span class="line">kSecAttrLabel                -       CFStringRef  </span><br><span class="line">kSecAttrIsInvisible            -       CFBooleanRef  </span><br><span class="line">kSecAttrIsNegative            -       CFBooleanRef  </span><br><span class="line">kSecAttrAccount                -       CFStringRef  </span><br><span class="line">kSecAttrService                -       CFStringRef  </span><br><span class="line">kSecAttrGeneric                -       CFDataRef</span><br><span class="line"></span><br><span class="line">See the header file Security/SecItem.h for more details.</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">@interface KeychainItemWrapper (PrivateMethods)</span><br><span class="line">/*</span><br><span class="line">The decision behind the following two methods (secItemFormatToDictionary and dictionaryToSecItemFormat) was  </span><br><span class="line">to encapsulate the transition between what the detail view controller was expecting (NSString *) and what the  </span><br><span class="line">Keychain API expects as a validly constructed container class.  </span><br><span class="line">*/</span><br><span class="line">- (NSMutableDictionary *)secItemFormatToDictionary:(NSDictionary *)dictionaryToConvert;</span><br><span class="line">- (NSMutableDictionary *)dictionaryToSecItemFormat:(NSDictionary *)dictionaryToConvert;</span><br><span class="line"></span><br><span class="line">// Updates the item in the keychain, or adds it if it doesn&apos;t exist.</span><br><span class="line">- (void)writeToKeychain;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation KeychainItemWrapper</span><br><span class="line"></span><br><span class="line">@synthesize keychainItemData, genericPasswordQuery;</span><br><span class="line"></span><br><span class="line">- (id)initWithAccount:(NSString *)account service:(NSString *)service accessGroup:(NSString *) accessGroup;</span><br><span class="line">&#123;</span><br><span class="line">    if (self = [super init])</span><br><span class="line">    &#123;</span><br><span class="line">        NSAssert(account != nil || service != nil, @&quot;Both account and service are nil.  Must specifiy at least one.&quot;);</span><br><span class="line">        // Begin Keychain search setup. The genericPasswordQuery the attributes kSecAttrAccount and</span><br><span class="line">        // kSecAttrService are used as unique identifiers differentiating keychain items from one another</span><br><span class="line">        genericPasswordQuery = [[NSMutableDictionary alloc] init];</span><br><span class="line"></span><br><span class="line">        [genericPasswordQuery setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];</span><br><span class="line"></span><br><span class="line">        [genericPasswordQuery setObject:account forKey:(id)kSecAttrAccount];</span><br><span class="line">        [genericPasswordQuery setObject:service forKey:(id)kSecAttrService];</span><br><span class="line"></span><br><span class="line">        // The keychain access group attribute determines if this item can be shared</span><br><span class="line">        // amongst multiple apps whose code signing entitlements contain the same keychain access group.</span><br><span class="line">        if (accessGroup != nil)</span><br><span class="line">        &#123;</span><br><span class="line">#if TARGET_IPHONE_SIMULATOR</span><br><span class="line">            // Ignore the access group if running on the iPhone simulator.</span><br><span class="line">            //</span><br><span class="line">            // Apps that are built for the simulator aren&apos;t signed, so there&apos;s no keychain access group</span><br><span class="line">            // for the simulator to check. This means that all apps can see all keychain items when run</span><br><span class="line">            // on the simulator.</span><br><span class="line">            //</span><br><span class="line">            // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the</span><br><span class="line">            // simulator will return -25243 (errSecNoAccessForItem).</span><br><span class="line">#else</span><br><span class="line">            [genericPasswordQuery setObject:accessGroup forKey:(id)kSecAttrAccessGroup];</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Use the proper search constants, return only the attributes of the first match.</span><br><span class="line">        [genericPasswordQuery setObject:(id)kSecMatchLimitOne forKey:(id)kSecMatchLimit];</span><br><span class="line">        [genericPasswordQuery setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnAttributes];</span><br><span class="line"></span><br><span class="line">        NSDictionary *tempQuery = [NSDictionary dictionaryWithDictionary:genericPasswordQuery];</span><br><span class="line"></span><br><span class="line">        NSMutableDictionary *outDictionary = nil;</span><br><span class="line"></span><br><span class="line">        if (! SecItemCopyMatching((CFDictionaryRef)tempQuery, (CFTypeRef *)&amp;outDictionary) == noErr)</span><br><span class="line">        &#123;</span><br><span class="line">            // Stick these default values into keychain item if nothing found.</span><br><span class="line">            [self resetKeychainItem];</span><br><span class="line"></span><br><span class="line">            //Adding the account and service identifiers to the keychain</span><br><span class="line">            [keychainItemData setObject:account forKey:(id)kSecAttrAccount];</span><br><span class="line">            [keychainItemData setObject:service forKey:(id)kSecAttrService];</span><br><span class="line"></span><br><span class="line">            if (accessGroup != nil)</span><br><span class="line">            &#123;</span><br><span class="line">#if TARGET_IPHONE_SIMULATOR</span><br><span class="line">                // Ignore the access group if running on the iPhone simulator.</span><br><span class="line">                //</span><br><span class="line">                // Apps that are built for the simulator aren&apos;t signed, so there&apos;s no keychain access group</span><br><span class="line">                // for the simulator to check. This means that all apps can see all keychain items when run</span><br><span class="line">                // on the simulator.</span><br><span class="line">                //</span><br><span class="line">                // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the</span><br><span class="line">                // simulator will return -25243 (errSecNoAccessForItem).</span><br><span class="line">#else</span><br><span class="line">                [keychainItemData setObject:accessGroup forKey:(id)kSecAttrAccessGroup];</span><br><span class="line">#endif</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            // load the saved data from Keychain.</span><br><span class="line">            self.keychainItemData = [self secItemFormatToDictionary:outDictionary];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [outDictionary release];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)initWithIdentifier: (NSString *)identifier accessGroup:(NSString *) accessGroup;</span><br><span class="line">&#123;</span><br><span class="line">    if (self = [super init])</span><br><span class="line">    &#123;</span><br><span class="line">        // Begin Keychain search setup. The genericPasswordQuery leverages the special user</span><br><span class="line">        // defined attribute kSecAttrGeneric to distinguish itself between other generic Keychain</span><br><span class="line">        // items which may be included by the same application.</span><br><span class="line">        genericPasswordQuery = [[NSMutableDictionary alloc] init];</span><br><span class="line"></span><br><span class="line">        [genericPasswordQuery setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];</span><br><span class="line">        [genericPasswordQuery setObject:identifier forKey:(id)kSecAttrGeneric];</span><br><span class="line"></span><br><span class="line">        // The keychain access group attribute determines if this item can be shared</span><br><span class="line">        // amongst multiple apps whose code signing entitlements contain the same keychain access group.</span><br><span class="line">        if (accessGroup != nil)</span><br><span class="line">        &#123;</span><br><span class="line">#if TARGET_IPHONE_SIMULATOR</span><br><span class="line">            // Ignore the access group if running on the iPhone simulator.</span><br><span class="line">            // </span><br><span class="line">            // Apps that are built for the simulator aren&apos;t signed, so there&apos;s no keychain access group</span><br><span class="line">            // for the simulator to check. This means that all apps can see all keychain items when run</span><br><span class="line">            // on the simulator.</span><br><span class="line">            //</span><br><span class="line">            // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the</span><br><span class="line">            // simulator will return -25243 (errSecNoAccessForItem).</span><br><span class="line">#else            </span><br><span class="line">            [genericPasswordQuery setObject:accessGroup forKey:(id)kSecAttrAccessGroup];</span><br><span class="line">#endif</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Use the proper search constants, return only the attributes of the first match.</span><br><span class="line">        [genericPasswordQuery setObject:(id)kSecMatchLimitOne forKey:(id)kSecMatchLimit];</span><br><span class="line">        [genericPasswordQuery setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnAttributes];</span><br><span class="line"></span><br><span class="line">        NSDictionary *tempQuery = [NSDictionary dictionaryWithDictionary:genericPasswordQuery];</span><br><span class="line"></span><br><span class="line">        NSMutableDictionary *outDictionary = nil;</span><br><span class="line"></span><br><span class="line">        if (! SecItemCopyMatching((CFDictionaryRef)tempQuery, (CFTypeRef *)&amp;outDictionary) == noErr)</span><br><span class="line">        &#123;</span><br><span class="line">            // Stick these default values into keychain item if nothing found.</span><br><span class="line">            [self resetKeychainItem];</span><br><span class="line"></span><br><span class="line">            // Add the generic attribute and the keychain access group.</span><br><span class="line">            [keychainItemData setObject:identifier forKey:(id)kSecAttrGeneric];</span><br><span class="line">            if (accessGroup != nil)</span><br><span class="line">            &#123;</span><br><span class="line">#if TARGET_IPHONE_SIMULATOR</span><br><span class="line">                // Ignore the access group if running on the iPhone simulator.</span><br><span class="line">                // </span><br><span class="line">                // Apps that are built for the simulator aren&apos;t signed, so there&apos;s no keychain access group</span><br><span class="line">                // for the simulator to check. This means that all apps can see all keychain items when run</span><br><span class="line">                // on the simulator.</span><br><span class="line">                //</span><br><span class="line">                // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the</span><br><span class="line">                // simulator will return -25243 (errSecNoAccessForItem).</span><br><span class="line">#else            </span><br><span class="line">                [keychainItemData setObject:accessGroup forKey:(id)kSecAttrAccessGroup];</span><br><span class="line">#endif</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            // load the saved data from Keychain.</span><br><span class="line">            self.keychainItemData = [self secItemFormatToDictionary:outDictionary];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [outDictionary release];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">    [keychainItemData release];</span><br><span class="line">    [genericPasswordQuery release];</span><br><span class="line"></span><br><span class="line">    [super dealloc];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setObject:(id)inObject forKey:(id)key </span><br><span class="line">&#123;</span><br><span class="line">    if (inObject == nil) return;</span><br><span class="line">    id currentObject = [keychainItemData objectForKey:key];</span><br><span class="line">    if (![currentObject isEqual:inObject])</span><br><span class="line">    &#123;</span><br><span class="line">        [keychainItemData setObject:inObject forKey:key];</span><br><span class="line">        [self writeToKeychain];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)objectForKey:(id)key</span><br><span class="line">&#123;</span><br><span class="line">    return [keychainItemData objectForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)resetKeychainItem</span><br><span class="line">&#123;</span><br><span class="line">    OSStatus junk = noErr;</span><br><span class="line">    if (!keychainItemData) </span><br><span class="line">    &#123;</span><br><span class="line">        self.keychainItemData = [[NSMutableDictionary alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    else if (keychainItemData)</span><br><span class="line">    &#123;</span><br><span class="line">        NSMutableDictionary *tempDictionary = [self dictionaryToSecItemFormat:keychainItemData];</span><br><span class="line">        junk = SecItemDelete((CFDictionaryRef)tempDictionary);</span><br><span class="line">        NSAssert( junk == noErr || junk == errSecItemNotFound, @&quot;Problem deleting current dictionary.&quot; );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Default attributes for keychain item.</span><br><span class="line">    [keychainItemData setObject:@&quot;&quot; forKey:(id)kSecAttrAccount];</span><br><span class="line">    [keychainItemData setObject:@&quot;&quot; forKey:(id)kSecAttrLabel];</span><br><span class="line">    [keychainItemData setObject:@&quot;&quot; forKey:(id)kSecAttrDescription];</span><br><span class="line"></span><br><span class="line">    // Default data for keychain item.</span><br><span class="line">    [keychainItemData setObject:@&quot;&quot; forKey:(id)kSecValueData];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMutableDictionary *)dictionaryToSecItemFormat:(NSDictionary *)dictionaryToConvert</span><br><span class="line">&#123;</span><br><span class="line">    // The assumption is that this method will be called with a properly populated dictionary</span><br><span class="line">    // containing all the right key/value pairs for a SecItem.</span><br><span class="line"></span><br><span class="line">    // Create a dictionary to return populated with the attributes and data.</span><br><span class="line">    NSMutableDictionary *returnDictionary = [NSMutableDictionary dictionaryWithDictionary:dictionaryToConvert];</span><br><span class="line"></span><br><span class="line">    // Add the Generic Password keychain item class attribute.</span><br><span class="line">    [returnDictionary setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];</span><br><span class="line"></span><br><span class="line">    // Convert the NSString to NSData to meet the requirements for the value type kSecValueData.</span><br><span class="line">    // This is where to store sensitive data that should be encrypted.</span><br><span class="line">    NSString *passwordString = [dictionaryToConvert objectForKey:(id)kSecValueData];</span><br><span class="line">    [returnDictionary setObject:[passwordString dataUsingEncoding:NSUTF8StringEncoding] forKey:(id)kSecValueData];</span><br><span class="line"></span><br><span class="line">    return returnDictionary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSMutableDictionary *)secItemFormatToDictionary:(NSDictionary *)dictionaryToConvert</span><br><span class="line">&#123;</span><br><span class="line">    // The assumption is that this method will be called with a properly populated dictionary</span><br><span class="line">    // containing all the right key/value pairs for the UI element.</span><br><span class="line"></span><br><span class="line">    // Create a dictionary to return populated with the attributes and data.</span><br><span class="line">    NSMutableDictionary *returnDictionary = [NSMutableDictionary dictionaryWithDictionary:dictionaryToConvert];</span><br><span class="line"></span><br><span class="line">    // Add the proper search key and class attribute.</span><br><span class="line">    [returnDictionary setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnData];</span><br><span class="line">    [returnDictionary setObject:(id)kSecClassGenericPassword forKey:(id)kSecClass];</span><br><span class="line"></span><br><span class="line">    // Acquire the password data from the attributes.</span><br><span class="line">    NSData *passwordData = NULL;</span><br><span class="line">    if (SecItemCopyMatching((CFDictionaryRef)returnDictionary, (CFTypeRef *)&amp;passwordData) == noErr)</span><br><span class="line">    &#123;</span><br><span class="line">        // Remove the search, class, and identifier key/value, we don&apos;t need them anymore.</span><br><span class="line">        [returnDictionary removeObjectForKey:(id)kSecReturnData];</span><br><span class="line"></span><br><span class="line">        // Add the password to the dictionary, converting from NSData to NSString.</span><br><span class="line">        NSString *password = [[[NSString alloc] initWithBytes:[passwordData bytes] length:[passwordData length] </span><br><span class="line">                                                     encoding:NSUTF8StringEncoding] autorelease];</span><br><span class="line">        [returnDictionary setObject:password forKey:(id)kSecValueData];</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        // Don&apos;t do anything if nothing is found.</span><br><span class="line">        NSAssert(NO, @&quot;Serious error, no matching item found in the keychain.\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [passwordData release];</span><br><span class="line"></span><br><span class="line">    return returnDictionary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)writeToKeychain</span><br><span class="line">&#123;</span><br><span class="line">    NSDictionary *attributes = NULL;</span><br><span class="line">    NSMutableDictionary *updateItem = NULL;</span><br><span class="line">    OSStatus result;</span><br><span class="line"></span><br><span class="line">    if (SecItemCopyMatching((CFDictionaryRef)genericPasswordQuery, (CFTypeRef *)&amp;attributes) == noErr)</span><br><span class="line">    &#123;</span><br><span class="line">        // First we need the attributes from the Keychain.</span><br><span class="line">        updateItem = [NSMutableDictionary dictionaryWithDictionary:attributes];</span><br><span class="line">        // Second we need to add the appropriate search key/values.</span><br><span class="line">        [updateItem setObject:[genericPasswordQuery objectForKey:(id)kSecClass] forKey:(id)kSecClass];</span><br><span class="line"></span><br><span class="line">        // Lastly, we need to set up the updated attribute list being careful to remove the class.</span><br><span class="line">        NSMutableDictionary *tempCheck = [self dictionaryToSecItemFormat:keychainItemData];</span><br><span class="line">        [tempCheck removeObjectForKey:(id)kSecClass];</span><br><span class="line"></span><br><span class="line">#if TARGET_IPHONE_SIMULATOR</span><br><span class="line">        // Remove the access group if running on the iPhone simulator.</span><br><span class="line">        // </span><br><span class="line">        // Apps that are built for the simulator aren&apos;t signed, so there&apos;s no keychain access group</span><br><span class="line">        // for the simulator to check. This means that all apps can see all keychain items when run</span><br><span class="line">        // on the simulator.</span><br><span class="line">        //</span><br><span class="line">        // If a SecItem contains an access group attribute, SecItemAdd and SecItemUpdate on the</span><br><span class="line">        // simulator will return -25243 (errSecNoAccessForItem).</span><br><span class="line">        //</span><br><span class="line">        // The access group attribute will be included in items returned by SecItemCopyMatching,</span><br><span class="line">        // which is why we need to remove it before updating the item.</span><br><span class="line">        [tempCheck removeObjectForKey:(id)kSecAttrAccessGroup];</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">        // An implicit assumption is that you can only update a single item at a time.</span><br><span class="line"></span><br><span class="line">        result = SecItemUpdate((CFDictionaryRef)updateItem, (CFDictionaryRef)tempCheck);</span><br><span class="line">        NSAssert( result == noErr, @&quot;Couldn&apos;t update the Keychain Item.&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        // No previous item found; add the new one.</span><br><span class="line">        result = SecItemAdd((CFDictionaryRef)[self dictionaryToSecItemFormat:keychainItemData], NULL);</span><br><span class="line">        NSAssert( result == noErr, @&quot;Couldn&apos;t add the Keychain Item.&quot; );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<ul>
<li>我们在写一个工具类用来保存UUID到keychain和从keychain中读取UUID.</li>
</ul>
<p>实现代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AppUntils.m文件  </span><br><span class="line">*********************</span><br><span class="line"></span><br><span class="line">#import  &lt;Security/Security.h&gt;</span><br><span class="line">#import &quot;KeychainItemWrapper.h&quot;</span><br><span class="line"></span><br><span class="line">#pragma mark - 保存和读取UUID</span><br><span class="line">+(void)saveUUIDToKeyChain&#123;</span><br><span class="line">    KeychainItemWrapper *keychainItem = [[KeychainItemWrapper alloc] initWithAccount:@&quot;Identfier&quot; service:@&quot;AppName&quot; accessGroup:nil];</span><br><span class="line">    NSString *string = [keychainItem objectForKey: (__bridge id)kSecAttrGeneric];</span><br><span class="line">    if([string isEqualToString:@&quot;&quot;] || !string)&#123;</span><br><span class="line">        [keychainItem setObject:[self getUUIDString] forKey:(__bridge id)kSecAttrGeneric];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+(NSString *)readUUIDFromKeyChain&#123;</span><br><span class="line">    KeychainItemWrapper *keychainItemm = [[KeychainItemWrapper alloc] initWithAccount:@&quot;Identfier&quot; service:@&quot;AppName&quot; accessGroup:nil];</span><br><span class="line">    NSString *UUID = [keychainItemm objectForKey: (__bridge id)kSecAttrGeneric];</span><br><span class="line">    return UUID;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (NSString *)getUUIDString</span><br><span class="line">&#123;</span><br><span class="line">    CFUUIDRef uuidRef = CFUUIDCreate(kCFAllocatorDefault);</span><br><span class="line">    CFStringRef strRef = CFUUIDCreateString(kCFAllocatorDefault , uuidRef);</span><br><span class="line">    NSString *uuidString = [(__bridge NSString*)strRef stringByReplacingOccurrencesOfString:@&quot;-&quot; withString:@&quot;&quot;];</span><br><span class="line">    CFRelease(strRef);</span><br><span class="line">    CFRelease(uuidRef);</span><br><span class="line">    return uuidString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>读取UUID<br>在需要读取的地方直接调用AppUtils的类方法readUUIDFromKeyChain即可。</p>
</li>
<li><p>注意</p>
<h3 id="1-设置非ARC编译环境"><a href="#1-设置非ARC编译环境" class="headerlink" title="1.设置非ARC编译环境"></a>1.设置非ARC编译环境</h3><p>因为KeychainItemWrapper.m文件是在非ARC环境下运行的，所以需要设置非arc编译环境， 在Build Phases下选在文件，设置compiler flags:-fno-objc-arc</p>
</li>
</ul>
<h3 id="2-让同一开发商的所有APP在同一台设备上获取到UUID相同"><a href="#2-让同一开发商的所有APP在同一台设备上获取到UUID相同" class="headerlink" title="2. 让同一开发商的所有APP在同一台设备上获取到UUID相同"></a>2. 让同一开发商的所有APP在同一台设备上获取到UUID相同</h3><p>在每个APP的项目里面做如下设置</p>
<h4 id="2-1、设置accessgroup"><a href="#2-1、设置accessgroup" class="headerlink" title="2.1、设置accessgroup"></a>2.1、设置accessgroup</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keychainItemWrapper *keychainItem = [[KeychainItemWrapper alloc] initWithAccount:@&quot;Identfier&quot; service:@&quot;AppName&quot; accessGroup:@&quot;YOUR_BUNDLE_SEED.com.yourcompany.userinfo&quot;];  </span><br><span class="line">此处设置accessGroup为YOURBUNDLESEED.com.yourcompany.userinfo</span><br></pre></td></tr></table></figure>
<h4 id="2-2、创建plist文件"><a href="#2-2、创建plist文件" class="headerlink" title="2.2、创建plist文件"></a>2.2、创建plist文件</h4><p>然后在项目相同的目录下创建KeychainAccessGroups.plist文件。</p>
<p>该文件的结构是一个字典，其中中最顶层的节点必须是一个键为“keychain-access-groups”的Array，并且该Array中每一项都是一个描述分组的NSString。YOURBUNDLESEED.com.yourcompany.userinfo就是要设置的组名。</p>
<h4 id="2-3-设置code-signing"><a href="#2-3-设置code-signing" class="headerlink" title="2.3 设置code signing"></a>2.3 设置code signing</h4><p>接着在Target—&gt;Build Settings—-&gt;Code Signing栏下的Code Signing Entitlements右侧添加KeychainAccessGroups.plist</p>
<p>这样就可以保证每个app都是从keychain中读取出来同一个UUID</p>
	  

	  <div>
  		<center>
		  <div class="pagination">
<ul class="pagination">
	
	
	
	
	
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
			
		
	
		
	
		
	
		
	
		
			
			
			
		
	
		
			
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
	
	
	
		<li class="prev disabled"><a><i class="fa fa-arrow-circle-o-left"></i>prev</a></li>
	
	<li><a href="/"><i class="fa fa-archive"></i>Home</a></li>
	
		<li class="next"><a href="/2016/06/30/iOS/Git相关操作/" class="alignright next">next<i class="fa fa-arrow-circle-o-right"></i></a></li>
	
</ul>
</div>

		</center>
	  </div>
	  
	</div> <!-- col-md-9/col-md-12 -->
	
  </div><!-- row -->

	</div>
  </div>
  <div class="container-narrow">
	<footer> <p>
  &copy; 2016 John Doe
  
      with help from <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-wixo/">Wixo</a>.    
</p> </footer>
  </div> <!-- container-narrow -->
  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/jquery.tableofcontents.min.js"></script>
<script src="/js/tocgenerator.min.js"></script>
<script src="/js/main.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


</body>
</html>
