<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>iOS开发中的几种设计模式 | spike 思考</title>
  <meta name="author" content="John Doe">
  
  <meta name="description" content="单例单例模式不需要传递任何参数，就有效地解决了不同代码间的数据共享问题。单例类是一个非常重要的概念，因为它们表现出了一种十分有用的设计模式。单例类的应用贯穿于整个iOS的SDK中。例如，UIApplication类有一个方法叫sharedApplication，从任何地方调用这个方法，都将返回与当前">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="iOS开发中的几种设计模式"/>
  <meta property="og:site_name" content="spike 思考"/>

  
    <meta property="og:image" content="undefined"/>
  

  
    <link rel="alternative" href="/atom.xml" title="spike 思考" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">  
  <link rel="stylesheet" href="/css/sidenav.css" media="screen" type="text/css">  
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  

</head>

<body id="body" data-spy="scroll" data-target=".toc">
  <div class="container" id="container">
	<div class="content">
	  <div class="page-header">		
  <h1><a class="brand" href="/">spike 思考</a><span class="split"></span><span class="title">iOS开发中的几种设计模式</span><span class="date" id="title-date"><i class="fa fa-clock-o"></i> 2016-06-06</span></h1>
</div>		

<div class="row page">
  <!-- cols -->	
  
  

  
	<div class="col-md-12">
	  

	  <!-- content -->
	  <h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">单例模式不需要传递任何参数，就有效地解决了不同代码间的数据共享问题。单例类是一个非常重要的概念，因为它们表现出了一种十分有用的设计模式。单例类的应用贯穿于整个iOS的SDK中。例如，UIApplication类有一个方法叫sharedApplication，从任何地方调用这个方法，都将返回与当前正在运行的应用程序相关联的UIApplication实例。除了这个，NSNotificationCenter(消息中心) 、NSFileManager(文件管理) 、 NSUserDefaults(应用程序设置) 、NSURLCache(请求缓存)、NSHTTPCookieStorage(应用程序cookies池)都是系统单例；[NSNotificationCenter defaultCenter]，[UIColor redColor]也是单例，单例类保证了应用程序的生命周期中有且仅有一个该类的实例对象，而且易于外界访问。</span><br><span class="line"></span><br><span class="line">单例模式的要点：</span><br><span class="line">一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。</span><br><span class="line"></span><br><span class="line">---简单实现单例---</span><br><span class="line">/* Singleton.h */ </span><br><span class="line">#import &quot;Foundation/Foundation.h&quot;</span><br><span class="line">@interface Singleton : NSObject </span><br><span class="line">+ (Singleton *)shardInstance; </span><br><span class="line">@end </span><br><span class="line"></span><br><span class="line">/* Singleton.m */ </span><br><span class="line">#import &quot;Singleton.h&quot; </span><br><span class="line">static Singleton *instance = nil; </span><br><span class="line"></span><br><span class="line">@implementation Singleton </span><br><span class="line">+ (Singleton *)sharedInstance </span><br><span class="line">	&#123; </span><br><span class="line">    if (!instance) </span><br><span class="line">    &#123; </span><br><span class="line">        instance = [[super allocWithZone:NULL] init]; </span><br><span class="line">    &#125; </span><br><span class="line">    return instance; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">---官方推荐写法---</span><br><span class="line">/* Singleton.h */</span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">@interface Singleton : NSObject</span><br><span class="line">+ (Singleton *)sharedInstance;</span><br><span class="line">@end</span><br><span class="line">/* Singleton.m */</span><br><span class="line">#import &quot;Singleton.h&quot;</span><br><span class="line">static Singleton *instance = nil;</span><br><span class="line">@implementation Singleton </span><br><span class="line">+ (Singleton *)sharedInstance </span><br><span class="line">	&#123; </span><br><span class="line">    static dispatch_once_t predicate;</span><br><span class="line">    dispatch_once(&amp;predicate,</span><br><span class="line">    ^&#123;</span><br><span class="line">        instance = [[Singleton alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return instance; </span><br><span class="line">&#125;</span><br><span class="line">获取实例：Singleton * singleton = [Singleton sharedInstance];</span><br></pre></td></tr></table></figure>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">工厂模式是另一种常见的设计模式，本质上是使用方法来简化类的选择和初始化过程。</span><br><span class="line"></span><br><span class="line">下面是一个网上到处都是的简单工厂模式的例子：</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">//  OperationFactory.m</span><br><span class="line">//  FactoryPattern</span><br><span class="line"></span><br><span class="line">#import &quot;OperationFactory.h&quot;</span><br><span class="line">#import &quot;Operation.h&quot;</span><br><span class="line">#import &quot;OperationAdd.h&quot;</span><br><span class="line">#import &quot;OperationSub.h&quot;</span><br><span class="line">#import &quot;OperationMul.h&quot;</span><br><span class="line">#import &quot;OperationDiv.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation OperationFactory</span><br><span class="line"></span><br><span class="line">+ (Operation *) createOperat:(char)operate</span><br><span class="line">&#123;</span><br><span class="line">    Operation *oper = nil;</span><br><span class="line">    switch (operate) </span><br><span class="line">    &#123;</span><br><span class="line">        case &apos;+&apos;:</span><br><span class="line">        &#123;</span><br><span class="line">            oper = [[OperationAdd alloc] init];</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case &apos;-&apos;:</span><br><span class="line">        &#123;</span><br><span class="line">            oper = [[OperationSub alloc] init];</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case &apos;*&apos;:</span><br><span class="line">        &#123;</span><br><span class="line">            oper = [[OperationMul alloc] init];</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        case &apos;/&apos;:</span><br><span class="line">        &#123;</span><br><span class="line">            oper = [[OperationDiv alloc] init];</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        default:</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return oper;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">由于 Objective-C 本身的动态特性，还可以用反射来改写：</span><br><span class="line"></span><br><span class="line">@implementation OperationFactory</span><br><span class="line">+ (Operation *) createOperat:(NSString *)operate</span><br><span class="line"> &#123;</span><br><span class="line">    Operation *oper = nil;</span><br><span class="line">    Class class = NSClassFromString(operate);</span><br><span class="line">    oper = [(Operation *)[class alloc] init];</span><br><span class="line">    if ([oper respondsToSelector:@selector(getResult)]) &#123;//判断是否有此名字的方法</span><br><span class="line">        [oper getResult];</span><br><span class="line">    &#125;</span><br><span class="line">    return oper;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">使用时，可以传入类名，来获取对应类的对象：</span><br><span class="line"></span><br><span class="line">Operation *oper = [OperationFactory createOperat: @&quot;OperationAdd&quot;];</span><br><span class="line">oper.numberA = 10;</span><br><span class="line">oper.numberB = 20;</span><br><span class="line">NSLog(@&quot;%f&quot;, oper.getResult);</span><br></pre></td></tr></table></figure>
<h3 id="委托模式"><a href="#委托模式" class="headerlink" title="委托模式"></a>委托模式</h3><p>委托模式是 Cocoa 中十分常见的设计模式，在 Cocoa 库中被大量的使用。在 Objective-C 中，委托模式通常使用协议（protocol）来实现。<br>委托模式，是简单的强大的模式，可让一个对象扮演另外对象的行为。委托对象保持到另外对象的引用，并在适当的时候发消息给另外对象。委托对象可以在发送消息的时候做一些额外的事情。<br>在cocoa框架中的委托模式，委托对象往往是框架中的对象，被委托对象是自定义的controller对象。委托对象保持一个到被委托对象的弱引用。是典型的回调。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---ex1---:</span><br><span class="line">@protocol PrintDelegate &lt;NSObject&gt;</span><br><span class="line">- (void)print;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@interface AClass : NSObject&lt;PrintDelegate&gt;</span><br><span class="line">@property id&lt;PrintDelegate&gt; delegate;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation AClass</span><br><span class="line"></span><br><span class="line">-(void)sayHello &#123;</span><br><span class="line">    [self.delegate print];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)print &#123;</span><br><span class="line">    NSLog(@&quot;Do Print&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 使用 AClass</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        AClass * a = [AClass new];</span><br><span class="line">        a.delegate = a;</span><br><span class="line">        [a sayHello];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---ex2---:</span><br><span class="line">CPPropOperationView.h</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"> </span><br><span class="line">#pragma mark - delegate</span><br><span class="line">@protocol CPPropOperationViewDelegate &lt;NSObject&gt;</span><br><span class="line">@required</span><br><span class="line">-(void) refreshPropOperationView:(id)sender;</span><br><span class="line">-(void) closePropOperationView:(id)sender; </span><br><span class="line">@end</span><br><span class="line"> </span><br><span class="line">#pragma mark - class</span><br><span class="line">@interface CPPropOperationView : UIView &#123;</span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic, assign) id&lt;CPPropOperationViewDelegate&gt; delegate;</span><br><span class="line">@property (nonatomic, retain) UIImageView* backgroundImageView;</span><br><span class="line">@property (nonatomic, retain) UIButton* refreshBtn;</span><br><span class="line">@property (nonatomic, retain) UIButton* closeBtn;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">CPPropOperationView.m</span><br><span class="line"></span><br><span class="line">#import &quot;CPPropOperationView.h&quot;</span><br><span class="line"> </span><br><span class="line">@implementation CPPropOperationView</span><br><span class="line">@synthesize delegate;</span><br><span class="line">@synthesize backgroundImageView = _backgroundImageView;</span><br><span class="line">@synthesize refreshBtn = _refreshBtn;</span><br><span class="line">@synthesize closeBtn = _closeBtn;</span><br><span class="line"> </span><br><span class="line">#pragma mark - View Life Cycle</span><br><span class="line">- (id)initWithFrame:(CGRect)frame &#123;</span><br><span class="line">    self = [super initWithFrame:frame];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        // Initialization code       </span><br><span class="line">        </span><br><span class="line">        // background image.</span><br><span class="line">        self.backgroundImageView = [[[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;bg.png&quot;]] autorelease];</span><br><span class="line">        [self.backgroundImageView setFrame:CGRectMake(0, 0, frame.size.width, frame.size.height)];</span><br><span class="line">        [self addSubview:self.backgroundImageView];</span><br><span class="line">         </span><br><span class="line">        // Refresh button. Bind to delegate&apos;s refreshPropOperationView:.</span><br><span class="line">        self.refreshBtn = [UIButton buttonWithType:UIButtonTypeCustom];</span><br><span class="line">        [self.refreshBtn setFrame:CGRectMake(0, 0, 225, 45)];</span><br><span class="line">        [self.refreshBtn setTitle:@&quot;Refresh 0&quot; forState:UIControlStateNormal];</span><br><span class="line">        [self.refreshBtn addTarget:delegate action:@selector(refreshPropOperationView:) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">        [self addSubview:self.refreshBtn];</span><br><span class="line">        </span><br><span class="line">        // Prop close button. Bind to delegate&apos;s closePropOperationView:.</span><br><span class="line">        self.closeBtn = [UIButton buttonWithType:UIButtonTypeCustom];</span><br><span class="line">        [self.closeBtn setFrame:CGRectMake(0, 100, 45, 45)];</span><br><span class="line">        [self.closeBtn setImage:[UIImage imageNamed:@&quot;close.png&quot;] forState:UIControlStateNormal];</span><br><span class="line">        [self.closeBtn addTarget:delegate action:@selector(closePropOperationView:) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">        [self addSubview:self.closeBtn];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">StoreViewCtrler.h </span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#import &quot;CPPropOperationView.h&quot;</span><br><span class="line"> </span><br><span class="line">@interface StoreViewCtrler : UIViewController &lt;CPPropOperationViewDelegate&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic, retain) CPPropOperationView* propOperationView;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">StoreViewCtrler.m</span><br><span class="line">#import &quot;StoreViewCtrler.h&quot;</span><br><span class="line">#import &quot;CPPropOperationView.h&quot;</span><br><span class="line"> </span><br><span class="line">@implementation StoreViewCtrler</span><br><span class="line">@synthesize magiboxOperationView;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#pragma mark - CPPropOperationViewDelegate </span><br><span class="line">-(void) refreshPropOperationView:(id)sender &#123; </span><br><span class="line">     self.backgroundImageView.image = [UIImage imageNamed:@&quot;bg2.png&quot;];</span><br><span class="line">     [self.propOperationView.refreshBtn setTitle:[NSString stringWithFormat:@&quot;Refresh 1&quot;] forState:UIControlStateNormal]; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">-(void) closePropOperationView:(id)sender &#123;</span><br><span class="line">     self.propOperationView.hidden = YES;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#pragma mark - View lifecycle </span><br><span class="line">-(void) viewWillAppear:(BOOL)animated &#123;</span><br><span class="line">    [super viewWillAppear:animated];</span><br><span class="line">     </span><br><span class="line">    if (self.propOperationView == nil) &#123;</span><br><span class="line">        self.propOperationView = [[[CPPropOperationView alloc] initWithFrame:CGRectMake(0, 0, 300, 300)] autorelease];</span><br><span class="line">        self.propOperationView.delegate = self;</span><br><span class="line">        [self.view addSubview:self.propOperationView];</span><br><span class="line">    &#125;</span><br><span class="line">    self.propOperationView.hidden = NO;</span><br><span class="line">&#125; </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="观察者模式（Observer）"><a href="#观察者模式（Observer）" class="headerlink" title="观察者模式（Observer）"></a>观察者模式（Observer）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cocoa 中提供了两种用于实现观察者模式的办法，一直是使用NSNotification，另一种是KVO(Key Value Observing)。</span><br><span class="line"></span><br><span class="line">NSNotification</span><br><span class="line"></span><br><span class="line">NSNotification 基于 Cocoa 自己的消息中心组件 NSNotificationCenter 实现。</span><br><span class="line"></span><br><span class="line">观察者需要统一在消息中心注册，说明自己要观察哪些值的变化。观察者通过类似下面的函数来进行注册：</span><br><span class="line"></span><br><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self</span><br><span class="line">                         selector:@selector(printName:)</span><br><span class="line">                             name: @&quot;messageName&quot;</span><br><span class="line">                           object:nil];</span><br><span class="line">上面的函数表明把自身注册成 &quot;messageName&quot; 消息的观察者，当有消息时，会调用自己的 printName 方法。</span><br><span class="line"></span><br><span class="line">消息发送者使用类似下面的函数发送消息：</span><br><span class="line"></span><br><span class="line">[[NSNotificationCenter defaultCenter] postNotificationName:@&quot;messageName&quot;</span><br><span class="line">                                    object:nil</span><br><span class="line">                                  userInfo:nil];</span><br></pre></td></tr></table></figure>
<h3 id="KVO-Key-Value-Observing"><a href="#KVO-Key-Value-Observing" class="headerlink" title="KVO(Key Value Observing)"></a>KVO(Key Value Observing)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">KVO的实现依赖于 Objective-C 本身强大的 KVC(Key Value Coding) 特性，可以实现对于某个属性变化的动态监测。</span><br><span class="line"></span><br><span class="line">示例代码如下：</span><br><span class="line"></span><br><span class="line">// Book类</span><br><span class="line">@interface Book : NSObject</span><br><span class="line"></span><br><span class="line">@property NSString *name;</span><br><span class="line">@property CGFloat price;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// AClass类</span><br><span class="line">@class Book;</span><br><span class="line">@interface AClass : NSObject</span><br><span class="line"></span><br><span class="line">@property (strong) Book *book;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation AClass</span><br><span class="line"></span><br><span class="line">- (id)init:(Book *)theBook &#123;</span><br><span class="line">    if(self = [super init])&#123;</span><br><span class="line">        self.book = theBook;</span><br><span class="line">        [self.book addObserver:self forKeyPath:@&quot;price&quot; options:NSKeyValueObservingOptionOld|NSKeyValueObservingOptionNew context:nil];</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath</span><br><span class="line">                      ofObject:(id)object</span><br><span class="line">                        change:(NSDictionary *)change</span><br><span class="line">                       context:(void *)context&#123;</span><br><span class="line">    if([keyPath isEqual:@&quot;price&quot;])&#123;</span><br><span class="line">        NSLog(@&quot;------price is changed------&quot;);</span><br><span class="line">        NSLog(@&quot;old price is %@&quot;,[change objectForKey:@&quot;old&quot;]);</span><br><span class="line">        NSLog(@&quot;new price is %@&quot;,[change objectForKey:@&quot;new&quot;]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">    [self.book removeObserver:self forKeyPath:@&quot;price&quot;];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// 使用 KVO</span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        Book *aBook = [Book new];</span><br><span class="line">        aBook.price = 10.9;</span><br><span class="line">        AClass * a = [[AClass alloc] init:aBook];</span><br><span class="line">        aBook.price = 11; // 输出 price is changed</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
	  

	  <div>
  		<center>
		  <div class="pagination">
<ul class="pagination">
	
	
	
	
	
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
			
		
	
		
	
		
	
		
			
		
	
		
			
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	
	
		<li class="prev"><a href="/2016/06/06/iOS/iOS页面流/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>prev</a></li>
	
	<li><a href="/"><i class="fa fa-archive"></i>Home</a></li>
	
		<li class="next disabled"><a>next<i class="fa fa-arrow-circle-o-right"></i></a></li>
	
</ul>
</div>

		</center>
	  </div>
	  
	</div> <!-- col-md-9/col-md-12 -->
	
  </div><!-- row -->

	</div>
  </div>
  <div class="container-narrow">
	<footer> <p>
  &copy; 2016 John Doe
  
      with help from <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-wixo/">Wixo</a>.    
</p> </footer>
  </div> <!-- container-narrow -->
  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/jquery.tableofcontents.min.js"></script>
<script src="/js/tocgenerator.min.js"></script>
<script src="/js/main.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


</body>
</html>
