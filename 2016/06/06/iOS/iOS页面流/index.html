<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>iOS页面流 | spike</title>
  <meta name="author" content="John Doe">
  
  <meta name="description" content="原文
页面流
一个手机上的app，通常会有多个页面，我们从页面A跳转到页面B，再从页面B跳到页面C，然后我们从页面C跳回到B，或者直接从页面C跳回到页面A，这些跳转，就是我们页面流的逻辑。看看上面的图，可以知道，我们这里主要讨论的是iOS中基于 Navigation方式 + Modal方式 的页面流">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="iOS页面流"/>
  <meta property="og:site_name" content="spike"/>

  
    <meta property="og:image" content="undefined"/>
  

  
    <link rel="alternative" href="/atom.xml" title="spike" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">  
  <link rel="stylesheet" href="/css/sidenav.css" media="screen" type="text/css">  
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  

</head>

<body id="body" data-spy="scroll" data-target=".toc">
  <div class="container" id="container">
	<div class="content">
	  <div class="page-header">		
  <h1><a class="brand" href="/">spike</a><span class="split"></span><span class="title">iOS页面流</span><span class="date" id="title-date"><i class="fa fa-clock-o"></i> 2016-06-06</span></h1>
</div>		

<div class="row page">
  <!-- cols -->	
  
  

  
	<div class="col-md-12">
	  

	  <!-- content -->
	  <p><a href="http://www.samirchen.com/" target="_blank" rel="external">原文</a></p>
<h3 id="页面流"><a href="#页面流" class="headerlink" title="页面流"></a>页面流</h3><p><img src="http://ww2.sinaimg.cn/mw1024/bc254b75jw1f4usactd4rj20k20j4gns.jpg" alt="页面流"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一个手机上的app，通常会有多个页面，我们从页面A跳转到页面B，再从页面B跳到页面C，然后我们从页面C跳回到B，或者直接从页面C跳回到页面A，这些跳转，就是我们页面流的逻辑。看看上面的图，可以知道，我们这里主要讨论的是iOS中基于 Navigation方式 + Modal方式 的页面流逻辑。</span><br><span class="line"></span><br><span class="line">那么什么是 Navigation式 的跳转？什么又是 Modal式 的跳转呢？</span><br><span class="line"></span><br><span class="line">Navigation式 的跳转就是上图中蓝色的实线箭头所表示的跳转方式，它所推动的整个视图流就如同一个树状结构，非常清晰，多用于主干视图的展现。iOS 在管理它们时用到了 UINavigationController，其机制就如同栈一样。在图中所有被 Navigation式 地管理着的 View Controller 我都把背景标为了蓝色。</span><br><span class="line"></span><br><span class="line">Modal式 的跳转就是上图中绿色的虚线箭头所表示的跳转方式，它多用于场景式的视图的展现，所以作为 Modal 跳转的目的 VC 通常是用于展示数据的视图或者功能性视图等等，这样的视图可能会在主干中的多种情况下被调用，就比如图中的 VCM1 被 VCN2 和 VCN3 都用到了。在我们实际使用中，通常拍照页面对应的VC就会被用作是Modal式的。在图中所有被 Modal式 地管理着的 View Controller 我都把背景标为了绿色。</span><br></pre></td></tr></table></figure>
<h2 id="页面之间的跳转及传参"><a href="#页面之间的跳转及传参" class="headerlink" title="页面之间的跳转及传参"></a>页面之间的跳转及传参</h2><h4 id="在设置根控制器的时候可以传参："><a href="#在设置根控制器的时候可以传参：" class="headerlink" title="在设置根控制器的时候可以传参："></a>在设置根控制器的时候可以传参：</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">NavigationController的初始化</span><br><span class="line">在图中，我们的入口是先创建一个 <span class="built_in">UINavigationController</span>，并把它的初始VC设置为 VCN1，同时可以在这里传参，代码如下：</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 AppDelegate.m 中</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">	VCN1* vcn1 = [[VCN1 alloc] init];</span><br><span class="line">	vcn1.stringPara = <span class="string">@"value"</span>; <span class="comment">// 传参</span></span><br><span class="line">	<span class="built_in">UINavigationController</span>* mainNavigationController = [[<span class="built_in">UINavigationController</span> alloc] initWithRootViewController:vcn1];</span><br><span class="line">	[mainNavigationController setNavigationBarHidden:<span class="literal">YES</span>];</span><br><span class="line">	[<span class="keyword">self</span>.window setRootViewController:mainNavigationController];</span><br><span class="line">	<span class="keyword">self</span>.window.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line">	[<span class="keyword">self</span>.window makeKeyAndVisible];</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Navigation-Push-传参"><a href="#Navigation-Push-传参" class="headerlink" title="Navigation-Push 传参"></a>Navigation-Push 传参</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">在图中，蓝色实线正向的箭头就表示的是 Navigation 的 Push 动作，比如：VCN1-&gt;VCN2; VCN1-&gt;VCN3-&gt;VCN4; VCN5-&gt;VCN6; VCN5-&gt;VCN7-&gt;VCN8 等跳转。一般来说，我们都是一级一级往前Push的，不应该有 VCN1-&gt;VCN4 这样的正向跳跃式Push的需求，要不然图就不这样画了，页面流就不这样设计了。在Push动作中传参是非常简单直接的，因为你这里创建了你要跳达的VC，直接设置其参数属性就可以了。</span><br><span class="line"></span><br><span class="line">例如，VCN1-&gt;VCN2 的跳转代码</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 VCN1.m 中</span></span><br><span class="line">-(<span class="keyword">void</span>) goVCN2:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">	VCN2* vcn2 = [[VCN2 alloc] init];</span><br><span class="line">	vcn2.stringPara = <span class="string">@"value"</span>; <span class="comment">// 传参</span></span><br><span class="line">	[<span class="keyword">self</span>.navigationController pushViewController:vcn2 animated:<span class="literal">YES</span>]; <span class="comment">// 这里的self.navigationController就是MainNavigationController。</span></span><br><span class="line">&#125;</span><br><span class="line">在做了以上Push后，VCN2 就会被压到由MainNavigationController管理的栈的栈顶。这个栈就是 <span class="keyword">self</span>.navigationController.viewControllers。</span><br><span class="line"></span><br><span class="line">Push动作是很简单的，基本上所有的Push代码都类似上面这样写。</span><br><span class="line"></span><br><span class="line">以下为push传值的两个实例：</span><br><span class="line">实例一和实例二都是一个意思，主要是在.m中有可接收的属性，再用push的方式进行传值</span><br><span class="line"></span><br><span class="line">实例一：</span><br><span class="line">首先SecondViewController视图中需要有一个属性用来存储传递过来的值：</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,retain) <span class="built_in">NSString</span> *firstValue ;<span class="comment">//属性传值</span></span><br><span class="line"></span><br><span class="line">然后MainViewController视图需要引用SecondViewController视图的头文件，在视图中的按钮点击事件中，通过SecondViewController的对象将需要传递的值存在firstValue中:</span><br><span class="line">(<span class="keyword">void</span>)buttonAction:(<span class="built_in">UIButton</span> *)button</span><br><span class="line">&#123;</span><br><span class="line">SecondViewController *second = </span><br><span class="line">[[SecondViewController alloc]init];<span class="comment">//用下一个视图的属性接受想要传过去的值,属性传值</span></span><br><span class="line">second.firstValue = _txtFiled.text;</span><br><span class="line">[<span class="keyword">self</span>.navigationController pushViewController:second animated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line">页面跳转之后，就能在SecondViewController视图中，通过存值的属性，取用刚才传递过来的值：</span><br><span class="line"><span class="comment">//显示传过来的值[_txtFiled setText:_firstValue];</span></span><br><span class="line"></span><br><span class="line">实例二：</span><br><span class="line">属性传值 将A页面所拥有的信息通过属性传递到B页面使用</span><br><span class="line">B页面定义了一个naviTitle属性，在A页面中直接通过属性赋值将A页面中的值传到B页面。</span><br><span class="line"></span><br><span class="line">A页面DetailViewController.h文件</span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"DetailViewController.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RootViewController</span> :<span class="title">UIViewController</span>&lt;<span class="title">ChangeDelegate</span>&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UITextField</span> *tf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">A RootViewController.m页面实现文件</span><br><span class="line"><span class="meta">#import <span class="meta-string">"RootViewController.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"DetailViewController.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RootViewController</span> ()</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RootViewController</span></span></span><br><span class="line"><span class="comment">//核心代码</span></span><br><span class="line">-(<span class="keyword">void</span>)loadView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIButton</span> *btn = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeRoundedRect</span>];</span><br><span class="line">    btn.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">30</span>);</span><br><span class="line">    [btn setTitle:<span class="string">@"Push"</span> forState:<span class="number">0</span>];</span><br><span class="line">    [btn addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(pushAction:) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:btn];</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)pushAction:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    tf = (<span class="built_in">UITextField</span> *)[<span class="keyword">self</span>.viewviewWithTag:<span class="number">1000</span>];</span><br><span class="line">    <span class="comment">//导航push到下一个页面</span></span><br><span class="line">    <span class="comment">//pushViewController 入栈引用计数+1，且控制权归系统</span></span><br><span class="line">    </span><br><span class="line">    DetailViewController *detailViewController = [[DetailViewControlleralloc]init];</span><br><span class="line">    <span class="comment">//属性传值，直接属性赋值</span></span><br><span class="line">    detailViewController.naviTitle =tf.text;</span><br><span class="line">    <span class="comment">//导航push到下一个页面</span></span><br><span class="line">    [<span class="keyword">self</span>.navigationControllerpushViewController:detailViewController animated:<span class="literal">YES</span>];</span><br><span class="line">    [detailViewControllerrelease];   </span><br><span class="line">&#125;</span><br><span class="line">B页面DetailViewController.h文件</span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DetailViewController</span> :<span class="title">UIViewController</span></span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">UITextField</span> *textField;</span><br><span class="line">   <span class="built_in">NSString</span> *_naviTitle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,retain)<span class="built_in">NSString</span> *naviTitle;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">B页面.m实现文件</span><br><span class="line"><span class="meta">#import <span class="meta-string">"DetailViewController.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DetailViewController</span> ()</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DetailViewController</span></span></span><br><span class="line"><span class="keyword">@synthesize</span> naviTitle =_naviTitle;</span><br><span class="line">-(<span class="keyword">void</span>)loadView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.view = [[[<span class="built_in">UIViewalloc</span>]initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>,<span class="number">0</span>, <span class="number">320</span>,<span class="number">480</span>)]autorelease];</span><br><span class="line">   <span class="keyword">self</span>.title = <span class="keyword">self</span>.naviTitle ;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Navigation-Pop-传参"><a href="#Navigation-Pop-传参" class="headerlink" title="Navigation-Pop 传参"></a>Navigation-Pop 传参</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">在图中，蓝色实线反向的箭头就表示的是 Navigation 的 Pop 动作，比如：VCN2-&gt;VCN1; VCN4-&gt;VCN3 等跳转，Pop的跳转需求相对Push就复杂一点了，因为我们还可能有类似 VCN4-&gt;VCN1; VCN8-&gt;VCN5 这样的反向跳跃式Pop的需求，这种需求是合理的。比如：我们由“设置页面”进入“登陆页面”，由“登陆页面”进入“注册页面”，等注册完成了，我们想从“注册页面”直接跳回“登陆页面”这是合理的。所以这里Pop动作就分为：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>）逐级Pop</span><br><span class="line">逐级Pop是很简单，但是要往回传参就没Push那样方便了，你需要去 <span class="keyword">self</span>.navigationController.viewControllers 中去找到你要跳达的VC，然后设置其参数。例如，VCN2-&gt;VCN1 的跳转代码</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 VCN2.m 中</span></span><br><span class="line">-(<span class="keyword">void</span>) back:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> *preVCIndex = <span class="keyword">self</span>.navigationController.viewControllers.count - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (preVCIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">UIViewController</span> *preVC = [<span class="keyword">self</span>.navigationController.viewControllers objectAtIndex:preVCIndex];</span><br><span class="line">        <span class="keyword">if</span> ([preVC isKindOfClass:[VCN1 class]]) &#123;</span><br><span class="line">        	VCN1* vcn1 = (VCN1*) preVC;</span><br><span class="line">        	vcn1.stringPara = <span class="string">@"value"</span>; <span class="comment">// 传参</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	[<span class="keyword">self</span>.navigationController popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br><span class="line">做了以上的Pop后，VCN2 就会被弹出由MainNavigationController管理的栈。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）跳跃式Pop</span><br><span class="line">要完成跳跃式Pop，可以去遍历 <span class="keyword">self</span>.navigationController.viewControllers 找到你想跳达的页面，然后Pop过去就可以了，传参也在这时设置即可。例如，VCN4-&gt;VCN1 的跳转代码</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 VCN4.m 中</span></span><br><span class="line">-(<span class="keyword">void</span>) backToVCN1:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">	<span class="comment">// 这里要稍微复杂一点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">UIViewController</span>* vc <span class="keyword">in</span> <span class="keyword">self</span>.navigationController.viewControllers) &#123;</span><br><span class="line">    	<span class="keyword">if</span> ([vc isKindOfClass:[VCN1 class]]) &#123;</span><br><span class="line">    		vcn1.stringPara = <span class="string">@"value"</span>; <span class="comment">// 传参</span></span><br><span class="line">        	[<span class="keyword">self</span>.navigationController popToViewController:vc animated:<span class="literal">YES</span>];</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">做了以上的跳跃式Pop后，<span class="keyword">self</span>.navigationController.viewControllers 这个栈中所有在 VCN1 上面的 VC 都会被弹出。通过这种方式，可以跳到栈中任意的页面。</span><br><span class="line"></span><br><span class="line">如果你想直接回到栈底，比如在我们的图中 VCN4-&gt;VCN1 就是回到栈底的情况，你还可以这样做：</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 VCN4.m 中</span></span><br><span class="line">-(<span class="keyword">void</span>) backToVCN1:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">	<span class="keyword">if</span> ([[<span class="keyword">self</span>.navigationController.viewControllers firstObject] isKindOfClass:[VCN1 class]]) &#123;</span><br><span class="line">    	VCN1* vcn1 = (VCN1*) [<span class="keyword">self</span>.navigationController.viewControllers firstObject];</span><br><span class="line">    	vcn1.stringPara = <span class="string">@"value"</span>; <span class="comment">// 传参</span></span><br><span class="line">	&#125;</span><br><span class="line">	[<span class="keyword">self</span>.navigationController popToRootViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h5 id="Modal-Present"><a href="#Modal-Present" class="headerlink" title="Modal-Present"></a>Modal-Present</h5></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在图中，绿色虚线正向的箭头就表示的是 Modal 的 Present 动作，比如：VCN2-&gt;VCM1; VCM1-&gt;VCM2; VCN4-&gt;VCN5; VCN6-&gt;VCM3 等跳转。Present 也是一级一级往前的。在Present动作中传参，也跟Push类似，因为在这里你要创建你想要展示的页面，这时候设置其参数属性即可。但是在我们的图中出现了几种不同Present的情况：</span><br><span class="line"></span><br><span class="line">1）Navigation页面流中的某个页面Present一个Modal的页面</span><br><span class="line">例如，VCN2-&gt;VCM1 的跳转代码：</span><br><span class="line"></span><br><span class="line">// 在 VCN2.m 中</span><br><span class="line">-(void) goVCM1:(id)sender &#123;</span><br><span class="line">	VCM1* vcm1 = [[VCM1 alloc] init];</span><br><span class="line">	[vcm1 setModalTransitionStyle:UIModalTransitionStyleCoverVertical];</span><br><span class="line">	vcm1.stringPara = @&quot;value&quot;; // 传参</span><br><span class="line">	[self.navigationController presentViewController:vcm1 animated:YES completion:nil]; // Present modal vc, not pop. 这里用 self.navigationController present 和 用 self present 的效果都是一样的。但是倾向与用前者，后面说明为什么。</span><br><span class="line">&#125;</span><br><span class="line">2）一个Modal的页面Present另一个Modal的页面</span><br><span class="line">例如，VCM1-&gt;VCM2 的跳转代码：</span><br><span class="line"></span><br><span class="line">// 在 VCM1.m 中</span><br><span class="line">-(void) goVCM2:(id)sender &#123;</span><br><span class="line">	VCM2* vcm2 = [[VCM2 alloc] init];</span><br><span class="line">	[vcm2 setModalTransitionStyle:UIModalTransitionStyleCoverVertical];</span><br><span class="line">	vcm2.stringPara = @&quot;value&quot;; // 传参</span><br><span class="line">	[self presentViewController:vcm2 animated:YES completion:nil]; // Present modal vc, not pop. 这里只能用 self present 了。</span><br><span class="line">&#125;</span><br><span class="line">3）一个Navigation页面流中的某个页面Present另一个Navigation页面流</span><br><span class="line">这个过程其实就是再创建一个UINavigationController，指定它的 root vc，然后 Present 出来即可，但是注意这里Present的是这个新创建的 UINavigationController。</span><br><span class="line"></span><br><span class="line">例如，VCN4-&gt;SubNavigationVC.VCN5 的跳转代码：</span><br><span class="line"></span><br><span class="line">// 在 VCN4.m 中</span><br><span class="line">-(void) goSubNavigationVC:(id)sender &#123;</span><br><span class="line">	VCN5* vcn5 = [[VCN5 alloc] init]; // 这个是 subNavigationController 的 root vc。</span><br><span class="line">	vcn5.stringPara = @&quot;value&quot;; // 传参</span><br><span class="line">	UINavigationController* subNavigationController = [[UINavigationController alloc] initWithRootViewController:vcn5];</span><br><span class="line">	subNavigationController.navigationBarHidden = YES;</span><br><span class="line">	[self.navigationController presentViewController:subNavigationController animated:YES completion:nil]; // 这里 present 的是 subNavigationController。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Modal-Dismiss"><a href="#Modal-Dismiss" class="headerlink" title="Modal-Dismiss"></a>Modal-Dismiss</h5><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">这种情况稍复杂，现在很多利用block回传待添加。</span><br><span class="line"></span><br><span class="line">在图中，绿色虚线反向的箭头就表示的是 Modal 的 Dismiss 动作，比如：VCM1-&gt;VCN2; VCM2-&gt;VCM1; VCM3-&gt;VCN6 等跳转。Dismiss 这个动作其实写起来是很简单的，但是想要往回传参通常就会复杂一点了，尤其是在不同的情况下。这里的关键点就在于搞清楚当前所在VC的 presentingViewController 这个属性到底指向着谁。</span><br><span class="line"></span><br><span class="line">也就是说，当前的VC1如果是被另一个VC2给Present出来的，那么VC1中<span class="keyword">self</span>.presentingViewController就是VC2。如果当前的VC1不是被谁Present出来的，但是VC1的某个祖先VC是被另一个VC给Present出来的，那么VC1中<span class="keyword">self</span>.presentingViewController就是Present当前这个VC1的最近的祖先的那个VC。</span><br><span class="line"></span><br><span class="line">那么下面，我们就根据<span class="keyword">self</span>.presentingViewController这个属性含义，结合我们图中的几种情况做一下具体的说明：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>）Navigation页面流中的某个页面Present一个Modal的页面后Dismiss</span><br><span class="line">在 VCM1-&gt;VCN2 这种情况下，在VCM1中，<span class="keyword">self</span>.presentingViewController是谁呢？一般，我们会认为是 VCN2，但事实上不是VCN2 而是 MainNavigationVC，这是很容易弄错的地方。所以这里想要传参回去的话，就要去 MainNavigationVC 的 viewContollers 栈中找到 VCN2，设置其参数属性。这里就要提到我们在上面介绍 Modal-Present 的时候提到的 VCN2-&gt;VCM1 的跳转代码，在那段代码里我们是用 <span class="keyword">self</span>.navigationController present...，其实这里不管用 <span class="keyword">self</span>.navigationController present... 还是用 <span class="keyword">self</span> present...，到VCM1后，VCM1的presentingViewController都是MainNavigationVC，所以我们选择写清楚点，用前者。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）一个Modal的页面Present另一个Modal的页面后Dismiss</span><br><span class="line">在 VCM2-&gt;VCM1 这种情况下，VCM1是被VCM2Present出来的，所以VCM2 的 presentingViewController 就是 VCM1，所以跳转代码如下：</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 VCM2.m 中</span></span><br><span class="line">-(<span class="keyword">void</span>) back:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">	<span class="keyword">if</span> ([<span class="keyword">self</span>.presentingViewController isKindOfClass:[VCM1 class]]) &#123;</span><br><span class="line">		VCM1* vcm1 = (VCM1*) [<span class="keyword">self</span>.presentingViewController isKindOfClass:[VCM1 class]];</span><br><span class="line">		vcm1.stringPara = <span class="string">@"value"</span>; <span class="comment">// 传参</span></span><br><span class="line">	&#125;</span><br><span class="line">	[<span class="keyword">self</span>.presentingViewController dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line">如果我们Present了多层的Modal式VC，而我们想直接跳跃式地Dismiss返回，比如：VCM4-&gt;VCM1 这种情况，VCM4 的 presentingViewController 是 VCM2，而 VCM2 的 presentingViewController 是 VCM1，所以 VCM4-&gt;VCM1 的跳转代码：</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 VCM4.m 中</span></span><br><span class="line">-(<span class="keyword">void</span>) backToVCM1:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">	<span class="keyword">if</span> ([<span class="keyword">self</span>.presentingViewController.presentingViewController isKindOfClass:[VCM1 class]]) &#123;</span><br><span class="line">		VCM1* vcm1 = (VCM1*) [<span class="keyword">self</span>.presentingViewController.presentingViewController isKindOfClass:[VCM1 class]];</span><br><span class="line">		vcm1.stringPara = <span class="string">@"value"</span>; <span class="comment">// 传参</span></span><br><span class="line">	&#125;</span><br><span class="line">	[<span class="keyword">self</span>.presentingViewController.presentingViewController dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line">这样写其实是比较不美观的，尤其是当层次更多更深的时候，如果真有那种情况，那就建议把多层次的Modal式页面流直接改成Navigation式管理更好。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）一个Navigation页面流中的某个页面Present另一个Navigation页面流后Dismiss</span><br><span class="line">在 SubNavigationVC.VCN5-&gt;VCN4 的情况下，VCN5 其实不是被谁Present出来的，但是它的父VC(<span class="keyword">self</span>.parentViewController)是SubNavigationVC，而SubNavigationVC是被MainNavigationVC给Prsent出来的，所以VCN5的presentingViewController就是MainNavigationVC。</span><br><span class="line"></span><br><span class="line">SubNavigationVC.VCN5-&gt;VCN4 的跳转代码：</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 VCN5.m 中</span></span><br><span class="line">-(<span class="keyword">void</span>) back:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">	<span class="comment">// self.presentingViewController是MainNavigationVC</span></span><br><span class="line">	<span class="keyword">if</span> ([<span class="keyword">self</span>.presentingViewController isKindOfClass:[<span class="built_in">UINavigationController</span> class]]) &#123;</span><br><span class="line">    	<span class="built_in">UINavigationController</span>* mainNavigationController = (<span class="built_in">UINavigationController</span>*) <span class="keyword">self</span>.presentingViewController;</span><br><span class="line">    	<span class="keyword">if</span> ([[mainNavigationController.viewControllers lastObject] isKindOfClass:[VCN4 class]]) &#123;</span><br><span class="line">        	VCN4* vcn4 = (VCN4*) [mainNavigationController.viewControllers lastObject];</span><br><span class="line">        	vcn4.stringPara = <span class="string">@"value"</span>; <span class="comment">// 传参</span></span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	[<span class="keyword">self</span>.presentingViewController dismissViewControllerAnimated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line">其实所有由SubNavigationVC管理的这些VC(包括VCN5，VCN6，VCN7，VCN8)的presentingViewController都是MainNavigationVC。所以我们可以直接从这些VC中任意一个直接跳到MainNavigationVC的栈顶的VCN4页面。</span><br></pre></td></tr></table></figure>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">===Navigation方式+Modal方式 的页面流逻辑其实已经能够满足我们大多时候的使用场景，如果你发现仍然不能满足，那建议首先考虑考虑项目的视图流的设计是不是合理。</span><br><span class="line">Navigation式的跳转只要牢牢盯住所在 VC 的 <span class="keyword">self</span>.navigationController，理解其像栈一样管理页面流的方式，然后好好使用 <span class="keyword">self</span>.navigationController.viewControllers 这个 VC栈 就好了。</span><br><span class="line">Modal式的跳转只要牢牢盯住所在 VC 的 <span class="keyword">self</span>.presentingViewController 就好了，一定要搞清楚它是哪个，这里是很容易弄混而造成代码逻辑错误的。从Navigation页面流Present出来的Modal页面，这个Modal页面的presentingViewController是对应的的<span class="built_in">UINavigationController</span>，而不是其中的那个具体的页面。</span><br><span class="line"></span><br><span class="line">===关于基于Storyboard来实现页面跳转和传参的方式多是基于Segue来实现的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">===DismissViewController</span><br><span class="line">这个是控制页面消失的方法，调用方法当前页面消失，适用于presentViewController的反操作。需求是连续dismiss两次回到最开始的页面。方法：[<span class="keyword">self</span> dismissViewControllerAnimated:<span class="literal">YES</span> completion:^&#123;[<span class="keyword">self</span>.navigationController popViewControllerAnimated:<span class="literal">NO</span>]&#125;];在回调的逻辑中填写你自己需要的跳转方法就可以了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">====页面PopViewController的回退调用block</span><br><span class="line">这种回调的block是跟随着动画的，在uitableView中实验了，对于重新加载数据不好用，但是对于一般的回退，很有用[<span class="built_in">CATransaction</span> begin];[<span class="built_in">CATransaction</span> setCompletionBlock:^&#123;    <span class="comment">// handle completion here</span>&#125;];</span><br><span class="line">[<span class="keyword">self</span>.navigationController popViewControllerAnimated:<span class="literal">YES</span>];</span><br><span class="line">[<span class="built_in">CATransaction</span> commit];</span><br><span class="line"></span><br><span class="line">自己研究的方法是，在pop之前给一个全局变量赋值，然后在新的页面viewWillAppear()中，进行判断然后书写相应逻辑进行刷新等操作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">===StoryBoard使用segue页面间传递数据:</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>) prepareForSegue:(<span class="built_in">UIStoryboardSegue</span> *)segue sender:(<span class="keyword">id</span>)sender</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([segue.identifier isEqualToString:<span class="string">@"SubLevelSegue"</span>]) &#123;</span><br><span class="line">        SubLevelViewController *mySubLevelViewController = segue.destinationViewController;</span><br><span class="line">        <span class="built_in">UITableViewCell</span> *cell = sender;</span><br><span class="line">        mySubLevelViewController.title = cell.textLabel.text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)prepareForSegue:(<span class="built_in">UIStoryboardSegue</span> *)segue sender:(<span class="keyword">id</span>)sender &#123;     <span class="built_in">UIViewController</span> *destination = segue.destinationViewController;       <span class="keyword">if</span> ([destination respondsToSelector:<span class="keyword">@selector</span>(setDelegate:)]) &#123;            [destination setValue:<span class="keyword">self</span> forKey:<span class="string">@"delegate"</span>];        &#125;        <span class="keyword">if</span> ([destination respondsToSelector:<span class="keyword">@selector</span>(setSelection:)]) &#123;            <span class="comment">// prepare selection info      </span>    <span class="built_in">NSIndexPath</span> *indexPath = [<span class="keyword">self</span>.tableView indexPathForCell:sender];                   <span class="keyword">id</span> object = <span class="keyword">self</span>.tasks[indexPath.row];                <span class="built_in">NSDictionary</span> *selection = @&#123;   <span class="string">@"indexPath"</span> : indexPath,   <span class="string">@"object"</span> : object&#125;;            [destination setValue:selection forKey:<span class="string">@"selection"</span>];    &#125; &#125;</span><br></pre></td></tr></table></figure>
	  

	  <div>
  		<center>
		  <div class="pagination">
<ul class="pagination">
	
	
	
	
	
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
			
		
	
		
	
		
	
		
			
			
		
	
		
			
			
			
		
	
		
	
		
	
		
	
		
	
		
	
	
	
		<li class="prev"><a href="/2016/06/15/iOS/iOS应用程序的生命周期/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>prev</a></li>
	
	<li><a href="/"><i class="fa fa-archive"></i>Home</a></li>
	
		<li class="next"><a href="/2016/06/06/iOS/iOS开发中的几种设计模式/" class="alignright next">next<i class="fa fa-arrow-circle-o-right"></i></a></li>
	
</ul>
</div>

		</center>
	  </div>
	  
	</div> <!-- col-md-9/col-md-12 -->
	
  </div><!-- row -->

	</div>
  </div>
  <div class="container-narrow">
	<footer> <p>
  &copy; 2016 John Doe
  
      with help from <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-wixo/">Wixo</a>.    
</p> </footer>
  </div> <!-- container-narrow -->
  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/jquery.tableofcontents.min.js"></script>
<script src="/js/tocgenerator.min.js"></script>
<script src="/js/main.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


</body>
</html>
