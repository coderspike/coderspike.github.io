<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>iOS页面流 | spike 代码之美</title>
  <meta name="author" content="John Doe">
  
  <meta name="description" content="开始学iOS编程的时候对页面之间如何跳转，传值等问题一直没太闹清楚，用这篇文章整理一下，大部分内容转载自这位阿里大神的博客（http://www.samirchen.com/），个人能力有限，希望在不断的记录中踏实前进。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="iOS页面流"/>
  <meta property="og:site_name" content="spike 代码之美"/>

  
    <meta property="og:image" content="undefined"/>
  

  
    <link rel="alternative" href="/atom.xml" title="spike 代码之美" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">  
  <link rel="stylesheet" href="/css/sidenav.css" media="screen" type="text/css">  
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  

</head>

<body id="body" data-spy="scroll" data-target=".toc">
  <div class="container" id="container">
	<div class="content">
	  <div class="page-header">		
  <h1><a class="brand" href="/">spike 代码之美</a><span class="split"></span><span class="title">iOS页面流</span><span class="date" id="title-date"><i class="fa fa-clock-o"></i> 2016-06-06</span></h1>
</div>		

<div class="row page">
  <!-- cols -->	
  
  

  
	<div class="col-md-12">
	  

	  <!-- content -->
	  <blockquote>
<p>开始学iOS编程的时候对页面之间如何跳转，传值等问题一直没太闹清楚，用这篇文章整理一下，大部分内容转载自这位阿里大神的博客（<a href="http://www.samirchen.com/），个人能力有限，希望在不断的记录中踏实前进。" target="_blank" rel="external">http://www.samirchen.com/），个人能力有限，希望在不断的记录中踏实前进。</a></p>
</blockquote>
<a id="more"></a>
<h2 id="页面流"><a href="#页面流" class="headerlink" title="页面流"></a>页面流</h2><p><img src="http://ww2.sinaimg.cn/mw1024/bc254b75jw1f4usactd4rj20k20j4gns.jpg" alt="页面流"></p>
<p>一个手机上的app，通常会有多个页面，我们从页面A跳转到页面B，再从页面B跳到页面C，然后我们从页面C跳回到B，或者直接从页面C跳回到页面A，这些跳转，就是我们页面流的逻辑。看看上面的图，可以知道，我们这里主要讨论的是iOS中基于 Navigation方式 + Modal方式 的页面流逻辑。</p>
<p>那么什么是 Navigation式 的跳转？什么又是 Modal式 的跳转呢？</p>
<p>Navigation式 的跳转就是上图中蓝色的实线箭头所表示的跳转方式，它所推动的整个视图流就如同一个树状结构，非常清晰，多用于主干视图的展现。iOS 在管理它们时用到了 UINavigationController，其机制就如同栈一样。在图中所有被 Navigation式 地管理着的 View Controller 我都把背景标为了蓝色。</p>
<p>Modal式 的跳转就是上图中绿色的虚线箭头所表示的跳转方式，它多用于场景式的视图的展现，所以作为 Modal 跳转的目的 VC 通常是用于展示数据的视图或者功能性视图等等，这样的视图可能会在主干中的多种情况下被调用，就比如图中的 VCM1 被 VCN2 和 VCN3 都用到了。在我们实际使用中，通常拍照页面对应的VC就会被用作是Modal式的。在图中所有被 Modal式 地管理着的 View Controller 我都把背景标为了绿色。</p>
<h2 id="页面之间的跳转及传参（暂列出几种，剩下的会在以后逐步添加。）"><a href="#页面之间的跳转及传参（暂列出几种，剩下的会在以后逐步添加。）" class="headerlink" title="页面之间的跳转及传参（暂列出几种，剩下的会在以后逐步添加。）"></a>页面之间的跳转及传参（暂列出几种，剩下的会在以后逐步添加。）</h2><ul>
<li><h4 id="在设置根控制器的时候可以传参："><a href="#在设置根控制器的时候可以传参：" class="headerlink" title="在设置根控制器的时候可以传参："></a>在设置根控制器的时候可以传参：</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NavigationController的初始化</span><br><span class="line">在图中，我们的入口是先创建一个 UINavigationController，并把它的初始VC设置为 VCN1，同时可以在这里传参，代码如下：</span><br><span class="line"></span><br><span class="line">// 在 AppDelegate.m 中</span><br><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">	VCN1* vcn1 = [[VCN1 alloc] init];</span><br><span class="line">	vcn1.stringPara = @&quot;value&quot;; // 传参</span><br><span class="line">	UINavigationController* mainNavigationController = [[UINavigationController alloc] initWithRootViewController:vcn1];</span><br><span class="line">	[mainNavigationController setNavigationBarHidden:YES];</span><br><span class="line">	[self.window setRootViewController:mainNavigationController];</span><br><span class="line">	self.window.backgroundColor = [UIColor whiteColor];</span><br><span class="line">	[self.window makeKeyAndVisible];</span><br><span class="line">	return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="Navigation-Push-传参"><a href="#Navigation-Push-传参" class="headerlink" title="Navigation-Push 传参"></a>Navigation-Push 传参</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在图中，蓝色实线正向的箭头就表示的是 Navigation 的 Push 动作，比如：VCN1-&gt;VCN2; VCN1-&gt;VCN3-&gt;VCN4; VCN5-&gt;VCN6; VCN5-&gt;VCN7-&gt;VCN8 等跳转。一般来说，我们都是一级一级往前Push的，不应该有 VCN1-&gt;VCN4 这样的正向跳跃式Push的需求，要不然图就不这样画了，页面流就不这样设计了。在Push动作中传参是非常简单直接的，因为你这里创建了你要跳达的VC，直接设置其参数属性就可以了。</span><br><span class="line"></span><br><span class="line">例如，VCN1-&gt;VCN2 的跳转代码</span><br><span class="line"></span><br><span class="line">// 在 VCN1.m 中</span><br><span class="line">-(void) goVCN2:(id)sender &#123;</span><br><span class="line">	VCN2* vcn2 = [[VCN2 alloc] init];</span><br><span class="line">	vcn2.stringPara = @&quot;value&quot;; // 传参</span><br><span class="line">	[self.navigationController pushViewController:vcn2 animated:YES]; // 这里的self.navigationController就是MainNavigationController。</span><br><span class="line">&#125;</span><br><span class="line">在做了以上Push后，VCN2 就会被压到由MainNavigationController管理的栈的栈顶。这个栈就是 self.navigationController.viewControllers。</span><br><span class="line"></span><br><span class="line">Push动作是很简单的，基本上所有的Push代码都类似上面这样写。</span><br><span class="line"></span><br><span class="line">以下为push传值的两个实例：</span><br><span class="line">实例一和实例二都是一个意思，主要是在.m中有可接收的属性，再用push的方式进行传值</span><br><span class="line"></span><br><span class="line">实例一：</span><br><span class="line">首先SecondViewController视图中需要有一个属性用来存储传递过来的值：</span><br><span class="line">@property(nonatomic,retain) NSString *firstValue ;//属性传值</span><br><span class="line"></span><br><span class="line">然后MainViewController视图需要引用SecondViewController视图的头文件，在视图中的按钮点击事件中，通过SecondViewController的对象将需要传递的值存在firstValue中:</span><br><span class="line">(void)buttonAction:(UIButton *)button</span><br><span class="line">&#123;</span><br><span class="line">SecondViewController *second = </span><br><span class="line">[[SecondViewController alloc]init];//用下一个视图的属性接受想要传过去的值,属性传值</span><br><span class="line">second.firstValue = _txtFiled.text;</span><br><span class="line">[self.navigationController pushViewController:second animated:YES];</span><br><span class="line">&#125;</span><br><span class="line">页面跳转之后，就能在SecondViewController视图中，通过存值的属性，取用刚才传递过来的值：</span><br><span class="line">//显示传过来的值[_txtFiled setText:_firstValue];</span><br><span class="line"></span><br><span class="line">实例二：</span><br><span class="line">属性传值 将A页面所拥有的信息通过属性传递到B页面使用</span><br><span class="line">B页面定义了一个naviTitle属性，在A页面中直接通过属性赋值将A页面中的值传到B页面。</span><br><span class="line"></span><br><span class="line">A页面DetailViewController.h文件</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#import &quot;DetailViewController.h&quot;</span><br><span class="line">@interface RootViewController :UIViewController&lt;ChangeDelegate&gt;</span><br><span class="line">&#123;</span><br><span class="line">    UITextField *tf;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">A RootViewController.m页面实现文件</span><br><span class="line">#import &quot;RootViewController.h&quot;</span><br><span class="line">#import &quot;DetailViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface RootViewController ()</span><br><span class="line">@end</span><br><span class="line">@implementation RootViewController</span><br><span class="line">//核心代码</span><br><span class="line">-(void)loadView</span><br><span class="line">&#123;</span><br><span class="line">    UIButton *btn = [UIButton buttonWithType:UIButtonTypeRoundedRect];</span><br><span class="line">    btn.frame = CGRectMake(0, 0, 100, 30);</span><br><span class="line">    [btn setTitle:@&quot;Push&quot; forState:0];</span><br><span class="line">    [btn addTarget:self action:@selector(pushAction:) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">    [self.view addSubview:btn];</span><br><span class="line">&#125;</span><br><span class="line">-(void)pushAction:(id)sender</span><br><span class="line">&#123;</span><br><span class="line">    tf = (UITextField *)[self.viewviewWithTag:1000];</span><br><span class="line">    //导航push到下一个页面</span><br><span class="line">    //pushViewController 入栈引用计数+1，且控制权归系统</span><br><span class="line">    </span><br><span class="line">    DetailViewController *detailViewController = [[DetailViewControlleralloc]init];</span><br><span class="line">    //属性传值，直接属性赋值</span><br><span class="line">    detailViewController.naviTitle =tf.text;</span><br><span class="line">    //导航push到下一个页面</span><br><span class="line">    [self.navigationControllerpushViewController:detailViewController animated:YES];</span><br><span class="line">    [detailViewControllerrelease];   </span><br><span class="line">&#125;</span><br><span class="line">B页面DetailViewController.h文件</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface DetailViewController :UIViewController</span><br><span class="line">&#123;</span><br><span class="line">   UITextField *textField;</span><br><span class="line">   NSString *_naviTitle;</span><br><span class="line">&#125;</span><br><span class="line">@property(nonatomic,retain)NSString *naviTitle;</span><br><span class="line">@end</span><br><span class="line">B页面.m实现文件</span><br><span class="line">#import &quot;DetailViewController.h&quot;</span><br><span class="line">@interface DetailViewController ()</span><br><span class="line">@end</span><br><span class="line">@implementation DetailViewController</span><br><span class="line">@synthesize naviTitle =_naviTitle;</span><br><span class="line">-(void)loadView</span><br><span class="line">&#123;</span><br><span class="line">    self.view = [[[UIViewalloc]initWithFrame:CGRectMake(0,0, 320,480)]autorelease];</span><br><span class="line">   self.title = self.naviTitle ;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="Navigation-Pop-传参"><a href="#Navigation-Pop-传参" class="headerlink" title="Navigation-Pop 传参"></a>Navigation-Pop 传参</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在图中，蓝色实线反向的箭头就表示的是 Navigation 的 Pop 动作，比如：VCN2-&gt;VCN1; VCN4-&gt;VCN3 等跳转，Pop的跳转需求相对Push就复杂一点了，因为我们还可能有类似 VCN4-&gt;VCN1; VCN8-&gt;VCN5 这样的反向跳跃式Pop的需求，这种需求是合理的。比如：我们由“设置页面”进入“登陆页面”，由“登陆页面”进入“注册页面”，等注册完成了，我们想从“注册页面”直接跳回“登陆页面”这是合理的。所以这里Pop动作就分为：</span><br><span class="line"></span><br><span class="line">1）逐级Pop</span><br><span class="line">逐级Pop是很简单，但是要往回传参就没Push那样方便了，你需要去 self.navigationController.viewControllers 中去找到你要跳达的VC，然后设置其参数。例如，VCN2-&gt;VCN1 的跳转代码</span><br><span class="line"></span><br><span class="line">// 在 VCN2.m 中</span><br><span class="line">-(void) back:(id)sender &#123;</span><br><span class="line">    NSInteger *preVCIndex = self.navigationController.viewControllers.count - 2;</span><br><span class="line">    if (preVCIndex &gt;= 0) &#123;</span><br><span class="line">        UIViewController *preVC = [self.navigationController.viewControllers objectAtIndex:preVCIndex];</span><br><span class="line">        if ([preVC isKindOfClass:[VCN1 class]]) &#123;</span><br><span class="line">        	VCN1* vcn1 = (VCN1*) preVC;</span><br><span class="line">        	vcn1.stringPara = @&quot;value&quot;; // 传参</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	[self.navigationController popViewControllerAnimated:YES];</span><br><span class="line">&#125;</span><br><span class="line">做了以上的Pop后，VCN2 就会被弹出由MainNavigationController管理的栈。</span><br><span class="line"></span><br><span class="line">2）跳跃式Pop</span><br><span class="line">要完成跳跃式Pop，可以去遍历 self.navigationController.viewControllers 找到你想跳达的页面，然后Pop过去就可以了，传参也在这时设置即可。例如，VCN4-&gt;VCN1 的跳转代码</span><br><span class="line"></span><br><span class="line">// 在 VCN4.m 中</span><br><span class="line">-(void) backToVCN1:(id)sender &#123;</span><br><span class="line">	// 这里要稍微复杂一点</span><br><span class="line">	for (UIViewController* vc in self.navigationController.viewControllers) &#123;</span><br><span class="line">    	if ([vc isKindOfClass:[VCN1 class]]) &#123;</span><br><span class="line">    		vcn1.stringPara = @&quot;value&quot;; // 传参</span><br><span class="line">        	[self.navigationController popToViewController:vc animated:YES];</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">做了以上的跳跃式Pop后，self.navigationController.viewControllers 这个栈中所有在 VCN1 上面的 VC 都会被弹出。通过这种方式，可以跳到栈中任意的页面。</span><br><span class="line"></span><br><span class="line">如果你想直接回到栈底，比如在我们的图中 VCN4-&gt;VCN1 就是回到栈底的情况，你还可以这样做：</span><br><span class="line"></span><br><span class="line">// 在 VCN4.m 中</span><br><span class="line">-(void) backToVCN1:(id)sender &#123;</span><br><span class="line">	if ([[self.navigationController.viewControllers firstObject] isKindOfClass:[VCN1 class]]) &#123;</span><br><span class="line">    	VCN1* vcn1 = (VCN1*) [self.navigationController.viewControllers firstObject];</span><br><span class="line">    	vcn1.stringPara = @&quot;value&quot;; // 传参</span><br><span class="line">	&#125;</span><br><span class="line">	[self.navigationController popToRootViewControllerAnimated:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h5 id="Modal-Present"><a href="#Modal-Present" class="headerlink" title="Modal-Present"></a>Modal-Present</h5></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在图中，绿色虚线正向的箭头就表示的是 Modal 的 Present 动作，比如：VCN2-&gt;VCM1; VCM1-&gt;VCM2; VCN4-&gt;VCN5; VCN6-&gt;VCM3 等跳转。Present 也是一级一级往前的。在Present动作中传参，也跟Push类似，因为在这里你要创建你想要展示的页面，这时候设置其参数属性即可。但是在我们的图中出现了几种不同Present的情况：</span><br><span class="line"></span><br><span class="line">1）Navigation页面流中的某个页面Present一个Modal的页面</span><br><span class="line">例如，VCN2-&gt;VCM1 的跳转代码：</span><br><span class="line"></span><br><span class="line">// 在 VCN2.m 中</span><br><span class="line">-(void) goVCM1:(id)sender &#123;</span><br><span class="line">	VCM1* vcm1 = [[VCM1 alloc] init];</span><br><span class="line">	[vcm1 setModalTransitionStyle:UIModalTransitionStyleCoverVertical];</span><br><span class="line">	vcm1.stringPara = @&quot;value&quot;; // 传参</span><br><span class="line">	[self.navigationController presentViewController:vcm1 animated:YES completion:nil]; // Present modal vc, not pop. 这里用 self.navigationController present 和 用 self present 的效果都是一样的。但是倾向与用前者，后面说明为什么。</span><br><span class="line">&#125;</span><br><span class="line">2）一个Modal的页面Present另一个Modal的页面</span><br><span class="line">例如，VCM1-&gt;VCM2 的跳转代码：</span><br><span class="line"></span><br><span class="line">// 在 VCM1.m 中</span><br><span class="line">-(void) goVCM2:(id)sender &#123;</span><br><span class="line">	VCM2* vcm2 = [[VCM2 alloc] init];</span><br><span class="line">	[vcm2 setModalTransitionStyle:UIModalTransitionStyleCoverVertical];</span><br><span class="line">	vcm2.stringPara = @&quot;value&quot;; // 传参</span><br><span class="line">	[self presentViewController:vcm2 animated:YES completion:nil]; // Present modal vc, not pop. 这里只能用 self present 了。</span><br><span class="line">&#125;</span><br><span class="line">3）一个Navigation页面流中的某个页面Present另一个Navigation页面流</span><br><span class="line">这个过程其实就是再创建一个UINavigationController，指定它的 root vc，然后 Present 出来即可，但是注意这里Present的是这个新创建的 UINavigationController。</span><br><span class="line"></span><br><span class="line">例如，VCN4-&gt;SubNavigationVC.VCN5 的跳转代码：</span><br><span class="line"></span><br><span class="line">// 在 VCN4.m 中</span><br><span class="line">-(void) goSubNavigationVC:(id)sender &#123;</span><br><span class="line">	VCN5* vcn5 = [[VCN5 alloc] init]; // 这个是 subNavigationController 的 root vc。</span><br><span class="line">	vcn5.stringPara = @&quot;value&quot;; // 传参</span><br><span class="line">	UINavigationController* subNavigationController = [[UINavigationController alloc] initWithRootViewController:vcn5];</span><br><span class="line">	subNavigationController.navigationBarHidden = YES;</span><br><span class="line">	[self.navigationController presentViewController:subNavigationController animated:YES completion:nil]; // 这里 present 的是 subNavigationController。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h5 id="Modal-Dismiss"><a href="#Modal-Dismiss" class="headerlink" title="Modal-Dismiss"></a>Modal-Dismiss</h5></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这种情况稍复杂，现在很多利用block回传待添加。</span><br><span class="line"></span><br><span class="line">在图中，绿色虚线反向的箭头就表示的是 Modal 的 Dismiss 动作，比如：VCM1-&gt;VCN2; VCM2-&gt;VCM1; VCM3-&gt;VCN6 等跳转。Dismiss 这个动作其实写起来是很简单的，但是想要往回传参通常就会复杂一点了，尤其是在不同的情况下。这里的关键点就在于搞清楚当前所在VC的 presentingViewController 这个属性到底指向着谁。</span><br><span class="line"></span><br><span class="line">也就是说，当前的VC1如果是被另一个VC2给Present出来的，那么VC1中self.presentingViewController就是VC2。如果当前的VC1不是被谁Present出来的，但是VC1的某个祖先VC是被另一个VC给Present出来的，那么VC1中self.presentingViewController就是Present当前这个VC1的最近的祖先的那个VC。</span><br><span class="line"></span><br><span class="line">那么下面，我们就根据self.presentingViewController这个属性含义，结合我们图中的几种情况做一下具体的说明：</span><br><span class="line"></span><br><span class="line">1）Navigation页面流中的某个页面Present一个Modal的页面后Dismiss</span><br><span class="line">在 VCM1-&gt;VCN2 这种情况下，在VCM1中，self.presentingViewController是谁呢？一般，我们会认为是 VCN2，但事实上不是VCN2 而是 MainNavigationVC，这是很容易弄错的地方。所以这里想要传参回去的话，就要去 MainNavigationVC 的 viewContollers 栈中找到 VCN2，设置其参数属性。这里就要提到我们在上面介绍 Modal-Present 的时候提到的 VCN2-&gt;VCM1 的跳转代码，在那段代码里我们是用 self.navigationController present...，其实这里不管用 self.navigationController present... 还是用 self present...，到VCM1后，VCM1的presentingViewController都是MainNavigationVC，所以我们选择写清楚点，用前者。</span><br><span class="line"></span><br><span class="line">2）一个Modal的页面Present另一个Modal的页面后Dismiss</span><br><span class="line">在 VCM2-&gt;VCM1 这种情况下，VCM1是被VCM2Present出来的，所以VCM2 的 presentingViewController 就是 VCM1，所以跳转代码如下：</span><br><span class="line"></span><br><span class="line">// 在 VCM2.m 中</span><br><span class="line">-(void) back:(id)sender &#123;</span><br><span class="line">	if ([self.presentingViewController isKindOfClass:[VCM1 class]]) &#123;</span><br><span class="line">		VCM1* vcm1 = (VCM1*) [self.presentingViewController isKindOfClass:[VCM1 class]];</span><br><span class="line">		vcm1.stringPara = @&quot;value&quot;; // 传参</span><br><span class="line">	&#125;</span><br><span class="line">	[self.presentingViewController dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">&#125;</span><br><span class="line">如果我们Present了多层的Modal式VC，而我们想直接跳跃式地Dismiss返回，比如：VCM4-&gt;VCM1 这种情况，VCM4 的 presentingViewController 是 VCM2，而 VCM2 的 presentingViewController 是 VCM1，所以 VCM4-&gt;VCM1 的跳转代码：</span><br><span class="line"></span><br><span class="line">// 在 VCM4.m 中</span><br><span class="line">-(void) backToVCM1:(id)sender &#123;</span><br><span class="line">	if ([self.presentingViewController.presentingViewController isKindOfClass:[VCM1 class]]) &#123;</span><br><span class="line">		VCM1* vcm1 = (VCM1*) [self.presentingViewController.presentingViewController isKindOfClass:[VCM1 class]];</span><br><span class="line">		vcm1.stringPara = @&quot;value&quot;; // 传参</span><br><span class="line">	&#125;</span><br><span class="line">	[self.presentingViewController.presentingViewController dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">&#125;</span><br><span class="line">这样写其实是比较不美观的，尤其是当层次更多更深的时候，如果真有那种情况，那就建议把多层次的Modal式页面流直接改成Navigation式管理更好。</span><br><span class="line"></span><br><span class="line">3）一个Navigation页面流中的某个页面Present另一个Navigation页面流后Dismiss</span><br><span class="line">在 SubNavigationVC.VCN5-&gt;VCN4 的情况下，VCN5 其实不是被谁Present出来的，但是它的父VC(self.parentViewController)是SubNavigationVC，而SubNavigationVC是被MainNavigationVC给Prsent出来的，所以VCN5的presentingViewController就是MainNavigationVC。</span><br><span class="line"></span><br><span class="line">SubNavigationVC.VCN5-&gt;VCN4 的跳转代码：</span><br><span class="line"></span><br><span class="line">// 在 VCN5.m 中</span><br><span class="line">-(void) back:(id)sender &#123;</span><br><span class="line">	// self.presentingViewController是MainNavigationVC</span><br><span class="line">	if ([self.presentingViewController isKindOfClass:[UINavigationController class]]) &#123;</span><br><span class="line">    	UINavigationController* mainNavigationController = (UINavigationController*) self.presentingViewController;</span><br><span class="line">    	if ([[mainNavigationController.viewControllers lastObject] isKindOfClass:[VCN4 class]]) &#123;</span><br><span class="line">        	VCN4* vcn4 = (VCN4*) [mainNavigationController.viewControllers lastObject];</span><br><span class="line">        	vcn4.stringPara = @&quot;value&quot;; // 传参</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	[self.presentingViewController dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">&#125;</span><br><span class="line">其实所有由SubNavigationVC管理的这些VC(包括VCN5，VCN6，VCN7，VCN8)的presentingViewController都是MainNavigationVC。所以我们可以直接从这些VC中任意一个直接跳到MainNavigationVC的栈顶的VCN4页面。</span><br></pre></td></tr></table></figure>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">===Navigation方式+Modal方式 的页面流逻辑其实已经能够满足我们大多时候的使用场景，如果你发现仍然不能满足，那建议首先考虑考虑项目的视图流的设计是不是合理。</span><br><span class="line">Navigation式的跳转只要牢牢盯住所在 VC 的 self.navigationController，理解其像栈一样管理页面流的方式，然后好好使用 self.navigationController.viewControllers 这个 VC栈 就好了。</span><br><span class="line">Modal式的跳转只要牢牢盯住所在 VC 的 self.presentingViewController 就好了，一定要搞清楚它是哪个，这里是很容易弄混而造成代码逻辑错误的。从Navigation页面流Present出来的Modal页面，这个Modal页面的presentingViewController是对应的的UINavigationController，而不是其中的那个具体的页面。</span><br><span class="line"></span><br><span class="line">===关于基于Storyboard来实现页面跳转和传参的方式多是基于Segue来实现的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">===DismissViewController</span><br><span class="line">这个是控制页面消失的方法，调用方法当前页面消失，适用于presentViewController的反操作。需求是连续dismiss两次回到最开始的页面。方法：[self dismissViewControllerAnimated:YES completion:^&#123;[self.navigationController popViewControllerAnimated:NO]&#125;];在回调的逻辑中填写你自己需要的跳转方法就可以了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">====页面PopViewController的回退调用block</span><br><span class="line">这种回调的block是跟随着动画的，在uitableView中实验了，对于重新加载数据不好用，但是对于一般的回退，很有用[CATransaction begin];[CATransaction setCompletionBlock:^&#123;    // handle completion here&#125;];</span><br><span class="line">[self.navigationController popViewControllerAnimated:YES];</span><br><span class="line">[CATransaction commit];</span><br><span class="line"></span><br><span class="line">自己研究的方法是，在pop之前给一个全局变量赋值，然后在新的页面viewWillAppear()中，进行判断然后书写相应逻辑进行刷新等操作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">===StoryBoard使用segue页面间传递数据:</span><br><span class="line"></span><br><span class="line">- (void) prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender</span><br><span class="line">&#123;</span><br><span class="line">    if ([segue.identifier isEqualToString:@&quot;SubLevelSegue&quot;]) &#123;</span><br><span class="line">        SubLevelViewController *mySubLevelViewController = segue.destinationViewController;</span><br><span class="line">        UITableViewCell *cell = sender;</span><br><span class="line">        mySubLevelViewController.title = cell.textLabel.text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123;     UIViewController *destination = segue.destinationViewController;       if ([destination respondsToSelector:@selector(setDelegate:)]) &#123;            [destination setValue:self forKey:@&quot;delegate&quot;];        &#125;        if ([destination respondsToSelector:@selector(setSelection:)]) &#123;            // prepare selection info          NSIndexPath *indexPath = [self.tableView indexPathForCell:sender];                   id object = self.tasks[indexPath.row];                NSDictionary *selection = @&#123;   @&quot;indexPath&quot; : indexPath,   @&quot;object&quot; : object&#125;;            [destination setValue:selection forKey:@&quot;selection&quot;];    &#125; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">===iOS PresentViewControlle后,直接返回根视图</span><br><span class="line">在开发中：用[self presentViewController:VC animated:YES completion:nil];实现跳转，多次跳转后，直接返回第一个。</span><br><span class="line">例如：</span><br><span class="line">A presentViewController B</span><br><span class="line">B presentViewController C</span><br><span class="line">C 直接回到A：</span><br><span class="line"> </span><br><span class="line">返回第一个视图核心代码如下：</span><br><span class="line">[self.presentingViewController.presentingViewController dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">===关于几种逆向传值的方法接下来会补充：</span><br></pre></td></tr></table></figure>
	  

	  <div>
  		<center>
		  <div class="pagination">
<ul class="pagination">
	
	
	
	
	
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
			
		
	
		
	
		
	
		
			
			
		
	
		
			
			
			
		
	
		
	
		
	
		
	
		
	
		
	
	
	
		<li class="prev"><a href="/2016/06/15/iOS/iOS应用程序的生命周期/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>prev</a></li>
	
	<li><a href="/"><i class="fa fa-archive"></i>Home</a></li>
	
		<li class="next"><a href="/2016/06/06/iOS/iOS开发中的几种设计模式/" class="alignright next">next<i class="fa fa-arrow-circle-o-right"></i></a></li>
	
</ul>
</div>

		</center>
	  </div>
	  
	</div> <!-- col-md-9/col-md-12 -->
	
  </div><!-- row -->

	</div>
  </div>
  <div class="container-narrow">
	<footer> <p>
  &copy; 2016 John Doe
  
      with help from <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-wixo/">Wixo</a>.    
</p> </footer>
  </div> <!-- container-narrow -->
  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/jquery.tableofcontents.min.js"></script>
<script src="/js/tocgenerator.min.js"></script>
<script src="/js/main.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


</body>
</html>
