<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> UIView简介和常用方法 · coder-gwb</title><meta name="description" content="UIView简介和常用方法 - null"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="http://fonts.useso.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">首页</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/categories/编程" target="_self" class="nav-list-link">编程</a></li><li class="nav-list-item"><a href="/categories/读书" target="_self" class="nav-list-link">读书</a></li><li class="nav-list-item"><a href="/categories/生活" target="_self" class="nav-list-link">生活</a></li><li class="nav-list-item"><a href="https://github.com/coderspike" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">UIView简介和常用方法</h1><div class="post-info">2016年6月12日</div><div class="post-content"><blockquote>
<p>UIView表示屏幕上的一块矩形区域，负责渲染区域的内容，并且响应该区域内发生的触摸事件。</p>
<p>继承关系：NSObject—UIResponder—UIView</p>
<p>屏幕上能够看见的都是UIView<br>每一个UIView都是容器</p>
<p>bounds的x,y永远为0(以自身左上角为原点)，frame的x,y以父视图的左上角为原点</p>
</blockquote>
<h3 id="常见属性"><a href="#常见属性" class="headerlink" title="常见属性"></a>常见属性</h3><p> @property frame<br> @property bounds<br> @property center<br> @property transform<br> @property alpha<br> @property backgroundColor<br> @property contentStretch</p>
<h3 id="UIView层的操作常用方法"><a href="#UIView层的操作常用方法" class="headerlink" title="UIView层的操作常用方法"></a>UIView层的操作常用方法</h3><p>(void)removeFromSuperview; // 从父视图中移除<br>(void)addSubview:(UIView <em>)view; // 添加一个子视图<br>(void)insertSubview:(UIView </em>)view belowSubview:(UIView <em>)slibingSubview; // 插入一个view到某个view的下层<br>(void)insertSubview:(UIView </em>)view aboveSubview:(UIView <em>)slibingSubview; // 插入一个view到某个view的上层<br>(void)insertSubview:(UIView </em>)view atIndex:(NSInteger)index; // 插入一个view到特定层<br>(void)bringSubviewToFront:(UIView <em>)view; // 将某个view放在最上层<br>(void)sendSubviewToBack:(UIView </em>)view; // 将某个view放在最下层<br>(BOOL)isDescendantOfView(UIView <em>)view; // 是否是某个视图的子孙视图<br>(void)exchangeSubviewAtIndex:(NSInteger)index1 withSubviewAtIndex:(NSInteger)index2; // 交换两个层的view<br>(UIView </em>)viewWithTag:(NSInteger)view; // 取到指定tag值的view</p>
<h3 id="UIView的加载过程"><a href="#UIView的加载过程" class="headerlink" title="UIView的加载过程"></a>UIView的加载过程</h3><p><img src="http://ww2.sinaimg.cn/mw1024/bc254b75jw1f4usac93ohj20mi0vsac7.jpg" alt="view"><br>我们可以知道如果是从 Storyboard 或 Nib 文件中加载 View Controller，我们都不要去重载 loadView，它会自动加载 view 属性以及它的各个 Subviews。只有当我们自己代码创建 View Controller 的时候，我们可能需要去重载 loadView。当然，如果我们不重载，那么默认情况下 loadView 会创建一个光秃秃的 UIView 对象赋给 view 属性。<br>loadView:先寻找有关可用的nib文件的信息，根据这个信息来加载nib文件，如果没有有关nib文件的信息，默认实现会创建一个空白的UIView对象，然后让这个对象成为controller的主view<br>首先访问view属性<br>如果存在view，加载。若不存在，则UIViewController调用loadView方法<br>loadView方法执行如下操作<br>如果覆盖了该方法，必须创建view给UIViewController的view属性<br>如果没有复写该方法，UIViewController会默认调用initWithNibName:bundle:方法初始化并加载view<br>通过viewDidLoad方法来执行一些其他任务</p>
<h3 id="UIViewController生命周期"><a href="#UIViewController生命周期" class="headerlink" title="UIViewController生命周期"></a>UIViewController生命周期</h3><p>(void)viewDidLoad; //视图加载完成<br>(void)viewWillAppear:(BOOL)animated; // 将要显示<br>(void)viewDidAppear:(BOOL)animated; // 显示完成<br>(void)viewWillDisappear:(BOOL)animated; // 将要移除<br>(void)viewDidDisappear:(BOOL)animated; // 已经移除<br>详细版本：</p>
<ol>
<li>-[ViewController initWithCoder:]或-[ViewController initWithNibName:Bundle]:首先从归档文件中加载UIViewController对象。即使是纯代码，也会把nil作为参数传给后者。<ol>
<li>-[UIView awakeFromNib]:作为第一个方法的助手，方便处理一些额外的设置。</li>
<li>-[ViewController loadView]:创建或加载一个view并把它赋值给UIViewController的view属性</li>
<li>-[ViewController viewDidLoad]:此时整个视图层次(view hierarchy)已经被放到内存中，可以移除一些视图，修改约束，加载数据等</li>
<li>-[ViewController viewWillAppear:]:视图加载完成，并即将显示在屏幕上,还没有设置动画，可以改变当前屏幕方向或状态栏的风格等。</li>
<li>-[ViewController viewWillLayoutSubviews]：即将开始子视图位置布局</li>
<li>-[ViewController viewDidLayoutSubviews]：用于通知视图的位置布局已经完成</li>
<li>-[ViewController viewDidAppear:]：视图已经展示在屏幕上，可以对视图做一些关于展示效果方面的修改。</li>
<li>-[ViewController viewWillDisappear:]：视图即将消失</li>
<li>-[ViewController viewDidDisappear:]：视图已经消失<br>如果考虑UIViewController可能在某个时刻释放整个view。那么再次加载视图时显然会从步骤3开始。因为此时的UIViewController对象依然存在。</li>
</ol>
</li>
</ol>
<h3 id="UIView、UIWindow、UIScreen、UIViewController-之间的层级关系"><a href="#UIView、UIWindow、UIScreen、UIViewController-之间的层级关系" class="headerlink" title="UIView、UIWindow、UIScreen、UIViewController 之间的层级关系"></a>UIView、UIWindow、UIScreen、UIViewController 之间的层级关系</h3><p><img src="http://ww1.sinaimg.cn/mw1024/bc254b75jw1f4usaaorkrj20y00i8gni.jpg" alt=""> </p>
<h3 id="UIView的bounds-frame和center属性"><a href="#UIView的bounds-frame和center属性" class="headerlink" title="UIView的bounds,frame和center属性"></a>UIView的bounds,frame和center属性</h3><p><img src="http://ww3.sinaimg.cn/mw1024/bc254b75jw1f4usab9jhfj20dk0abwf7.jpg" alt="bound"><br>看着上图，对照一下就很清楚了<br>View B’s bounds= ((0,0),(200,250))<br>View B’s frame= ((140,65),(320,320))<br>View B’s center= (300,225)</p>
<h3 id="常用方法收录"><a href="#常用方法收录" class="headerlink" title="常用方法收录"></a>常用方法收录</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">===获取指定的subViewfor(UIView *view in subviews)</span><br><span class="line">&#123;</span><br><span class="line">if(view.tag == 998)</span><br><span class="line">&#123;</span><br><span class="line">//根据tag判断</span><br><span class="line">&#125;</span><br><span class="line">if([view isKindOfClass:[UIImageView class]])</span><br><span class="line">&#123;</span><br><span class="line">//根据类型判断</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">===做一个与屏幕同等大小的UIView</span><br><span class="line">方法一：</span><br><span class="line"> #pragma mark - Setup</span><br><span class="line">- (void)setupUI &#123;</span><br><span class="line">// Use full screen layout.</span><br><span class="line">self.edgesForExtendedLayout = UIRectEdgeAll;</span><br><span class="line">self.automaticallyAdjustsScrollViewInsets = YES;</span><br><span class="line">self.extendedLayoutIncludesOpaqueBars = YES;</span><br><span class="line">self.view.backgroundColor = [UIColor whiteColor];</span><br><span class="line">// Title.</span><br><span class="line">self.title = @&quot;Detail&quot;;</span><br><span class="line">&#125;</span><br><span class="line">方法二：</span><br><span class="line">CGRect rect = [[UIScreen mainScreen] bounds];</span><br><span class="line">CGSize size = rect.size;</span><br><span class="line">CGFloat width = size.width;</span><br><span class="line">CGFloat height = size.height; </span><br><span class="line">CGRectMake(origin.x，origin.y，size.width. Size.height)在代码中定义矩形</span><br><span class="line">Frame:     该view在父view坐标系统中的位置和大小。（参照点是，父亲的坐标系统）</span><br><span class="line">bounds：该view在本地坐标系统中的位置和大小。   （参照点是，本地坐标系统，就相当于ViewB自己的坐标系统，以0,0点为起点）</span><br><span class="line">center： 该view的中心点在父view坐标系统中的位置和大小。（参照点是，父亲的坐标系统）</span><br><span class="line">===UIView添加UITableView      TestTableViewController *viewController = [[TestTableViewController alloc] init];</span><br><span class="line">      [self addChildViewController:viewController];</span><br><span class="line">      [self.view addSubview:viewController.view];</span><br><span class="line">      [viewController didMoveToParentViewController:self];</span><br><span class="line">      [如果不添加controller 则viewController 则不具备跳转等controller功能]</span><br><span class="line">===设置uiView的位置</span><br><span class="line">aView.frame = CGRectMake( 100, 200, aView.frame.size.width, aView.frame.size.height ); // set new position exactly</span><br><span class="line">===remove view from superView</span><br><span class="line"></span><br><span class="line">for (UIView* subView in [self.view.subviews])&#123;    if ([subView isKindOfClass:[ZeldaView class]])        [subView removeFromSuperview];&#125;===添加一条分割线</span><br><span class="line">UIView *navDividingLine = [[UIView alloc] initWithFrame:CGRectMake(0,159,self.view.bounds.size.width,1)];</span><br><span class="line">        navDividingLine.backgroundColor = [UIColor groupTableViewBackgroundColor];  //这个颜色就是默认表格线的颜色</span><br><span class="line">        [navDividingLine sizeToFit];</span><br><span class="line">        [self.view addSubview:navDividingLine];</span><br></pre></td></tr></table></figure>
<h3 id="UIView设置圆角"><a href="#UIView设置圆角" class="headerlink" title="UIView设置圆角"></a>UIView设置圆角</h3><p>UIView设置圆角<br>1、比较简单的情况，UIView四个角都是圆角：</p>
<pre><code>UIView *aView = [[UIView alloc] init];

aView.frame = CGRectMake(0, 0, 300, 200);
aView.backgroundColor = [UIColor redColor];

//设置圆角边框

aView.layer.cornerRadius = 8;

aView.layer.masksToBounds = YES;

//设置边框及边框颜色

aView.layer.borderWidth = 8;

aView.layer.borderColor =[ [UIColor grayColor] CGColor];

[self.view addSubview:aView];
</code></pre><p>2、设置四个角中的某个或者某几个为圆角</p>
<pre><code>UIView *aView = [[UIView alloc] init];

aView.frame = CGRectMake(0, 0, 300, 200);
aView.backgroundColor = [UIColor redColor];

[self.view addSubview:aView];

//设置所需的圆角位置以及大小
UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:aView.bounds byRoundingCorners:UIRectCornerBottomLeft | UIRectCornerBottomRight cornerRadii:CGSizeMake(10, 10)];
CAShapeLayer *maskLayer = [[CAShapeLayer alloc] init];
maskLayer.frame = aView.bounds;
maskLayer.path = maskPath.CGPath;
aView.layer.mask = maskLayer;
</code></pre><p>其中，UIRectCornerBottomLeft，UIRectCornerBottomRight是可以选择的角。</p>
<p>typedef NS_OPTIONS(NSUInteger, UIRectCorner) {<br>    UIRectCornerTopLeft     = 1 &lt;&lt; 0,<br>    UIRectCornerTopRight    = 1 &lt;&lt; 1,<br>    UIRectCornerBottomLeft  = 1 &lt;&lt; 2,<br>    UIRectCornerBottomRight = 1 &lt;&lt; 3,<br>    UIRectCornerAllCorners  = ~0UL<br>};</p>
<p>上面的枚举是可以供选择的角，分别是：“左上角”、“右上角”、“左下角”、“右下角”。</p>
</div></article></div></section><footer><div class="paginator"><a href="/2016/06/15/iOS应用程序的生命周期/" class="prev">PREV</a><a href="/2016/06/06/iOS工具类收录/" class="next">NEXT</a></div><div data-thread-key="2016/06/12/UIView简介和常用方法/" data-title="UIView简介和常用方法" data-url="http://yoursite.com/2016/06/12/UIView简介和常用方法/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"true"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script><div class="copyright"><p>© 2015 - 2016 <a href="http://yoursite.com"></a>, unless otherwise noted.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>