<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>UIView | spike</title>
  <meta name="author" content="John Doe">
  
  <meta name="description" content="UIView 表示屏幕上的一块矩形区域，负责渲染区域的内容，并且响应该区域内发生的触摸事件。它在iOS App中占有绝对重要的地位，因为iOS中几乎所有可视化控件都是 UIView 的子类。继承关系：NSObject—UIResponder—UIView屏幕上能够看见的都是UIViewUIView ">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="UIView"/>
  <meta property="og:site_name" content="spike"/>

  
    <meta property="og:image" content="undefined"/>
  

  
    <link rel="alternative" href="/atom.xml" title="spike" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">  
  <link rel="stylesheet" href="/css/sidenav.css" media="screen" type="text/css">  
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  

</head>

<body id="body" data-spy="scroll" data-target=".toc">
  <div class="container" id="container">
	<div class="content">
	  <div class="page-header">		
  <h1><a class="brand" href="/">spike</a><span class="split"></span><span class="title">UIView</span><span class="date" id="title-date"><i class="fa fa-clock-o"></i> 2016-06-12</span></h1>
</div>		

<div class="row page">
  <!-- cols -->	
  
  

  
	<div class="col-md-12">
	  

	  <!-- content -->
	  <blockquote>
<p>UIView 表示屏幕上的一块矩形区域，负责渲染区域的内容，并且响应该区域内发生的触摸事件。它在iOS App中占有绝对重要的地位，因为iOS中几乎所有可视化控件都是 UIView 的子类。<br>继承关系：NSObject—UIResponder—UIView<br>屏幕上能够看见的都是UIView<br>UIView 可以负责以下几种任务：<br>绘制和动画<br>布局和子视图管理<br>事件处理<br>bounds的x,y永远为0(以自身左上角为原点)，frame的x,y以父视图的左上角为原点</p>
</blockquote>
<h3 id="常见属性"><a href="#常见属性" class="headerlink" title="常见属性"></a>常见属性</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">The following properties of the <span class="built_in">UIView</span> class are animatable:</span><br><span class="line"> <span class="keyword">@property</span> frame</span><br><span class="line"> <span class="keyword">@property</span> bounds</span><br><span class="line"> <span class="keyword">@property</span> center</span><br><span class="line"> <span class="keyword">@property</span> transform</span><br><span class="line"> <span class="keyword">@property</span> alpha</span><br><span class="line"> <span class="keyword">@property</span> backgroundColor</span><br><span class="line"> <span class="keyword">@property</span> contentStretch</span><br></pre></td></tr></table></figure>
<h3 id="视图的几何属性"><a href="#视图的几何属性" class="headerlink" title="视图的几何属性"></a>视图的几何属性</h3><p>视图有 frame，center，bounds 等几个基本几何属性，其中:<br>frame 使用的最多，其坐标位置都是相对于父视图的，可以用于确定本视图在父视图中的位置和其自身的大小<br>center 的坐标位置也是相对于父视图的，通常用于移动，旋转等动画操作<br>bounds 是相对于自身的，通常情况下就是（0,0,width,height)， bounds 的含义可以认为是当前 view 被允许绘制的范围</p>
<h3 id="UIView的结构体"><a href="#UIView的结构体" class="headerlink" title="UIView的结构体"></a>UIView的结构体</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CGPoint</span></span><br><span class="line"><span class="keyword">struct</span> <span class="built_in">CGPoint</span> &#123;  </span><br><span class="line">  <span class="built_in">CGFloat</span> x;  </span><br><span class="line">  <span class="built_in">CGFloat</span> y;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">CGPoint</span> <span class="built_in">CGPoint</span>;  </span><br><span class="line"></span><br><span class="line"><span class="built_in">CGSize</span></span><br><span class="line"><span class="keyword">struct</span> <span class="built_in">CGSize</span> &#123;  </span><br><span class="line">  <span class="built_in">CGFloat</span> width;  </span><br><span class="line">  <span class="built_in">CGFloat</span> height;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">CGSize</span> <span class="built_in">CGSize</span>;  </span><br><span class="line"></span><br><span class="line"><span class="built_in">CGRect</span></span><br><span class="line"><span class="keyword">struct</span> <span class="built_in">CGRect</span> &#123;  </span><br><span class="line">  <span class="built_in">CGPoint</span> origin;  <span class="comment">//偏移是相对父视图的  </span></span><br><span class="line">  <span class="built_in">CGSize</span> size;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="built_in">CGRect</span> <span class="built_in">CGRect</span>;  </span><br><span class="line"><span class="built_in">UIView</span>* myView =[[ <span class="built_in">UIView</span> alloc]initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0.0</span>,<span class="number">0.0</span>,<span class="number">200.0</span>,<span class="number">400.0</span>)];</span><br></pre></td></tr></table></figure>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>可以以动画的形式改变视图的下面这些属性，只需要告诉系统动画开始和结束时的数值，系统会自动处理中间的过渡过程。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">frame</span><br><span class="line">bounds</span><br><span class="line">center</span><br><span class="line">transform</span><br><span class="line">alpha</span><br><span class="line">backgroundColor</span><br><span class="line">contentStretch</span><br></pre></td></tr></table></figure>
<h3 id="布局和子视图管理"><a href="#布局和子视图管理" class="headerlink" title="布局和子视图管理"></a>布局和子视图管理</h3><p>除了提供视图本身的内容之外，一个视图也可以表现得像一个容器。当一个视图包含其他视图时，两个视图之间就创建了一个父子关系。在这个关系中子视图被称为 subView ，父视图被称为 superView 。一个视图可以保护多个子视图，它们被存放在这个视图的 subviews 数组里。添加，删除，以及操作这些子视图的相对位置的函数如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">addSubview:</span><br><span class="line">insertSubview:...</span><br><span class="line">bringSubviewToFront:</span><br><span class="line">sendSubviewToBack:</span><br><span class="line">exchangeSubviewAtIndex:withSubviewAtIndex:</span><br><span class="line">removeFromSuperview（子视图调用）</span><br></pre></td></tr></table></figure>
<h3 id="UIView层的操作常用方法"><a href="#UIView层的操作常用方法" class="headerlink" title="UIView层的操作常用方法"></a>UIView层的操作常用方法</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">void</span>)removeFromSuperview; <span class="comment">// 从父视图中移除</span></span><br><span class="line">(<span class="keyword">void</span>)addSubview:(<span class="built_in">UIView</span> *)view; <span class="comment">// 添加一个子视图</span></span><br><span class="line">(<span class="keyword">void</span>)insertSubview:(<span class="built_in">UIView</span> *)view belowSubview:(<span class="built_in">UIView</span> *)slibingSubview; <span class="comment">// 插入一个view到某个view的下层</span></span><br><span class="line">(<span class="keyword">void</span>)insertSubview:(<span class="built_in">UIView</span> *)view aboveSubview:(<span class="built_in">UIView</span> *)slibingSubview; <span class="comment">// 插入一个view到某个view的上层</span></span><br><span class="line">(<span class="keyword">void</span>)insertSubview:(<span class="built_in">UIView</span> *)view atIndex:(<span class="built_in">NSInteger</span>)index; <span class="comment">// 插入一个view到特定层</span></span><br><span class="line">(<span class="keyword">void</span>)bringSubviewToFront:(<span class="built_in">UIView</span> *)view; <span class="comment">// 将某个view放在最上层</span></span><br><span class="line">(<span class="keyword">void</span>)sendSubviewToBack:(<span class="built_in">UIView</span> *)view; <span class="comment">// 将某个view放在最下层</span></span><br><span class="line">(<span class="built_in">BOOL</span>)isDescendantOfView(<span class="built_in">UIView</span> *)view; <span class="comment">// 是否是某个视图的子孙视图</span></span><br><span class="line">(<span class="keyword">void</span>)exchangeSubviewAtIndex:(<span class="built_in">NSInteger</span>)index1 withSubviewAtIndex:(<span class="built_in">NSInteger</span>)index2; <span class="comment">// 交换两个层的view</span></span><br><span class="line">(<span class="built_in">UIView</span> *)viewWithTag:(<span class="built_in">NSInteger</span>)view; <span class="comment">// 取到指定tag值的view</span></span><br></pre></td></tr></table></figure>
<h3 id="UIView的加载过程"><a href="#UIView的加载过程" class="headerlink" title="UIView的加载过程"></a>UIView的加载过程</h3><p><img src="http://ww2.sinaimg.cn/mw1024/bc254b75jw1f4usac93ohj20mi0vsac7.jpg" alt="view"><br>我们可以知道如果是从 Storyboard 或 Nib 文件中加载 View Controller，我们都不要去重载 loadView，它会自动加载 view 属性以及它的各个 Subviews。只有当我们自己代码创建 View Controller 的时候，我们可能需要去重载 loadView。当然，如果我们不重载，那么默认情况下 loadView 会创建一个光秃秃的 UIView 对象赋给 view 属性。<br>loadView:先寻找有关可用的nib文件的信息，根据这个信息来加载nib文件，如果没有有关nib文件的信息，默认实现会创建一个空白的UIView对象，然后让这个对象成为controller的主view<br>首先访问view属性<br>如果存在view，加载。若不存在，则UIViewController调用loadView方法<br>loadView方法执行如下操作<br>如果覆盖了该方法，必须创建view给UIViewController的view属性<br>如果没有复写该方法，UIViewController会默认调用initWithNibName:bundle:方法初始化并加载view<br>通过viewDidLoad方法来执行一些其他任务</p>
<h3 id="UIViewController生命周期"><a href="#UIViewController生命周期" class="headerlink" title="UIViewController生命周期"></a>UIViewController生命周期</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">void</span>)loadView</span><br><span class="line">(<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">(<span class="keyword">void</span>)viewWillAppear</span><br><span class="line">(<span class="keyword">void</span>)viewWillLayoutSubviews</span><br><span class="line">(<span class="keyword">void</span>)viewDidLayoutSubviews</span><br><span class="line">(<span class="keyword">void</span>)viewDidAppear</span><br><span class="line">(<span class="keyword">void</span>)viewWillDisappear</span><br><span class="line">(<span class="keyword">void</span>)viewDidDisappear</span><br><span class="line"></span><br><span class="line">假设现在有一个 <span class="built_in">AViewController</span>(简称 Avc) 和 BViewController (简称 Bvc)，通过 navigationController 的 push 实现 Avc 到 Bvc 的跳转，下面是各个方法的执行执行顺序：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> A viewDidLoad  </span><br><span class="line"><span class="number">2.</span> A viewWillAppear  </span><br><span class="line"><span class="number">3.</span> A viewDidAppear  </span><br><span class="line"><span class="number">4.</span> B viewDidLoad  </span><br><span class="line"><span class="number">5.</span> A viewWillDisappear  </span><br><span class="line"><span class="number">6.</span> B viewWillAppear  </span><br><span class="line"><span class="number">7.</span> A viewDidDisappear  </span><br><span class="line"><span class="number">8.</span> B viewDidAppear  </span><br><span class="line"></span><br><span class="line"><span class="number">9.</span> 如果再从 Bvc 跳回 Avc，会产生下面的执行顺序：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> B viewWillDisappear  </span><br><span class="line"><span class="number">2.</span> A viewWillAppear  </span><br><span class="line"><span class="number">3.</span> B viewDidDisappear  </span><br><span class="line"><span class="number">4.</span> A viewDidAppear  </span><br><span class="line"></span><br><span class="line">可见 viewDidLoad 只会调用一次，再第二次跳回 Avc 的时候，<span class="built_in">AViewController</span> 仍然存在于内存中，也就不需要 load 了。</span><br><span class="line"></span><br><span class="line">详细版本：</span><br><span class="line"><span class="number">1.</span> -[ViewController initWithCoder:]或-[ViewController initWithNibName:Bundle]:首先从归档文件中加载<span class="built_in">UIViewController</span>对象。即使是纯代码，也会把<span class="literal">nil</span>作为参数传给后者。</span><br><span class="line"><span class="number">2.</span> -[<span class="built_in">UIView</span> awakeFromNib]:作为第一个方法的助手，方便处理一些额外的设置。</span><br><span class="line"><span class="number">3.</span> -[ViewController loadView]:创建或加载一个view并把它赋值给<span class="built_in">UIViewController</span>的view属性</span><br><span class="line"><span class="number">4.</span> -[ViewController viewDidLoad]:此时整个视图层次(view hierarchy)已经被放到内存中，可以移除一些视图，修改约束，加载数据等</span><br><span class="line"><span class="number">5.</span> -[ViewController viewWillAppear:]:视图加载完成，并即将显示在屏幕上,还没有设置动画，可以改变当前屏幕方向或状态栏的风格等。</span><br><span class="line"><span class="number">6.</span> -[ViewController viewWillLayoutSubviews]：即将开始子视图位置布局</span><br><span class="line"><span class="number">7.</span> -[ViewController viewDidLayoutSubviews]：用于通知视图的位置布局已经完成</span><br><span class="line"><span class="number">8.</span> -[ViewController viewDidAppear:]：视图已经展示在屏幕上，可以对视图做一些关于展示效果方面的修改。</span><br><span class="line"><span class="number">9.</span> -[ViewController viewWillDisappear:]：视图即将消失</span><br><span class="line"><span class="number">10.</span> -[ViewController viewDidDisappear:]：视图已经消失</span><br><span class="line">如果考虑<span class="built_in">UIViewController</span>可能在某个时刻释放整个view。那么再次加载视图时显然会从步骤<span class="number">3</span>开始。因为此时的<span class="built_in">UIViewController</span>对象依然存在。</span><br></pre></td></tr></table></figure>
<h3 id="UIView、UIWindow、UIScreen、UIViewController-之间的层级关系"><a href="#UIView、UIWindow、UIScreen、UIViewController-之间的层级关系" class="headerlink" title="UIView、UIWindow、UIScreen、UIViewController 之间的层级关系"></a>UIView、UIWindow、UIScreen、UIViewController 之间的层级关系</h3><p><img src="http://ww1.sinaimg.cn/mw1024/bc254b75jw1f4usaaorkrj20y00i8gni.jpg" alt=""> </p>
<h3 id="UIView的bounds-frame和center属性"><a href="#UIView的bounds-frame和center属性" class="headerlink" title="UIView的bounds,frame和center属性"></a>UIView的bounds,frame和center属性</h3><p><img src="http://ww3.sinaimg.cn/mw1024/bc254b75jw1f4usab9jhfj20dk0abwf7.jpg" alt="bound"><br>看着上图，对照一下就很清楚了<br>View B’s bounds= ((0,0),(200,250))<br>View B’s frame= ((140,65),(320,320))<br>View B’s center= (300,225)</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">===获取指定的subView<span class="keyword">for</span>(<span class="built_in">UIView</span> *view <span class="keyword">in</span> subviews)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(view.tag == <span class="number">998</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//根据tag判断</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>([view isKindOfClass:[<span class="built_in">UIImageView</span> class]])</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//根据类型判断</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">===做一个与屏幕同等大小的<span class="built_in">UIView</span></span><br><span class="line"></span><br><span class="line">方法一：</span><br><span class="line"> <span class="meta">#pragma mark - Setup</span></span><br><span class="line">- (<span class="keyword">void</span>)setupUI &#123;</span><br><span class="line"><span class="comment">// Use full screen layout.</span></span><br><span class="line"><span class="keyword">self</span>.edgesForExtendedLayout = <span class="built_in">UIRectEdgeAll</span>;</span><br><span class="line"><span class="keyword">self</span>.automaticallyAdjustsScrollViewInsets = <span class="literal">YES</span>;</span><br><span class="line"><span class="keyword">self</span>.extendedLayoutIncludesOpaqueBars = <span class="literal">YES</span>;</span><br><span class="line"><span class="keyword">self</span>.view.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</span><br><span class="line"><span class="comment">// Title.</span></span><br><span class="line"><span class="keyword">self</span>.title = <span class="string">@"Detail"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line"><span class="built_in">CGRect</span> rect = [[<span class="built_in">UIScreen</span> mainScreen] bounds];</span><br><span class="line"><span class="built_in">CGSize</span> size = rect.size;</span><br><span class="line"><span class="built_in">CGFloat</span> width = size.width;</span><br><span class="line"><span class="built_in">CGFloat</span> height = size.height; </span><br><span class="line"><span class="built_in">CGRectMake</span>(origin.x，origin.y，size.width. Size.height)在代码中定义矩形</span><br><span class="line">Frame:     该view在父view坐标系统中的位置和大小。（参照点是，父亲的坐标系统）</span><br><span class="line">bounds：该view在本地坐标系统中的位置和大小。   （参照点是，本地坐标系统，就相当于ViewB自己的坐标系统，以<span class="number">0</span>,<span class="number">0</span>点为起点）</span><br><span class="line">center： 该view的中心点在父view坐标系统中的位置和大小。（参照点是，父亲的坐标系统）</span><br><span class="line">===<span class="built_in">UIView</span>添加<span class="built_in">UITableView</span>      TestTableViewController *viewController = [[TestTableViewController alloc] init];</span><br><span class="line">      [<span class="keyword">self</span> addChildViewController:viewController];</span><br><span class="line">      [<span class="keyword">self</span>.view addSubview:viewController.view];</span><br><span class="line">      [viewController didMoveToParentViewController:<span class="keyword">self</span>];</span><br><span class="line">      [如果不添加controller 则viewController 则不具备跳转等controller功能]</span><br><span class="line">      </span><br><span class="line">===设置uiView的位置</span><br><span class="line">aView.frame = <span class="built_in">CGRectMake</span>( <span class="number">100</span>, <span class="number">200</span>, aView.frame.size.width, aView.frame.size.height ); <span class="comment">// set new position exactly</span></span><br><span class="line"></span><br><span class="line">===remove view from superView</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">UIView</span>* subView <span class="keyword">in</span> [<span class="keyword">self</span>.view.subviews])&#123;    <span class="keyword">if</span> ([subView isKindOfClass:[ZeldaView class]])        [subView removeFromSuperview];&#125;</span><br><span class="line">===添加一条分割线</span><br><span class="line"><span class="built_in">UIView</span> *navDividingLine = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>,<span class="number">159</span>,<span class="keyword">self</span>.view.bounds.size.width,<span class="number">1</span>)];</span><br><span class="line">        navDividingLine.backgroundColor = [<span class="built_in">UIColor</span> groupTableViewBackgroundColor];  <span class="comment">//这个颜色就是默认表格线的颜色</span></span><br><span class="line">        [navDividingLine sizeToFit];</span><br><span class="line">        [<span class="keyword">self</span>.view addSubview:navDividingLine];</span><br></pre></td></tr></table></figure>
<h3 id="UIView设置圆角"><a href="#UIView设置圆角" class="headerlink" title="UIView设置圆角"></a>UIView设置圆角</h3><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、比较简单的情况，<span class="built_in">UIView</span>四个角都是圆角：</span><br><span class="line"><span class="built_in">UIView</span> *aView = [[<span class="built_in">UIView</span> alloc] init];aView.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, <span class="number">200</span>);aView.backgroundColor = [<span class="built_in">UIColor</span> redColor];<span class="comment">//设置圆角边框   </span>aView.layer.cornerRadius = <span class="number">8</span>; aView.layer.masksToBounds = <span class="literal">YES</span>;  <span class="comment">//设置边框及边框颜色  </span>aView.layer.borderWidth = <span class="number">8</span>;  aView.layer.borderColor =[ [<span class="built_in">UIColor</span> grayColor] <span class="built_in">CGColor</span>]; [<span class="keyword">self</span>.view addSubview:aView];</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="number">2</span>、设置四个角中的某个或者某几个为圆角</span><br><span class="line"><span class="built_in">UIView</span> *aView = [[<span class="built_in">UIView</span> alloc] init];aView.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, <span class="number">200</span>);aView.backgroundColor = [<span class="built_in">UIColor</span> redColor];[<span class="keyword">self</span>.view addSubview:aView];<span class="comment">//设置所需的圆角位置以及大小</span><span class="built_in">UIBezierPath</span> *maskPath = [<span class="built_in">UIBezierPath</span> bezierPathWithRoundedRect:aView.bounds byRoundingCorners:<span class="built_in">UIRectCornerBottomLeft</span> | <span class="built_in">UIRectCornerBottomRight</span> cornerRadii:<span class="built_in">CGSizeMake</span>(<span class="number">10</span>, <span class="number">10</span>)];    <span class="built_in">CAShapeLayer</span> *maskLayer = [[<span class="built_in">CAShapeLayer</span> alloc] init];    maskLayer.frame = aView.bounds;    maskLayer.path = maskPath.CGPath;    aView.layer.mask = maskLayer;</span><br><span class="line"></span><br><span class="line">其中，<span class="built_in">UIRectCornerBottomLeft</span>，<span class="built_in">UIRectCornerBottomRight</span>是可以选择的角。</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, <span class="built_in">UIRectCorner</span>) &#123;    <span class="built_in">UIRectCornerTopLeft</span>     = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,    <span class="built_in">UIRectCornerTopRight</span>    = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,    <span class="built_in">UIRectCornerBottomLeft</span>  = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,    <span class="built_in">UIRectCornerBottomRight</span> = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,    <span class="built_in">UIRectCornerAllCorners</span>  = ~<span class="number">0</span>UL&#125;;</span><br><span class="line">上面的枚举是可以供选择的角，分别是：“左上角”、“右上角”、“左下角”、“右下角”。</span><br></pre></td></tr></table></figure>
	  

	  <div>
  		<center>
		  <div class="pagination">
<ul class="pagination">
	
	
	
	
	
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
			
		
	
		
	
		
	
		
	
		
			
			
			
		
	
		
	
		
			
		
	
		
	
		
	
	
	
		<li class="prev"><a href="/2016/07/04/iOS/布局相关/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>prev</a></li>
	
	<li><a href="/"><i class="fa fa-archive"></i>Home</a></li>
	
		<li class="next"><a href="/2016/05/31/iOS/UITableView的使用/" class="alignright next">next<i class="fa fa-arrow-circle-o-right"></i></a></li>
	
</ul>
</div>

		</center>
	  </div>
	  
	</div> <!-- col-md-9/col-md-12 -->
	
  </div><!-- row -->

	</div>
  </div>
  <div class="container-narrow">
	<footer> <p>
  &copy; 2016 John Doe
  
      with help from <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-wixo/">Wixo</a>.    
</p> </footer>
  </div> <!-- container-narrow -->
  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/jquery.tableofcontents.min.js"></script>
<script src="/js/tocgenerator.min.js"></script>
<script src="/js/main.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


</body>
</html>
