<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Objc面试题收录 | spike 代码之美</title>
  <meta name="author" content="John Doe">
  
  <meta name="description" content="持续收录一些较经典的面试题">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Objc面试题收录"/>
  <meta property="og:site_name" content="spike 代码之美"/>

  
    <meta property="og:image" content="undefined"/>
  

  
    <link rel="alternative" href="/atom.xml" title="spike 代码之美" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">  
  <link rel="stylesheet" href="/css/sidenav.css" media="screen" type="text/css">  
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  

</head>

<body id="body" data-spy="scroll" data-target=".toc">
  <div class="container" id="container">
	<div class="content">
	  <div class="page-header">		
  <h1><a class="brand" href="/">spike 代码之美</a><span class="split"></span><span class="title">Objc面试题收录</span><span class="date" id="title-date"><i class="fa fa-clock-o"></i> 2016-06-24</span></h1>
</div>		

<div class="row page">
  <!-- cols -->	
  
  

  
	<div class="col-md-12">
	  

	  <!-- content -->
	  <blockquote>
<p>持续收录一些较经典的面试题</p>
</blockquote>
<a id="more"></a>
<h3 id="简单描述一下XIB与Storyboards，说一下他们的优缺点"><a href="#简单描述一下XIB与Storyboards，说一下他们的优缺点" class="headerlink" title="简单描述一下XIB与Storyboards，说一下他们的优缺点"></a>简单描述一下XIB与Storyboards，说一下他们的优缺点</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">优点：</span><br><span class="line">XIB：在编译前就提供了可视化界面，可以直接拖控件，也可以直接给控件添加约束，更直观一些，而且类文件中就少了创建控件的代码，确实简化不少，通常每个XIB对应一个类。</span><br><span class="line">Storyboard：在编译前提供了可视化界面，可拖控件，可加约束，在开发时比较直观，而且一个storyboard可以有很多的界面，每个界面对应一个类文件，通过storybard，可以直观地看出整个App的结构(事实上故事板是多个xib文件集合的描述文件，也采用xml格式).</span><br><span class="line">缺点：</span><br><span class="line">XIB：需求变动时，需要修改XIB很大，有时候甚至需要重新添加约束，导致开发周期变长。XIB载入相比纯代码自然要慢一些。对于比较复杂逻辑控制不同状态下显示不同内容时，使用XIB是比较困难的。当多人团队或者多团队开发时，如果XIB文件被发动，极易导致冲突，而且解决冲突相对要困难很多。</span><br><span class="line">Storyboard：需求变动时，需要修改storyboard上对应的界面的约束，与XIB一样可能要重新添加约束，或者添加约束会造成大量的冲突，尤其是多团队开发。对于复杂逻辑控制不同显示内容时，比较困难。当多人团队或者多团队开发时，大家会同时修改一个storyboard，导致大量冲突，解决起来相当困难。</span><br></pre></td></tr></table></figure>
<h3 id="下面四个修饰指针有什么区别"><a href="#下面四个修饰指针有什么区别" class="headerlink" title="下面四个修饰指针有什么区别?"></a>下面四个修饰指针有什么区别?</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const char *p;</span><br><span class="line">char const *p;  </span><br><span class="line">char * const p;  </span><br><span class="line">const char * const p;</span><br><span class="line"> </span><br><span class="line">参考答案：</span><br><span class="line">• const char *p定义了一个指向不可变的字符串的字符指针，可以这么看：const char *为类型，p是变量。</span><br><span class="line">• char const *p与上一个是一样的。</span><br><span class="line">• char * const p定义了一个指向字符串的指针，该指针值不可改变，即不可改变指向。这么看：char *是类型，const是修饰变量p，也就是说p是一个常量</span><br><span class="line">const char * const p定义了一个指向不可变的字符串的字符指针，且该指针也不可改变指向。这一个就很容易看出来了。两个const分别修饰，因此都是不可变的。</span><br></pre></td></tr></table></figure>
<h3 id="请把字符串2015-04-10格式化日期转为NSDate类型"><a href="#请把字符串2015-04-10格式化日期转为NSDate类型" class="headerlink" title="请把字符串2015-04-10格式化日期转为NSDate类型"></a>请把字符串2015-04-10格式化日期转为NSDate类型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSString *timeStr = @&quot;2015-04-10&quot;;</span><br><span class="line">NSDateFormatter *formatter = [[NSDateFormatter alloc] init];</span><br><span class="line">formatter.dateFormat = @&quot;yyyy-MM-dd&quot;;</span><br><span class="line">formatter.timeZone = [NSTimeZone defaultTimeZone];</span><br><span class="line">NSDate *date = [formatter dateFromString:timeStr];</span><br><span class="line">// 2015-04-09 16:00:00 +0000</span><br><span class="line">NSLog(@&quot;%@&quot;, date);</span><br></pre></td></tr></table></figure>
<h3 id="描述一下iOS的内存管理，在开发中对于内存的使用和优化包含哪些方面。我们在开发中应该注意哪些问题。"><a href="#描述一下iOS的内存管理，在开发中对于内存的使用和优化包含哪些方面。我们在开发中应该注意哪些问题。" class="headerlink" title="描述一下iOS的内存管理，在开发中对于内存的使用和优化包含哪些方面。我们在开发中应该注意哪些问题。"></a>描述一下iOS的内存管理，在开发中对于内存的使用和优化包含哪些方面。我们在开发中应该注意哪些问题。</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">内存管理准则：谁强引用过，谁就在不再使用时使引用计数减一。</span><br><span class="line">对于内存的使用和优化常见的有以下方面：</span><br><span class="line">重用问题：如UITableViewCells、UICollectionViewCells、UITableViewHeaderFooterViews设置正确的reuseIdentifier，充分重用。</span><br><span class="line">尽量把views设置为不透明：当opque为NO的时候，图层的半透明取决于图片和其本身合成的图层为结果，可提高性能。</span><br><span class="line">不要使用太复杂的XIB/Storyboard：载入时就会将XIB/storyboard需要的所有资源，包括图片全部载入内存，即使未来很久才会使用。那些相比纯代码写的延迟加载，性能及内存就差了很多。</span><br><span class="line">选择正确的数据结构：学会选择对业务场景最合适的数组结构是写出高效代码的基础。比如，数组: 有序的一组值。使用索引来查询很快，使用值查询很慢，插入/删除很慢。字典: 存储键值对，用键来查找比较快。集合: 无序的一组值，用值来查找很快，插入/删除很快。</span><br><span class="line">gzip/zip压缩：当从服务端下载相关附件时，可以通过gzip/zip压缩后再下载，使得内存更小，下载速度也更快。</span><br><span class="line">延迟加载：对于不应该使用的数据，使用延迟加载方式。对于不需要马上显示的视图，使用延迟加载方式。比如，网络请求失败时显示的提示界面，可能一直都不会使用到，因此应该使用延迟加载。</span><br><span class="line">数据缓存：对于cell的行高要缓存起来，使得reload数据时，效率也极高。而对于那些网络数据，不需要每次都请求的，应该缓存起来，可以写入数据库，也可以通过plist文件存储。</span><br><span class="line">处理内存警告：一般在基类统一处理内存警告，将相关不用资源立即释放掉</span><br><span class="line">重用大开销对象：一些objects的初始化很慢，比如NSDateFormatter和NSCalendar，但又不可避免地需要使用它们。通常是作为属性存储起来，防止反复创建。</span><br><span class="line">避免反复处理数据：许多应用需要从服务器加载功能所需的常为JSON或者XML格式的数据。在服务器端和客户端使用相同的数据结构很重要。</span><br><span class="line">使用Autorelease Pool：在某些循环创建临时变量处理数据时，自动释放池以保证能及时释放内存。</span><br></pre></td></tr></table></figure>
<h3 id="深复制和浅复制的区别："><a href="#深复制和浅复制的区别：" class="headerlink" title="深复制和浅复制的区别："></a>深复制和浅复制的区别：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">浅复制只复制指向对象的指针，而不复制引用对象的本身。深层复制复制对象的本身。</span><br><span class="line">意思就是说我有个A对象，复制一份后得到A_copy对象，对于浅复制来说，A和A_copy指向的是同一个内存资源，复制的只不过是一个指针，对象本身的资源还是只有一份，当对A_copy执行修改操作时，我们发现A引用的对象同样被修改，深复制对象中存在了两份独立的对象本身，浅复制好比你和你的影子，你完蛋，影子也完蛋，深复制好比克隆人，你完蛋，克隆人还活着。</span><br><span class="line"></span><br><span class="line">===什么情况使用 weak 关键字，相比 assign 有什么不同？</span><br><span class="line">什么情况使用 weak 关键字？</span><br><span class="line">在 ARC 中,在有可能出现循环引用的时候,往往要通过让其中一端使用 weak 来解决,比如: delegate 代理属性。</span><br><span class="line">自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用 weak,自定义 IBOutlet 控件属性一般也使用 weak；当然，也可以使用strong。在下文也有论述：《IBOutlet连出来的视图属性为什么可以被设置成weak?》</span><br><span class="line">不同点：</span><br><span class="line">weak 此特质表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)。 而assign 的“设置方法”只会执行针对“纯量类型” (scalar type，例如 CGFloat 或 NSlnteger 等)的简单赋值操作。</span><br><span class="line">assigin 可以用非 OC 对象,而 weak 必须用于 OC 对象</span><br></pre></td></tr></table></figure>
<h3 id="怎么用-copy-关键字？"><a href="#怎么用-copy-关键字？" class="headerlink" title="怎么用 copy 关键字？"></a>怎么用 copy 关键字？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用途：</span><br><span class="line">NSString、NSArray、NSDictionary 等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary；</span><br><span class="line">block 也经常使用 copy 关键字</span><br></pre></td></tr></table></figure>
<h3 id="property-的本质是什么？"><a href="#property-的本质是什么？" class="headerlink" title="@property 的本质是什么？"></a>@property 的本质是什么？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@property = ivar + getter + setter;</span><br><span class="line">下面解释下：</span><br><span class="line">“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。</span><br><span class="line">“属性” (property)作为 Objective-C 的一项特性，主要的作用就在于封装对象中的数据。 Objective-C 对象通常会把其所需要的数据保存为各种实例变量。实例变量一般通过“存取方法”(access method)来访问。其中，“获取方法” (getter)用于读取变量值，而“设置方法” (setter)用于写入变量值。这个概念已经定型，并且经由“属性”这一特性而成为 Objective-C 2.0 的一部分。 而在正规的 Objective-C 编码风格中，存取方法有着严格的命名规范。 正因为有了这种严格的命名规范，所以 Objective-C 这门语言才能根据名称自动创建出存取方法。其实也可以把属性当做一种关键字，其表示:</span><br><span class="line">编译器会自动写出一套存取方法，用以访问给定类型中具有给定名称的变量。 所以你也可以这么说：</span><br><span class="line">@property = getter + setter;</span><br><span class="line">例如下面这个类：</span><br><span class="line">@interface Person : NSObject@property NSString *firstName;@property NSString *lastName;@end</span><br><span class="line">上述代码写出来的类与下面这种写法等效：</span><br><span class="line">@interface Person : NSObject- (NSString *)firstName;- (void)setFirstName:(NSString *)firstName;- (NSString *)lastName;- (void)setLastName:(NSString *)lastName;@end</span><br></pre></td></tr></table></figure>
<h3 id="ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？"><a href="#ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？" class="headerlink" title="ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？"></a>ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对应基本数据类型默认关键字是atomic,readwrite,assign</span><br><span class="line">对于普通的 Objective-C 对象atomic,readwrite,strong</span><br></pre></td></tr></table></figure>
<h3 id="一个objc对象的isa的指针指向什么？有什么作用？"><a href="#一个objc对象的isa的指针指向什么？有什么作用？" class="headerlink" title="一个objc对象的isa的指针指向什么？有什么作用？"></a>一个objc对象的isa的指针指向什么？有什么作用？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">指向他的类对象,从而可以找到对象上的方法</span><br></pre></td></tr></table></figure>
<h3 id="objc中的类方法和实例方法有什么本质区别和联系？"><a href="#objc中的类方法和实例方法有什么本质区别和联系？" class="headerlink" title="objc中的类方法和实例方法有什么本质区别和联系？"></a>objc中的类方法和实例方法有什么本质区别和联系？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类方法：</span><br><span class="line">	类方法是属于类对象的</span><br><span class="line">	类方法只能通过类对象调用</span><br><span class="line">	类方法中的self是类对象</span><br><span class="line">	类方法可以调用其他的类方法</span><br><span class="line">	类方法中不能访问成员变量</span><br><span class="line">	类方法中不定直接调用对象方法</span><br><span class="line">实例方法：</span><br><span class="line">	实例方法是属于实例对象的</span><br><span class="line">	实例方法只能通过实例对象调用</span><br><span class="line">	实例方法中的self是实例对象</span><br><span class="line">	实例方法中可以访问成员变量</span><br><span class="line">	实例方法中直接调用实例方法</span><br><span class="line">	实例方法中也可以调用类方法(通过类名)</span><br></pre></td></tr></table></figure>
<h3 id="iOS-的沙盒目录结构是怎样的？-App-Bundle-里面都有什么？"><a href="#iOS-的沙盒目录结构是怎样的？-App-Bundle-里面都有什么？" class="headerlink" title="iOS 的沙盒目录结构是怎样的？ App Bundle 里面都有什么？"></a>iOS 的沙盒目录结构是怎样的？ App Bundle 里面都有什么？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.沙盒结构</span><br><span class="line">Application：存放程序源文件，上架前经过数字签名，上架后不可修改</span><br><span class="line">Documents：常用目录，iCloud备份目录，存放数据,这里不能存缓存文件,否则上架不被通过</span><br><span class="line">Library</span><br><span class="line">Caches：存放体积大又不需要备份的数据,SDWebImage缓存路径就是这个</span><br><span class="line">Preference：设置目录，iCloud会备份设置信息</span><br><span class="line">tmp：存放临时文件，不会被备份，而且这个文件下的数据有可能随时被清除的可能</span><br><span class="line">2.App Bundle 里面有什么</span><br><span class="line">Info.plist:此文件包含了应用程序的配置信息.系统依赖此文件以获取应用程序的相关信息</span><br><span class="line">可执行文件:此文件包含应用程序的入口和通过静态连接到应用程序target的代码</span><br><span class="line">资源文件:图片,声音文件一类的</span><br><span class="line">其他:可以嵌入定制的数据资源</span><br></pre></td></tr></table></figure>
<h3 id="Objective-C-如何对已有的方法，添加自己的功能代码以实现类似记录日志这样的功能？"><a href="#Objective-C-如何对已有的方法，添加自己的功能代码以实现类似记录日志这样的功能？" class="headerlink" title="Objective-C 如何对已有的方法，添加自己的功能代码以实现类似记录日志这样的功能？"></a>Objective-C 如何对已有的方法，添加自己的功能代码以实现类似记录日志这样的功能？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	这题目主要考察的是runtime如何交换方法</span><br><span class="line">	先在分类中添加一个方法,注意不能重写系统方法,会覆盖</span><br><span class="line">	+ (NSString *)myLog&#123;    // 这里写打印行号,什么方法,哪个类调用等等&#125;</span><br><span class="line">	然后交换方法</span><br><span class="line">	// 加载分类到内存的时候调用+ (void)load&#123;    // 获取imageWithName方法地址    Method description = class_getClassMethod(self, @selector(description));</span><br><span class="line">	// 获取imageWithName方法地址    Method myLog = class_getClassMethod(self, @selector(myLog));</span><br><span class="line">	// 交换方法地址，相当于交换实现方式    method_exchangeImplementations(description, myLog);&#125;</span><br></pre></td></tr></table></figure>
<h3 id="strong-weak-unsafe-unretained-的区别？"><a href="#strong-weak-unsafe-unretained-的区别？" class="headerlink" title="strong / weak / unsafe_unretained 的区别？"></a>strong / weak / unsafe_unretained 的区别？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">weak只能修饰OC对象,使用weak不会使计数器加1,对象销毁时修饰的对象会指向nil</span><br><span class="line">strong等价与retain,能使计数器加1,且不能用来修饰数据类型</span><br><span class="line">unsafe_unretained等价与assign,可以用来修饰数据类型和OC对象,但是不会使计数器加1,且对象销毁时也不会将对象指向nil,容易造成野指针错误</span><br></pre></td></tr></table></figure>
<h3 id="如何为-Class-定义一个对外只读对内可读写的属性"><a href="#如何为-Class-定义一个对外只读对内可读写的属性" class="headerlink" title="如何为 Class 定义一个对外只读对内可读写的属性?"></a>如何为 Class 定义一个对外只读对内可读写的属性?</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在头文件中将属性定义为readonly,在.m文件中将属性重新定义为readwrite</span><br></pre></td></tr></table></figure>
<h3 id="frame-和-bounds-的区别是什么？"><a href="#frame-和-bounds-的区别是什么？" class="headerlink" title="frame 和 bounds 的区别是什么？"></a>frame 和 bounds 的区别是什么？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frame相对于父视图,是父视图坐标系下的位置和大小。bounds相对于自身,是自身坐标系下的位置和大小。</span><br><span class="line">frame以父控件的左上角为坐标原点，bounds以自身的左上角为坐标原点</span><br></pre></td></tr></table></figure>
<h3 id="Instancetype"><a href="#Instancetype" class="headerlink" title="Instancetype:"></a>Instancetype:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface NSArray  </span><br><span class="line">+ (id)constructAnArray;  </span><br><span class="line">@end  </span><br><span class="line">当我们使用如下方式初始化NSArray时：</span><br><span class="line">[NSArray constructAnArray];  </span><br><span class="line">根据Cocoa的方法命名规范，得到的返回类型就和方法声明的返回类型一样，是id</span><br><span class="line"></span><br><span class="line">@interface NSArray  </span><br><span class="line">+ (instancetype)constructAnArray;  </span><br><span class="line">@end  </span><br><span class="line">当使用相同方式初始化NSArray时：</span><br><span class="line">1. [NSArray constructAnArray];  </span><br><span class="line">得到的返回类型和方法所在类的类型相同，是NSArray*</span><br><span class="line">instancetype的作用，就是使那些非关联返回类型的方法返回所在类的类型！</span><br><span class="line">①instancetype可以返回和方法所在类相同类型的对象，id只能返回未知类型的对象；</span><br><span class="line">②instancetype只能作为返回值，不能像id那样作为参数，比如下面的写法</span><br></pre></td></tr></table></figure>
<h3 id="请简单描述一下队列和多线程的使用原理"><a href="#请简单描述一下队列和多线程的使用原理" class="headerlink" title="请简单描述一下队列和多线程的使用原理"></a>请简单描述一下队列和多线程的使用原理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在iOS中队列分为以下几种：</span><br><span class="line">• 串行队列：队列中的任务只会顺序执行</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">dispatch_queue_t q = dispatch_queue_create(&quot;...&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"> </span><br><span class="line">• 并行队列： 队列中的任务通常会并发执行</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">dispatch_queue_t q = dispatch_queue_create(&quot;......&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"> </span><br><span class="line">• 全局队列：是系统的，直接拿过来（GET）用就可以；与并行队列类似</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">dispatch_queue_t q = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line"> </span><br><span class="line">• 主队列：每一个应用程序对应唯一一个主队列，直接GET即可；在多线程开发中，使用主队列更新UI</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">dispatch_queue_t q = dispatch_get_main_queue();</span><br><span class="line"> </span><br><span class="line">上面这四种是针对GCD来讲的，串行队列中的任务只能一个个地执行，在前一个没有执行完毕之前，下一个只能等待。并行队列可以并发地执行任务，因此多个任务之间执行的顺序不能确定，当添加一个新的任务时，交由GCD来判断是否要创建新的新的线程。</span><br></pre></td></tr></table></figure>
<h3 id="static的作用"><a href="#static的作用" class="headerlink" title="static的作用"></a>static的作用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这个关键在实际开发中挺常用的。当我们使用实例成员变量不好处理时，我们将声明为静态变量，因此它有以下特性。</span><br><span class="line">参考答案：</span><br><span class="line">• 函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值</span><br><span class="line">• 在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问</span><br><span class="line">• 在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内</span><br><span class="line">• 在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝</span><br><span class="line">在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。</span><br></pre></td></tr></table></figure>
<h3 id="self-super"><a href="#self-super" class="headerlink" title="self super"></a>self super</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">下面的代码输出什么？ </span><br><span class="line">@implementation Son : Father</span><br><span class="line"> </span><br><span class="line">- (id)init &#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));</span><br><span class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@end</span><br><span class="line"> </span><br><span class="line">// 输出</span><br><span class="line">NSStringFromClass([self class]) = Son</span><br><span class="line">NSStringFromClass([super class]) = Son</span><br><span class="line"> </span><br><span class="line">这个题目主要是考察关于Objective-C中对self和super的理解。我们都知道：self是类的隐藏参数，指向当前调用方法的这个类的实例。那super呢？</span><br><span class="line">很多人会想当然的认为“super和self类似，应该是指向父类的指针吧！”。这是很普遍的一个误区。其实 super是一个 Magic Keyword，它本质是一个编译器标示符，和self 是指向的同一个消息接受者！他们两个的不同点在于：super会告诉编译器，调用class 这个方法时，要去父类的方法，而不是本类里的。</span><br><span class="line">上面的例子不管调用[self class]还是[super class]，接受消息的对象都是当前 Son ＊xxx 这个对象。</span><br><span class="line">当使用self调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用super时，则从父类的方法列表中开始找。然后调用父类的这个方法。</span><br><span class="line">通过self来调用方法时，会转换成：</span><br><span class="line"> </span><br><span class="line">id objc_msgSend(id self, SEL op, ...)</span><br><span class="line"> </span><br><span class="line">而通过super调用方法时，会转换成：</span><br><span class="line"> </span><br><span class="line">id objc_msgSendSuper(struct objc_super *super, SEL op, ...)</span><br><span class="line"> </span><br><span class="line">而第一个参数是 objc_super 这样一个结构体，其定义如下:</span><br><span class="line"> </span><br><span class="line">struct objc_super &#123;</span><br><span class="line">       __unsafe_unretained id receiver;</span><br><span class="line">       __unsafe_unretained Class super_class;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="什么是单例，如何设计单例？"><a href="#什么是单例，如何设计单例？" class="headerlink" title="什么是单例，如何设计单例？"></a>什么是单例，如何设计单例？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">参考答案：</span><br><span class="line">单例就是全局都只有一个对象存在，而且是在整个App运行过程中都存在。每个App都会有单例，比如UIApplication。而我们在做用户数据存储时，通常都会用单例存储，因为应用在所有操作中，经常要求先登录。</span><br><span class="line">下面这种写法是最常用的写法，这个是线程安全的。 </span><br><span class="line">+ (instancetype)shared &#123;</span><br><span class="line">  static HYBUserManager *sg_userManager = nil;</span><br><span class="line">  static dispatch_once_t onceToken;</span><br><span class="line">  dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">    if (sg_userManager == nil) &#123;</span><br><span class="line">      sg_userManager = [[HYBUserManager alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  return sg_userManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="怎么用copy关键字？"><a href="#怎么用copy关键字？" class="headerlink" title="怎么用copy关键字？"></a>怎么用copy关键字？</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">分析：</span><br><span class="line">copy关键字只能应用于对象，不能用于基本类型。copy属性会复制一份，并且强引用之，但是对于集合类型，通常并不能达到深拷贝的目的。NSString、NSArray、NSDictionary等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，当然很多时候都使用了strong来声明。block也使用copy关键字来声明。</span><br><span class="line">参考答案：</span><br><span class="line">• copy关键字只能应用于对象，不能用于基本类型</span><br><span class="line">• 对于字符串，理应始终使用copy，虽然使用strong一般情况下也没有关系</span><br><span class="line">• 对于不可变集合类型，有可变和不可变类型，若要防止外部的修改影响所传过来的值，应该使用copy来声明，虽然大多情况下使用strong一定问题都没有。不过，实际开发中，我见到的几乎都是使用strong来声明的，包括笔者在内。</span><br><span class="line">• 对于可变集合类型，都应该使用strong来声明，不能使用copy，因为copy会生成一个不可变的类型，而不是可变的。</span><br><span class="line">对于block，都应该使用copy来声明，原因是block来捕获上下文的信息。</span><br></pre></td></tr></table></figure>
<h3 id="对数组中的元素去重复"><a href="#对数组中的元素去重复" class="headerlink" title="对数组中的元素去重复"></a>对数组中的元素去重复</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSArray *array = @[@&quot;12-11&quot;, @&quot;12-11&quot;, @&quot;12-11&quot;, @&quot;12-12&quot;, @&quot;12-13&quot;, @&quot;12-14&quot;];//推荐的写法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">有如下几种方案：</span><br><span class="line">• 第一种方法：开辟新的内存空间，然后判断是否存在，若不存在则添加到数组中，得到最终结果的顺序不发生变化。效率分析：时间复杂度为O ( n2 )：</span><br><span class="line"> </span><br><span class="line">NSMutableArray *resultArray = [[NSMutableArray alloc] initWithCapacity:array.count];</span><br><span class="line">// 外层一个循环</span><br><span class="line">for (NSString *item in array) &#123;</span><br><span class="line">   // 调用-containsObject:本质也是要循环去判断，因此本质上是双层遍历</span><br><span class="line">   // 时间复杂度为O ( n^2 )而不是O (n)</span><br><span class="line">    if (![resultArray containsObject:item]) &#123;</span><br><span class="line">      [resultArray addObject:item];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;resultArray: %@&quot;, resultArray);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">原来集合操作可以通过valueForKeyPath来实现的，去重可以一行代码实现： </span><br><span class="line">array = [array valueForKeyPath:@&quot;@distinctUnionOfObjects.self&quot;];</span><br><span class="line">NSLog(@&quot;%@&quot;, array);</span><br><span class="line"> </span><br><span class="line">但是返回的结果是无序的，与原来的顺序不同。</span><br><span class="line"></span><br><span class="line">• 第二种方法：利用NSDictionary去重，字典在设置key-value时，若已存在则更新值，若不存在则插入值，然后获取allValues。若不要求有序，则可以采用此种方法。若要求有序，还得进行排序。效率分析：只需要一个循环就可以完成放入字典，若不要求有序，时间复杂度为O(n)。若要求排序，则效率与排序算法有关：</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">NSMutableDictionary *resultDict = [[NSMutableDictionary alloc] initWithCapacity:array.count];</span><br><span class="line">for (NSString *item in array) &#123;</span><br><span class="line">    [resultDict setObject:item forKey:item];</span><br><span class="line">&#125;</span><br><span class="line">NSArray *resultArray = resultDict.allValues;</span><br><span class="line">NSLog(@&quot;%@&quot;, resultArray);</span><br><span class="line"> </span><br><span class="line">如果需要按照原来的升序排序，可以这样：</span><br><span class="line">resultArray = [resultArray sortedArrayUsingComparator:^NSComparisonResult(id  _Nonnull obj1, id  _Nonnull obj2) &#123;</span><br><span class="line">  NSString *item1 = obj1;</span><br><span class="line">  NSString *item2 = obj2;</span><br><span class="line">  return [item1 compare:item2 options:NSLiteralSearch];</span><br><span class="line">&#125;];</span><br><span class="line">NSLog(@&quot;%@&quot;, resultArray);</span><br><span class="line"></span><br><span class="line">• 第三种方法：利用集合NSSet的特性(确定性、无序性、互异性)，放入集合就自动去重了。但是它与字典拥有同样的无序性，所得结果顺序不再与原来一样。如果不要求有序，使用此方法与字典的效率应该是差不多的。效率分析：时间复杂度为O (n)：</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">NSSet *set = [NSSet setWithArray:array];</span><br><span class="line">NSArray *resultArray = [set allObjects];</span><br><span class="line">NSLog(@&quot;%@&quot;, resultArray);</span><br><span class="line"> </span><br><span class="line">如果要求有序，那就得排序，比如这里要升序排序：</span><br><span class="line"> </span><br><span class="line">resultArray = [resultArray sortedArrayUsingComparator:^NSComparisonResult(id  _Nonnull obj1, id  _Nonnull obj2) &#123;</span><br><span class="line">  NSString *item1 = obj1;</span><br><span class="line">  NSString *item2 = obj2;</span><br><span class="line">  return [item1 compare:item2 options:NSLiteralSearch];</span><br><span class="line">&#125;];</span><br><span class="line">NSLog(@&quot;%@&quot;, resultArray);</span><br><span class="line"> </span><br><span class="line">补充：</span><br><span class="line">一直没有使用过有序集合，网友们反馈到可以直接使用有序集合，感谢大家：</span><br><span class="line">NSOrderedSet *set = [NSOrderedSet orderedSetWithArray:array];</span><br><span class="line">NSLog(@&quot;%@&quot;, set.array);</span><br></pre></td></tr></table></figure>
<h3 id="请写出有多少有方法给UIImageView添加圆角"><a href="#请写出有多少有方法给UIImageView添加圆角" class="headerlink" title="请写出有多少有方法给UIImageView添加圆角?"></a>请写出有多少有方法给UIImageView添加圆角?</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、最直接的方法就是使用如下属性设置：</span><br><span class="line">imgView.layer.cornerRadius = 10;// 这一行代码是很消耗性能的imgView.clipsToBounds = YES;</span><br><span class="line">好处是使用简单，操作方便。坏处是离屏渲染（off-screen-rendering）需要消耗性能。对于图片比较多的视图上，不建议使用这种方法来设置圆角。通常来说，计算机系统中CPU、GPU、显示器是协同工作的。CPU计算好显示内容提交到GPU，GPU渲染完成后将渲染结果放入帧缓冲区。</span><br><span class="line">简单来说，离屏渲染，导致本该GPU干的活，结果交给了CPU来干，而CPU又不擅长GPU干的活，于是拖慢了UI层的FPS（数据帧率），并且离屏需要创建新的缓冲区和上下文切换，因此消耗较大的性能。</span><br><span class="line"></span><br><span class="line">2. 给UIImage添加生成圆角图片的扩展API：</span><br><span class="line">- (UIImage *)hyb_imageWithCornerRadius:(CGFloat)radius &#123;  CGRect rect = (CGRect)&#123;0.f, 0.f, self.size&#125;;</span><br><span class="line">UIGraphicsBeginImageContextWithOptions(self.size, NO, UIScreen.mainScreen.scale);  CGContextAddPath(UIGraphicsGetCurrentContext(),                   [UIBezierPath bezierPathWithRoundedRect:rect cornerRadius:radius].CGPath);  CGContextClip(UIGraphicsGetCurrentContext());</span><br><span class="line">[self drawInRect:rect];  UIImage *image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">UIGraphicsEndImageContext();</span><br><span class="line">return image;&#125;</span><br><span class="line">然后调用时就直接传一个圆角来处理：</span><br><span class="line">imgView.image = [[UIImage imageNamed:@&quot;test&quot;] hyb_imageWithCornerRadius:4];</span><br></pre></td></tr></table></figure>
	  

	  <div>
  		<center>
		  <div class="pagination">
<ul class="pagination">
	
	
	
	
	
	
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
			
		
	
		
	
		
	
		
	
		
			
			
			
		
			
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
	
	
	
		<li class="prev"><a href="/2016/08/06/property/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>prev</a></li>
	
	<li><a href="/"><i class="fa fa-archive"></i>Home</a></li>
	
		<li class="next"><a href="/2016/06/15/Objc概念知识点学习笔记/" class="alignright next">next<i class="fa fa-arrow-circle-o-right"></i></a></li>
	
</ul>
</div>

		</center>
	  </div>
	  
	</div> <!-- col-md-9/col-md-12 -->
	
  </div><!-- row -->

	</div>
  </div>
  <div class="container-narrow">
	<footer> <p>
  &copy; 2016 John Doe
  
      with help from <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-wixo/">Wixo</a>.    
</p> </footer>
  </div> <!-- container-narrow -->
  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/jquery.tableofcontents.min.js"></script>
<script src="/js/tocgenerator.min.js"></script>
<script src="/js/main.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


</body>
</html>
