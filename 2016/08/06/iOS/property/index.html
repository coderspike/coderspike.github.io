<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>@property | spike 代码之美</title>
  <meta name="author" content="John Doe">
  
  <meta name="description" content="&amp;gt;@Property是声明属性的语法，它可以快速方便的为实例变量创建存取器，并允许我们通过点语法使用存取器。存取器（accessor）：指用于获取和设置实例变量的方法。用于获取实例变量值的存取器是getter，用于设置实例变量值的存取器是setter。
修饰词assign、weak、stron">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="@property"/>
  <meta property="og:site_name" content="spike 代码之美"/>

  
    <meta property="og:image" content="undefined"/>
  

  
    <link rel="alternative" href="/atom.xml" title="spike 代码之美" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">  
  <link rel="stylesheet" href="/css/sidenav.css" media="screen" type="text/css">  
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  

</head>

<body id="body" data-spy="scroll" data-target=".toc">
  <div class="container" id="container">
	<div class="content">
	  <div class="page-header">		
  <h1><a class="brand" href="/">spike 代码之美</a><span class="split"></span><span class="title">@property</span><span class="date" id="title-date"><i class="fa fa-clock-o"></i> 2016-08-06</span></h1>
</div>		

<div class="row page">
  <!-- cols -->	
  
  

  
	<div class="col-md-12">
	  

	  <!-- content -->
	  <p>&gt;<br>@Property是声明属性的语法，它可以快速方便的为实例变量创建存取器，并允许我们通过点语法使用存取器。<br>存取器（accessor）：指用于获取和设置实例变量的方法。用于获取实例变量值的存取器是getter，用于设置实例变量值的存取器是setter。</p>
<h3 id="修饰词"><a href="#修饰词" class="headerlink" title="修饰词"></a>修饰词</h3><p>assign、weak、strong、retain、copy、nonatomic、atomic、readonly、readwrite</p>
<h4 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h4><p>1.这个修饰词是直接赋值的意思 , 整型/浮点型等数据类型都用这个词修饰 .<br>2.如果没有使用 weak strong retain copy 修饰 , 那么默认就是使用 assign 了. ( 它们之间是有你没我的关系 )<br>3.当然其实对象也可以用 assign 修饰 , 只是对象的计数器不会+1 . ( 与 strong 的区别 )<br>4.如果用来修饰对象属性 , 那么当对象被销毁后指针是不会指向 nil 的 . 所以会出现野指针错误 . ( 与weak的区别 )<br>assign（默认）：assign用于值类型，如int、float、double和NSInteger，CGFloat等表示单纯的复制。还包括不存在所有权关系的对象，比如常见的delegate。</p>
<h4 id="weak-ARC-对象"><a href="#weak-ARC-对象" class="headerlink" title="weak ( ARC )(对象)"></a>weak ( ARC )(对象)</h4><p>1.弱指针是针对对象的修饰词 , 就是说它不能修饰基本数据类型(int float) .<br>2.weak 修饰的引用计数器不会+1 , 也就是直接赋值 .<br>3.弱引用是为打破循环引用而生的 .<br>4.它最被人所喜欢的原因是 它所指向的对象如果被销毁 , 它会指向 nil . 从而不会出现野指针错误 .<br>在setter方法中，需要对传入的对象不进行引用计数加1的操作。<br>简单来说，就是对传入的对象没有所有权，当该对象引用计数为0时，即该对象被释放后，用weak声明的实例变量指向nil，即实例变量的值为0。weak关键字是IOS5引入的，IOS5之前是不能使用该关键字的。delegate 和 Outlet 一般用weak来声明。</p>
<h4 id="strong-ARC-对象"><a href="#strong-ARC-对象" class="headerlink" title="strong ( ARC )(对象)"></a>strong ( ARC )(对象)</h4><p>1.直接赋值并且对象的引用计数器 +1 .<br>2.在 ARC 里替代了 retain 的作用 .<br>strong是在IOS引入ARC的时候引入的关键字，是retain的一个可选的替代。表示实例变量对传入的对象要有所有权关系，即强引用。strong跟retain的意思相同并产生相同的代码，但是语意上更好更能体现对象的关系。</p>
<h4 id="retain-MRC"><a href="#retain-MRC" class="headerlink" title="retain ( MRC )"></a>retain ( MRC )</h4><p>1.release 旧对象( 旧对象计数器 -1 ) , retain 新对象( 新对象计数器 +1 ) , 然后指向新对象 .<br>2.在set方法里面是这样的 :</p>
<pre><code> if (_dog)
{ 
  [_dog release]; 
} 
_dog = [dog retain];
</code></pre><h4 id="copy-ARC-MRC"><a href="#copy-ARC-MRC" class="headerlink" title="copy ( ARC/MRC )"></a>copy ( ARC/MRC )</h4><p>1.copy 在 MRC 时是这样做的 release 旧对象( 旧对象的引用计数器 -1 ) , copy 新对象( 新对象的引用计数器 +1 ) , 然后指向新对象 .（新对象是指最终指向的那个对象，不管深拷贝还是浅拷贝）</p>
<p>1.1在set方法里面是这样的 :</p>
<pre><code>if (_dog) 
{ 
[_dog release]; 
} 
_dog = [dog copy];
</code></pre><p>2.copy 在 ARC 时是这么干的 copy 新对象( 新对象的引用计数器 +1 ) , 然后指向新对象 .</p>
<p>2.1在set方法里面是这样的 :<br>_dog = [dog copy];<br>3.使用注意 :<br>3.1 修饰的属性本身要不可变的 . 例如 NSMutableArray 采用 copy 修饰 , 添加元素表面上可以 一到运行就崩溃了 , 因为 copy 过后实际上成了NSArray了 . 那么此时，需要用到mutablecopy。<br>3.2 遵守 NSCopying 协议的对象使用 .<br>与strong类似，但区别在于实例变量是对传入对象的副本拥有所有权，而非对象本身。</p>
<h4 id="nonatomic-ARC-MRC"><a href="#nonatomic-ARC-MRC" class="headerlink" title="nonatomic ( ARC/MRC )"></a>nonatomic ( ARC/MRC )</h4><p>1.不对set方法加锁 .<br>2.性能好<br>3.线程不安全<br>nonatomic跟atomic刚好相反。表示非原子的，可以被多个线程访问。它的效率比atomic快。但不能保证在多线程环境下的安全性，在单线程和明确只有一个线程访问的情况下广泛使用。</p>
<h4 id="atomic-ARC-MRC"><a href="#atomic-ARC-MRC" class="headerlink" title="atomic ( ARC/MRC )"></a>atomic ( ARC/MRC )</h4><p>1.原子属性就是对生成的 set 方法加互斥锁 @synchronized(锁对象) .</p>
<pre><code>@synchronized(self) { _delegate = delegate;}
</code></pre><p>2.需要消耗系统资源 .<br>3.互斥锁是利用线程同步实现的 , 意在保证同一时间只有一个线程调用 set 方法 .<br>4.其实还有 get 方法 , 要是同时 set 和 get 一起调用还是会有问题的 . 所以即使用了 atomic 修饰 还是不够安全 .</p>
<p>atomic（默认）：atomic意为操作是原子的，意味着只有一个线程访问实例变量。atomic是线程安全的，至少在当前的存取器上是安全的。它是一个默认的特性，但是很少使用，因为比较影响效率，这跟ARM平台和内部锁机制有关。</p>
<h4 id="readonly-只读"><a href="#readonly-只读" class="headerlink" title="readonly (只读)"></a>readonly (只读)</h4><p>1.让 Xcode 只生成get方法 .<br>2.不想把暴露的属性被人随便替换时 , 可以使用 .<br>readonly： readonly表示只有getter没有setter。</p>
<h4 id="readwrite-读写-默认"><a href="#readwrite-读写-默认" class="headerlink" title="readwrite (读写)(默认)"></a>readwrite (读写)(默认)</h4><p>1.让 Xcode 生成get/set方法 .<br>2.不用 readonly 修饰时 , 默认就是 readwrite .<br>readwrite（默认）：readwrite是默认值，表示该属性同时拥有setter和getter。</p>
	  

	  <div>
  		<center>
		  <div class="pagination">
<ul class="pagination">
	
	
	
	
	
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
			
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
			
			
		
	
		
	
		
	
		
			
		
	
		
			
		
	
		
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
		
	
		
	
		
	
		
	
		
	
	
	
		<li class="prev"><a href="/2016/08/08/iOS/实例方法、类方法、Category、Protocol/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i>prev</a></li>
	
	<li><a href="/"><i class="fa fa-archive"></i>Home</a></li>
	
		<li class="next"><a href="/2016/06/24/iOS/Objc面试题收录/" class="alignright next">next<i class="fa fa-arrow-circle-o-right"></i></a></li>
	
</ul>
</div>

		</center>
	  </div>
	  
	</div> <!-- col-md-9/col-md-12 -->
	
  </div><!-- row -->

	</div>
  </div>
  <div class="container-narrow">
	<footer> <p>
  &copy; 2016 John Doe
  
      with help from <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-wixo/">Wixo</a>.    
</p> </footer>
  </div> <!-- container-narrow -->
  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/jquery.tableofcontents.min.js"></script>
<script src="/js/tocgenerator.min.js"></script>
<script src="/js/main.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


</body>
</html>
