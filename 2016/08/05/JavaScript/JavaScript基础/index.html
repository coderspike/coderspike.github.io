<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JavaScript基础 | spike</title>
  <meta name="author" content="John Doe">
  
  <meta name="description" content="基本特性1、脚本语言JavaScript是一种解释型的脚本语言,C、C++等语言先编译后执行,而JavaScript是在程序的运行过程中进行解释执行。2、基于对象JavaScript是一种基于对象的脚本语言,它不仅可以创建对象,也能使用现有的对象。JavaScript 中的几乎所有事务都是对象：字符">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="JavaScript基础"/>
  <meta property="og:site_name" content="spike"/>

  
    <meta property="og:image" content="undefined"/>
  

  
    <link rel="alternative" href="/atom.xml" title="spike" type="application/atom+xml">
  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">  
  <link rel="stylesheet" href="/css/sidenav.css" media="screen" type="text/css">  
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  

</head>

<body id="body" data-spy="scroll" data-target=".toc">
  <div class="container" id="container">
	<div class="content">
	  <div class="page-header">		
  <h1><a class="brand" href="/">spike</a><span class="split"></span><span class="title">JavaScript基础</span><span class="date" id="title-date"><i class="fa fa-clock-o"></i> 2016-08-05</span></h1>
</div>		

<div class="row page">
  <!-- cols -->	
  
  

  
	<div class="col-md-12">
	  

	  <!-- content -->
	  <h3 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h3><p>1、脚本语言<br>JavaScript是一种解释型的脚本语言,C、C++等语言先编译后执行,而JavaScript是在程序的运行过程中进行解释执行。<br>2、基于对象<br>JavaScript是一种基于对象的脚本语言,它不仅可以创建对象,也能使用现有的对象。JavaScript 中的几乎所有事务都是对象：字符串、数字、数组、日期、函数，等等。<br>3、简单<br>JavaScript语言中采用的是弱类型的变量类型,对使用的数据类型未做出严格的要求,是基于Java基本语句和控制的脚本语言,其设计简单紧凑。<br>4、动态性<br>JavaScript是一种采用事件驱动的脚本语言,它不需要经过Web服务器就可以对用户的输入做出响应。<br>5、跨平台性<br>JavaScript脚本语言不依赖于操作系统,仅需要浏览器的支持</p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>通常来说，一段程序代码中所用到的名字并不总是有效/可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。<br>1.js变量声明提前</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global"</span>;    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   alert(scope);<span class="comment">//undefined</span></span><br><span class="line">   <span class="keyword">var</span> scope = <span class="string">"local"</span></span><br><span class="line">    alert(scope);<span class="comment">//local</span></span><br><span class="line">&#125;</span><br><span class="line">t();      </span><br><span class="line">以上代码说明:</span><br><span class="line"><span class="number">1.</span><span class="function"><span class="keyword">function</span>作用域里的变量<span class="title">scope</span>遮盖了上层作用域变量<span class="title">scope</span>,<span class="title">javascript</span>是没有块级作用域的,只有函数作用域。<span class="title">JavaScript</span> 变量的生存期,<span class="title">JavaScript</span> 变量的生命期从它们被声明的时间开始。局部变量会在函数运行以后被删除,全局变量会在页面关闭后被删除。</span><br><span class="line">2.在<span class="title">function</span>作用域内，变量<span class="title">v</span>的声明被提升了。所以最初的代码相当于：</span><br><span class="line"><span class="title">var</span> <span class="title">v</span> = "<span class="title">global</span>";</span><br><span class="line"><span class="title">function</span> <span class="title">t</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scope; <span class="comment">//declaration hoisting</span></span><br><span class="line">  alert(scope)</span><br><span class="line">  scope = <span class="string">"local"</span>;</span><br><span class="line">  alert(scope)</span><br><span class="line">&#125;          </span><br><span class="line">t();</span><br></pre></td></tr></table></figure>
<p>2.不用var声明为全局变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    scope = <span class="string">"local"</span></span><br><span class="line">&#125;</span><br><span class="line">t();</span><br><span class="line">alert(scope);<span class="comment">//local</span></span><br></pre></td></tr></table></figure>
<h3 id="JS原型"><a href="#JS原型" class="headerlink" title="JS原型"></a>JS原型</h3><p>(1) 所有的函数都有一个prototype属性，这个属性引用了一个对象，这个对象就是原型对象，也简称原型。</p>
<p>(2)函数的prototype属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">函数的prototype属性</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">alert(Foo.prototype); <span class="comment">//[object Object]</span></span><br></pre></td></tr></table></figure>
<p>(3)prototype的constructor属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">alert(Foo.prototype.constructor); <span class="comment">//function Foo()&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>(4)对象的<strong>proto</strong>属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype =  &#123;name:<span class="string">"xxx"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Foo();</span><br><span class="line">alert(obj.__proto__ === Foo.prototype); <span class="comment">//true</span></span><br><span class="line">alert(obj.name); <span class="comment">//xxx</span></span><br></pre></td></tr></table></figure>
<p>(5)原型链<br>访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着<strong>proto</strong>这条链向上找，这就是原型链。<br>(6)区分一个属性是不是从原型里找到的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype =  &#123;name:<span class="string">"xxx"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Foo(); </span><br><span class="line">obj.age = <span class="number">10</span>;</span><br><span class="line">alert(obj. hasOwnProperty(<span class="string">"name"</span>));<span class="comment">//false</span></span><br><span class="line">alert(obj. hasOwnProperty(<span class="string">"age"</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>(7) 函数对象有隐式原型吗？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">alert(Foo.__proto__); <span class="comment">//function () &#123;&#125;</span></span><br><span class="line">alert(Foo.__proto__.constructor); <span class="comment">//function Function() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>
<p>（8）Fuction创造一切<br><img src="http://ww4.sinaimg.cn/mw690/bc254b75gw1f6j9aobtmej20t00oudjf.jpg" alt="img"></p>
<p>(9)所有对象都有原型链</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(<span class="string">"str"</span>.__proto__.constructor);<span class="comment">//function String() &#123; [native code] &#125;</span></span><br><span class="line">alert(<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>).__proto__.constructor);<span class="comment">//function Number() &#123; [native code] &#125;</span></span><br><span class="line">alert(<span class="keyword">new</span> <span class="built_in">Date</span>.__proto__.constructor);<span class="comment">//function anonymous() &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>(10)利用原型对象对原生对象进行扩展</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span>.prototype.suolve =  <span class="function"><span class="keyword">function</span> (<span class="params">length</span>)</span>&#123;</span><br><span class="line"> 		<span class="keyword">if</span>(<span class="keyword">this</span>.length &gt; length)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.substring(<span class="number">0</span>,length)+<span class="string">"……"</span>;</span><br><span class="line">   		 &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">     		<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   		 &#125;</span><br><span class="line">&#125;</span><br><span class="line">alert(<span class="string">"猜猜结果？"</span>.suolve(<span class="number">2</span>)); <span class="comment">//猜猜……</span></span><br></pre></td></tr></table></figure>
<h3 id="通用写法"><a href="#通用写法" class="headerlink" title="通用写法"></a>通用写法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name,age = <span class="number">10</span>,dept;</span><br><span class="line"></span><br><span class="line">alert(<span class="number">10</span> == <span class="string">"10"</span>); <span class="comment">//true</span></span><br><span class="line">alert(<span class="number">10</span> === <span class="string">"10"</span>); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">""</span>;</span><br><span class="line">alert(name || <span class="string">"xxx"</span>); <span class="comment">//xxx</span></span><br><span class="line">alert(name &amp;&amp; <span class="string">"xxx"</span>); <span class="comment">//""</span></span><br></pre></td></tr></table></figure>
<h3 id="javascript里的反射"><a href="#javascript里的反射" class="headerlink" title="javascript里的反射"></a>javascript里的反射</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;name:<span class="string">'xxx'</span>,age:<span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> p <span class="keyword">in</span> obj)&#123;</span><br><span class="line">	 alert(p);</span><br><span class="line">     alert(obj[p]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// name xxx age 10</span></span><br></pre></td></tr></table></figure>
<h3 id="使用立即执行函数对代码进行隔离"><a href="#使用立即执行函数对代码进行隔离" class="headerlink" title="使用立即执行函数对代码进行隔离"></a>使用立即执行函数对代码进行隔离</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">主要是用于隔离作用域</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... all vars and functions are in this scope only</span></span><br><span class="line">    <span class="comment">// still maintains access to all globals</span></span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">函数中的变量并不会影响到外面的作用域中</span><br><span class="line"><span class="keyword">var</span> currTime = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    <span class="keyword">var</span> year  = time.getFullYear()</span><br><span class="line">    <span class="keyword">var</span> month = time.getMonth()</span><br><span class="line">    <span class="keyword">var</span> date  = time.getDate()</span><br><span class="line">    <span class="keyword">var</span> hour  = time.getHours()</span><br><span class="line">    <span class="keyword">var</span> min   = time.getMinutes()</span><br><span class="line">    <span class="keyword">var</span> sec   = time.getSeconds()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> year + <span class="string">'/'</span> + month + <span class="string">'/'</span> + date + <span class="string">' '</span> + hour + <span class="string">':'</span> + min + <span class="string">':'</span> + sec</span><br><span class="line">&#125;)()；</span><br><span class="line">alert(currTime);  <span class="comment">//2016/7/6 17:0:27</span></span><br></pre></td></tr></table></figure>
<h3 id="关于闭包和立即执行函数"><a href="#关于闭包和立即执行函数" class="headerlink" title="关于闭包和立即执行函数"></a>关于闭包和立即执行函数</h3><p>匿名函数和闭包没有直接关系。能用匿名函数实现闭包的地方，一定也能用命名函数实现。<br>闭包的本质在于“闭”和“包”，即把一些变量封闭起来，使其它程序访问不到，同时把这个封闭的东西打成包甩出来，让大家可以直接用这个包（函数）。最典型的实现之一是对象（或类）的私有成员，如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">// 这是一个封闭在 MyClass 中的局部变量</span></span><br><span class="line">   <span class="keyword">var</span> _name;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 这是一个甩出来的“包”</span></span><br><span class="line">   <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> _name;</span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 这是另一个甩出来的“包”</span></span><br><span class="line">   <span class="keyword">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">       <span class="comment">// 这保证了 _name 的第一个字母和空格后的第一个字母是大写</span></span><br><span class="line">       <span class="comment">// 而且因为闭包的原因，_name 不可能被 MyCLass() 外的程序访问到</span></span><br><span class="line">       <span class="comment">// 也就保证了上述命名规则的无例外执行</span></span><br><span class="line">       _name = name.replace(<span class="regexp">/^.|\s./g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> s.toUpperCase();</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> MyClass();</span><br><span class="line">p.setName(<span class="string">"james fancy"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.getName());   <span class="comment">// James Fancy</span></span><br></pre></td></tr></table></figure>
<p>匿名函数通常只是用于给成员赋值，比如上例中的 getName 和 setName；也有可能用于立即执行函数，比如你的那段代码，这会将全局变量局部化，避免全局污染。<br>闭包常常会和匿名函数一起使用，但他们之间并没有密不可分的关系。<br>IIFE主要目的是做的一些封装，防止污染，以及保证内部变量的安全<br>闭包严格来说，是一个函数执行之后，返回另外一个函数，返回的函数有前一个函数的内部变量的引用可能会用在IIFE里面，通过返回的函数来提供内部变量的一些操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">....</span><br><span class="line">&#125;());</span><br><span class="line">可以拆解为</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure>
<p>闭包是对函数中变量作用域的构成方式的一种表述，具体表现为一个函数中可以访问不在其作用域范围内但在其外层函数作用域中存在的变量，这个外层函数作用域的顶层为全局作用域</p>
<p>匿名函数从字面理解就是没有命名的函数，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> 	<span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>立即执行函数是指声明完之后便直接执行的函数，因此通常这类函数也不需要命名，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> 	<span class="comment">//...</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>闭包通常指在函数内部再定义一个函数，由于作用域的关系，外部函数无法访问内部函数的变量，而内部函数可以访问外部函数的变量，此时如果外部函数将内部函数返回，便形成了闭包，如：</p>
<pre><code class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>{
  <span class="keyword">var</span> prop = <span class="string">'outer'</span>;
  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>{
<span class="built_in">console</span>.log(prop); <span class="comment">// outer</span>
  }
  <span class="keyword">return</span> inner;
}
</code></pre>
<p>所以，也可以把任何函数理解为一个闭包，因为每个函数都可以访问外部函数或者全局的变量，但是外部函数或全局无法访问函数内部的变量，也就可以理解为是一个闭包。</p>
	  

	  <div>
  		<center>
		  <div class="pagination">
<ul class="pagination">
	
	
	
	
	
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
			
			
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	
	
		<li class="prev disabled"><a><i class="fa fa-arrow-circle-o-left"></i>prev</a></li>
	
	<li><a href="/"><i class="fa fa-archive"></i>Home</a></li>
	
		<li class="next disabled"><a>next<i class="fa fa-arrow-circle-o-right"></i></a></li>
	
</ul>
</div>

		</center>
	  </div>
	  
	</div> <!-- col-md-9/col-md-12 -->
	
  </div><!-- row -->

	</div>
  </div>
  <div class="container-narrow">
	<footer> <p>
  &copy; 2016 John Doe
  
      with help from <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-wixo/">Wixo</a>.    
</p> </footer>
  </div> <!-- container-narrow -->
  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/jquery.tableofcontents.min.js"></script>
<script src="/js/tocgenerator.min.js"></script>
<script src="/js/main.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


</body>
</html>
