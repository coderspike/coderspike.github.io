<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="coder-gwb" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="coder-gwb">
<meta property="og:type" content="website">
<meta property="og:title" content="coder-gwb">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="coder-gwb">
<meta property="og:description" content="coder-gwb">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="coder-gwb">
<meta name="twitter:description" content="coder-gwb">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://yoursite.com/"/>

  <title> coder-gwb </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">coder-gwb</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/16/关于CocoaPods的使用总结/" itemprop="url">
                  关于CocoaPods的使用总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-06-16T16:27:20+08:00" content="2016-06-16">
              2016-06-16
            </time>
          </span>

          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/15/一些概念和知识点/" itemprop="url">
                  一些概念和知识点
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-06-15T16:07:24+08:00" content="2016-06-15">
              2016-06-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>杂乱的记录一些概念及知识点</p>
</blockquote>
<h4 id="介绍AppDelegate之前先要介绍UIApplication"><a href="#介绍AppDelegate之前先要介绍UIApplication" class="headerlink" title="介绍AppDelegate之前先要介绍UIApplication"></a>介绍AppDelegate之前先要介绍UIApplication</h4><p>简单介绍<br>（1）UIApplication对象是应用程序的象征，一个UIApplication对象就代表一个应用程序。<br>（2）每一个应用都有自己的UIApplication对象，而且是单例的，如果试图在程序中新建一个UIApplication对象，那么将报错提示。<br>（3）通过[UIApplicationsharedApplication]可以获得这个单例对象<br>（4） 一个iOS程序启动后创建的第一个对象就是UIApplication对象，且只有一个（通过代码获取两个UIApplication对象，打印地址可以看出地址是相同的）。<br>（5）利用UIApplication对象，能进行一些应用级别的操作，如：设置应用程序图标右上角的红色提醒数字、设置联网指示器的可见性、管理状态栏、openURL<br>下面介绍appdelagate<br>在main.m的UIApplicationMain函数中，根据@”AppDelegate”这个类，创建一个delegate对象，并将该delegate对象赋值给UIApplication对象中的delegate属性<br>所有的移动操作系统都有个致命的缺点：app很容易受到打扰。比如一个来电或者锁屏会导致app进入后台甚至被终止。<br>还有很多其它类似的情况会导致app受到干扰，在app受到干扰时，会产生一些系统事件，这时UIApplication会通知它的delegate对象，让delegate代理来处理这些系统事件。<br>作用：当被打断的时候，通知代理进入到后台。</p>
<h4 id="响应者链"><a href="#响应者链" class="headerlink" title="响应者链"></a>响应者链</h4><p>事件分类<br>对于IOS设备用户来说，他们操作设备的方式主要有三种：触摸屏幕、晃动设备、通过遥控设施控制设备。对应的事件类型有以下三种：<br>1、触屏事件（Touch Event）<br>2、运动事件（Motion Event）<br>3、远端控制事件（Remote-Control Event）</p>
<p>响应者链（Responder Chain）<br>指的是有响应和处理事件能力的对象。响应者链就是由一系列的响应者对象构成的一个层次结构。<br>什么是事件的响应者<br>只要继承了UIResponder的对象就可以作为事件的响应者<br>其中AppDelegate类是创建一个iOS项目时自动创建的继承UIResponder的应用程序委托类<br>// 接口文件</p>
<p>#import <uikit uikit.h=""><br>@interface AppDelegate : UIResponder <uiapplicationdelegate></uiapplicationdelegate></uikit></p>
<ul>
<li>什么是第一响应者<br>与用户交互的控件就是第一响应者，它将作为响应者链的开始，事件首先发送给第一响应者，然后再依次传递下去，直到该事件被某个响应者处理。</li>
<li>起始及事件分发<br>当一个触摸事件发生，首先接收到事件的对象是UIApplication<br>将事件放入UIApplication的活动队列中<br>UIApplication的单例对象，再从活动队列取出该事件，并传递给UIWindow<br>UIWindow的对象将调用-(nullable UIView <em>)hitTest:(CGPoint)point withEvent:(nullable UIEvent </em>)event;方法<br>  • 在这个方法中对其下一层的每一个视图调用- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent <em>)event;方法，用于判断当前点击的点是否位于当前视图中<br>（1）若返回NO，则表示不在当前视图中，-(nullable UIView </em>)hitTest:(CGPoint)point withEvent:(nullable UIEvent <em>)event;方法返回nil;<br>（2）若返回YES，则说明该触摸事件发生在当前视图，然后当前视图再调用 -(nullable UIView </em>)hitTest:(CGPoint)point withEvent:(nullable UIEvent <em>)event;方法;<br>（3）重复上述过程，直到- (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent </em>)event;方法返回YES，并使用它调用-(nullable UIView <em>)hitTest:(CGPoint)point withEvent:(nullable UIEvent </em>)event;方法返回nil的时候，表示此视图就是这个触摸事的第一响应者。</li>
<li>响应者链<br>如果当前响应者无法响应用户事件，它将继续向上传递，直到找到请响应者，这个传递过程形成了一条有规律的链条，组成了响应者链（一个层次结构）如果一直找到AppDelegate类还是无法响应用户事件，那么这个事件将无法被响应，但如果在响应者链上传递的过程中，有某个响应者对该传递的事件有响应，该传递过程将立即停止。<br><img src="http://upload-images.jianshu.io/upload_images/652024-2e717ff7875279f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>  initial view若不能处理事件，则传到其父视图view<br>  view若不能处理，则传到其父视图，因为它还不是最上层视图<br>  这里view的父视图是view controller的view，因为这个view也不能处理事件，因此传给view controller<br>  若view controller也不能处理此事件，则传到window<br>  若window也不能处理此事件，则传到app单例对象Application<br>  若UIApplication单例对象也不能处理，则表示无效事件</li>
</ul>
<h3 id="简单描述一下XIB与Storyboards，说一下他们的优缺点"><a href="#简单描述一下XIB与Storyboards，说一下他们的优缺点" class="headerlink" title="简单描述一下XIB与Storyboards，说一下他们的优缺点"></a>简单描述一下XIB与Storyboards，说一下他们的优缺点</h3><p>优点：<br>XIB：在编译前就提供了可视化界面，可以直接拖控件，也可以直接给控件添加约束，更直观一些，而且类文件中就少了创建控件的代码，确实简化不少，通常每个XIB对应一个类。<br>Storyboard：在编译前提供了可视化界面，可拖控件，可加约束，在开发时比较直观，而且一个storyboard可以有很多的界面，每个界面对应一个类文件，通过storybard，可以直观地看出整个App的结构(事实上故事板是多个xib文件集合的描述文件，也采用xml格式).<br>缺点：<br>XIB：需求变动时，需要修改XIB很大，有时候甚至需要重新添加约束，导致开发周期变长。XIB载入相比纯代码自然要慢一些。对于比较复杂逻辑控制不同状态下显示不同内容时，使用XIB是比较困难的。当多人团队或者多团队开发时，如果XIB文件被发动，极易导致冲突，而且解决冲突相对要困难很多。<br>Storyboard：需求变动时，需要修改storyboard上对应的界面的约束，与XIB一样可能要重新添加约束，或者添加约束会造成大量的冲突，尤其是多团队开发。对于复杂逻辑控制不同显示内容时，比较困难。当多人团队或者多团队开发时，大家会同时修改一个storyboard，导致大量冲突，解决起来相当困难。</p>
<h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>也称为延迟加载，即在需要的时候才加载（效率低，占用内存小）。所谓懒加载，写的是其get方法.</p>
<ul>
<li>(NSMutableArray *)fakeData<br>{<pre><code>if (!_fakeData)//判断是否已经有了，若没有，则进行实例化
</code></pre>  {<pre><code>self.fakeData   = [NSMutableArray array];
</code></pre>  }<br>  return _fakeData;<br>}</li>
</ul>
<p>优点：<br>防止对象被提前创建（内存优化，如加载plist文件等耗内存的操作）<br>防止对象重复创建 （永远只加载一次）<br>防止对象使用时,还没被创建<br>可以在懒加载方法里面,进行初始化操作</p>
<p>懒加载代码示例</p>
<ul>
<li>(void)viewDidLoad {<br>[super viewDidLoad];<br>}</li>
<li>(NSArray *)shopData<br>{<br>  if (!_shopData) {<pre><code>_shopData = [NSArray arrayWithContentsOfFile:
</code></pre>[[NSBundle mainBundle] pathForResource:@”shop” ofType:@”plist”]];<br>  }<br>  return _shopData;<br>}<br>@end</li>
</ul>
<h3 id="iOS开发中需要的图片"><a href="#iOS开发中需要的图片" class="headerlink" title="iOS开发中需要的图片"></a>iOS开发中需要的图片</h3><p>1、产品设计图<br>   可以以6的长宽比 750<em>1134来设计。这些图片用于描述app是什么样子的，这是app开发人员的开发参考。<br>2、产品切图<br>将设计师将设计稿切成可以用来开发的图<br>    颜色值<br>    iOS颜色值取 RGB各颜色的值比如某个色值，给予iOS开发的色值为 R:12 G:34 B:56 给出的值就是 12,34,56(有时也要根据开发的习惯，有时也用十六进制)<br>    内部设计细节：1、所有能点击的图片不得小于44px（Retina需要88px）2、单独存在的部件必须是双数尺寸 3、两倍图以@2x作为命名后缀<br>3、图标icon<br>      需要四种尺寸：58</em>58、80<em>80、120</em>120、180<em>180<br>4、启动图LaunchImage<br>      需要四种尺寸：3.5英寸（640</em>960），4英寸（640<em>1136），4.7英寸（750</em>1134），5.5英寸（1242<em>2208）<br>5、引导图<br>      这是用于用户第一次使用app或者app更新之后展示新特性的图<br>6、App Store上架图<br>      这个是用于在App Store上面 介绍app的，需要四种尺寸：3.5英寸（640</em>960），4英寸（640<em>1136），4.7英寸（750</em>1134），5.5英寸（1242*2208）</p>
<h3 id="在-m中的声明-interface"><a href="#在-m中的声明-interface" class="headerlink" title="在.m中的声明@interface"></a>在.m中的声明@interface</h3><p>//in Header.h<br>@interface Header{}<br>@end</p>
<p>//in Header.m<br>@interface Header()<br>@end<br>这是个非常常见的设计,为什么在.m文件里面,也要出现一个接口声明呢?<br>这很类似于一个分类,但其实它不是一个分类(或者你也可以叫它anonymous Catogary),其实这是一个叫做class extension的东西</p>
<p>说说区别:</p>
<ol>
<li>首先 extension 可以重声明一个数据成员,比如一个数据成员是只读的,你可以把它变成可读写</li>
<li>分类根本不同意你扩展数据成员,它只扩展一些方法, 但是在Clang/LLVM 2.0 compiler 以后, extension可以这么做.</li>
<li>有时候,你如果希望实现一些不公开的方法供自己使用,那你可以把它放入.m的extension里面.那么这些接口都是不公开的了</li>
</ol>
<h3 id="下面四个修饰指针有什么区别"><a href="#下面四个修饰指针有什么区别" class="headerlink" title="下面四个修饰指针有什么区别?"></a>下面四个修饰指针有什么区别?</h3><p>const char <em>p;<br>char const </em>p;<br>char <em> const p;<br>const char </em> const p;</p>
<p>参考答案：<br>• const char <em>p定义了一个指向不可变的字符串的字符指针，可以这么看：const char </em>为类型，p是变量。<br>• char const <em>p与上一个是一样的。<br>• char </em> const p定义了一个指向字符串的指针，该指针值不可改变，即不可改变指向。这么看：char <em>是类型，const是修饰变量p，也就是说p是一个常量<br>const char </em> const p定义了一个指向不可变的字符串的字符指针，且该指针也不可改变指向。这一个就很容易看出来了。两个const分别修饰，因此都是不可变的。   </p>
<h3 id="关于页面流"><a href="#关于页面流" class="headerlink" title="关于页面流"></a>关于页面流</h3><p>ViewDIdLoad是视图加载完成调用的,你pop回来他早已经加载过了不会在进入这个函数了</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/15/多线程基础/" itemprop="url">
                  多线程基础
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-06-15T14:46:00+08:00" content="2016-06-15">
              2016-06-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>多线程在iOS的开发中应用的场景非常多，自己还不能整理完全，转一下别人的博客，自己稍作记录。</p>
</blockquote>
<p><a href="http://www.cnblogs.com/kenshincui/p/3983982.html" target="_blank" rel="external">这里</a></p>
<p>iOS多线程</p>
<p>在iOS中每个进程启动后都会建立一个主线程（UI线程），这个线程是其他线程的父线程。由于在iOS中除了主线程，其他子线程是独立于Cocoa Touch的，所以只有主线程可以更新UI界面（新版iOS中，使用其他线程更新UI可能也能成功，但是不推荐）。iOS中多线程使用并不复杂，关键是如何控制好各个线程的执行顺序、处理好资源竞争问题。常用的多线程开发有三种方式：</p>
<p>1.NSThread</p>
<p>2.NSOperation</p>
<p>3.GCD</p>
<h3 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h3><p>NSThread是轻量级的多线程开发，使用起来也并不复杂，但是使用NSThread需要自己管理线程生命周期。可以使用对象方法+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(id)argument直接将操作添加到线程中并启动，也可以使用对象方法- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(id)argument 创建一个线程对象，然后调用start方法启动线程。</p>
<h5 id="解决线程阻塞问题"><a href="#解决线程阻塞问题" class="headerlink" title="解决线程阻塞问题"></a>解决线程阻塞问题</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">在资源下载过程中，由于网络原因有时候很难保证下载时间，如果不使用多线程可能用户完成一个下载操作需要长时间的等待，这个过程中无法进行其他操作。下面演示一个采用多线程下载图片的过程，在这个示例中点击按钮会启动一个线程去下载图片，下载完成后使用UIImageView将图片显示到界面中。可以看到用户点击完下载按钮后，不管图片是否下载完成都可以继续操作界面，不会造成阻塞。</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">//  NSThread实现多线程</span><br><span class="line">//  MultiThread</span><br><span class="line">//</span><br><span class="line">//  Created by Kenshin Cui on 14-3-22.</span><br><span class="line">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;KCMainViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface KCMainViewController ()&#123;</span><br><span class="line">    UIImageView *_imageView;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation KCMainViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [self layoutUI];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 界面布局</span><br><span class="line">-(void)layoutUI&#123;</span><br><span class="line">    _imageView =[[UIImageView alloc]initWithFrame:[UIScreen mainScreen].applicationFrame];</span><br><span class="line">    _imageView.contentMode=UIViewContentModeScaleAspectFit;</span><br><span class="line">    [self.view addSubview:_imageView];</span><br><span class="line">    </span><br><span class="line">    UIButton *button=[UIButton buttonWithType:UIButtonTypeRoundedRect];</span><br><span class="line">    button.frame=CGRectMake(50, 500, 220, 25);</span><br><span class="line">    [button setTitle:@&quot;加载图片&quot; forState:UIControlStateNormal];</span><br><span class="line">    //添加方法</span><br><span class="line">    [button addTarget:self action:@selector(loadImageWithMultiThread) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">    [self.view addSubview:button];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 将图片显示到界面</span><br><span class="line">-(void)updateImage:(NSData *)imageData&#123;</span><br><span class="line">    UIImage *image=[UIImage imageWithData:imageData];</span><br><span class="line">    _imageView.image=image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 请求图片数据</span><br><span class="line">-(NSData *)requestData&#123;</span><br><span class="line">    NSURL *url=[NSURL URLWithString:@&quot;http://images.apple.com/iphone-6/overview/images/biggest_right_large.png&quot;];</span><br><span class="line">    NSData *data=[NSData dataWithContentsOfURL:url];</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 加载图片</span><br><span class="line">-(void)loadImage&#123;</span><br><span class="line">    //请求数据</span><br><span class="line">    NSData *data= [self requestData];</span><br><span class="line">    /*将数据显示到UI控件,注意只能在主线程中更新UI,</span><br><span class="line">     另外performSelectorOnMainThread方法是NSObject的分类方法，每个NSObject对象都有此方法，</span><br><span class="line">     它调用的selector方法是当前调用控件的方法，例如使用UIImageView调用的时候selector就是UIImageView的方法</span><br><span class="line">     Object：代表调用方法的参数,不过只能传递一个参数(如果有多个参数请使用对象进行封装)</span><br><span class="line">     waitUntilDone:是否线程任务完成执行</span><br><span class="line">    */</span><br><span class="line">    [self performSelectorOnMainThread:@selector(updateImage:) withObject:data waitUntilDone:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 多线程下载图片</span><br><span class="line">-(void)loadImageWithMultiThread&#123;</span><br><span class="line">    //方法1：使用对象方法</span><br><span class="line">    //创建一个线程，第一个参数是请求的操作，第二个参数是操作方法的参数</span><br><span class="line">//    NSThread *thread=[[NSThread alloc]initWithTarget:self selector:@selector(loadImage) object:nil];</span><br><span class="line">//    //启动一个线程，注意启动一个线程并非就一定立即执行，而是处于就绪状态，当系统调度时才真正执行</span><br><span class="line">//    [thread start];</span><br><span class="line">    </span><br><span class="line">    //方法2：使用类方法</span><br><span class="line">    [NSThread detachNewThreadSelector:@selector(loadImage) toTarget:self withObject:nil];</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">程序比较简单，但是需要注意执行步骤：当点击了“加载图片”按钮后启动一个新的线程，这个线程在演示中大概用了5s左右，在这5s内UI线程是不会阻塞的，用户可以进行其他操作，大约5s之后图片下载完成，此时调用UI线程将图片显示到界面中（这个过程瞬间完成）。另外前面也提到过，更新UI的时候使用UI线程，这里调用了NSObject的分类扩展方法，调用UI线程完成更新。</span><br></pre></td></tr></table></figure>
<h5 id="多个线程并发"><a href="#多个线程并发" class="headerlink" title="多个线程并发"></a>多个线程并发</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">上面这个演示并没有演示多个子线程操作之间的关系，现在不妨在界面中多加载几张图片，每个图片都来自远程请求。</span><br><span class="line"></span><br><span class="line">大家应该注意到不管是使用+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(id)argument、- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(id)argument 方法还是使用- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait方法都只能传一个参数，由于更新图片需要传递UIImageView的索引和图片数据，因此这里不妨定义一个类保存图片索引和图片数据以供后面使用。</span><br><span class="line"></span><br><span class="line">KCImageData.h</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">//  KCImageData.h</span><br><span class="line">//  MultiThread</span><br><span class="line">//</span><br><span class="line">//  Created by Kenshin Cui on 14-3-22.</span><br><span class="line">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface KCImageData : NSObject</span><br><span class="line"></span><br><span class="line">#pragma mark 索引</span><br><span class="line">@property (nonatomic,assign) int index;</span><br><span class="line"></span><br><span class="line">#pragma mark 图片数据</span><br><span class="line">@property (nonatomic,strong) NSData *data;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line">接下来将创建多个UIImageView并创建多个线程用于往UIImageView中填充图片。</span><br><span class="line"></span><br><span class="line">KCMainViewController.m</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">//  NSThread实现多线程</span><br><span class="line">//  MultiThread</span><br><span class="line">//</span><br><span class="line">//  Created by Kenshin Cui on 14-3-22.</span><br><span class="line">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;KCMainViewController.h&quot;</span><br><span class="line">#import &quot;KCImageData.h&quot;</span><br><span class="line">#define ROW_COUNT 5</span><br><span class="line">#define COLUMN_COUNT 3</span><br><span class="line">#define ROW_HEIGHT 100</span><br><span class="line">#define ROW_WIDTH ROW_HEIGHT</span><br><span class="line">#define CELL_SPACING 10</span><br><span class="line"></span><br><span class="line">@interface KCMainViewController ()&#123;</span><br><span class="line">    NSMutableArray *_imageViews;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation KCMainViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    [self layoutUI];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 界面布局</span><br><span class="line">-(void)layoutUI&#123;</span><br><span class="line">    //创建多个图片控件用于显示图片</span><br><span class="line">    _imageViews=[NSMutableArray array];</span><br><span class="line">    for (int r=0; r&lt;ROW_COUNT; r++) &#123;</span><br><span class="line">        for (int c=0; c&lt;COLUMN_COUNT; c++) &#123;</span><br><span class="line">            UIImageView *imageView=[[UIImageView alloc]initWithFrame:CGRectMake(c*ROW_WIDTH+(c*CELL_SPACING), r*ROW_HEIGHT+(r*CELL_SPACING                           ), ROW_WIDTH, ROW_HEIGHT)];</span><br><span class="line">            imageView.contentMode=UIViewContentModeScaleAspectFit;</span><br><span class="line">//            imageView.backgroundColor=[UIColor redColor];</span><br><span class="line">            [self.view addSubview:imageView];</span><br><span class="line">            [_imageViews addObject:imageView];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    UIButton *button=[UIButton buttonWithType:UIButtonTypeRoundedRect];</span><br><span class="line">    button.frame=CGRectMake(50, 500, 220, 25);</span><br><span class="line">    [button setTitle:@&quot;加载图片&quot; forState:UIControlStateNormal];</span><br><span class="line">    //添加方法</span><br><span class="line">    [button addTarget:self action:@selector(loadImageWithMultiThread) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">    [self.view addSubview:button];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 将图片显示到界面</span><br><span class="line">-(void)updateImage:(KCImageData *)imageData&#123;</span><br><span class="line">    UIImage *image=[UIImage imageWithData:imageData.data];</span><br><span class="line">    UIImageView *imageView= _imageViews[imageData.index];</span><br><span class="line">    imageView.image=image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 请求图片数据</span><br><span class="line">-(NSData *)requestData:(int )index&#123;</span><br><span class="line">    NSURL *url=[NSURL URLWithString:@&quot;http://images.apple.com/iphone-6/overview/images/biggest_right_large.png&quot;];</span><br><span class="line">    NSData *data=[NSData dataWithContentsOfURL:url];</span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 加载图片</span><br><span class="line">-(void)loadImage:(NSNumber *)index&#123;</span><br><span class="line">    //    NSLog(@&quot;%i&quot;,i);</span><br><span class="line">    //currentThread方法可以取得当前操作线程</span><br><span class="line">    NSLog(@&quot;current thread:%@&quot;,[NSThread currentThread]);</span><br><span class="line">    </span><br><span class="line">    int i=[index integerValue];</span><br><span class="line">    </span><br><span class="line">//    NSLog(@&quot;%i&quot;,i);//未必按顺序输出</span><br><span class="line">    </span><br><span class="line">    NSData *data= [self requestData:i];</span><br><span class="line">    </span><br><span class="line">    KCImageData *imageData=[[KCImageData alloc]init];</span><br><span class="line">    imageData.index=i;</span><br><span class="line">    imageData.data=data;</span><br><span class="line">    [self performSelectorOnMainThread:@selector(updateImage:) withObject:imageData waitUntilDone:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 多线程下载图片</span><br><span class="line">-(void)loadImageWithMultiThread&#123;</span><br><span class="line">    //创建多个线程用于填充图片</span><br><span class="line">    for (int i=0; i&lt;ROW_COUNT*COLUMN_COUNT; ++i) &#123;</span><br><span class="line">//        [NSThread detachNewThreadSelector:@selector(loadImage:) toTarget:self withObject:[NSNumber numberWithInt:i]];</span><br><span class="line">        NSThread *thread=[[NSThread alloc]initWithTarget:self selector:@selector(loadImage:) object:[NSNumber numberWithInt:i]];</span><br><span class="line">        thread.name=[NSString stringWithFormat:@&quot;myThread%i&quot;,i];//设置线程名称</span><br><span class="line">        [thread start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">通过NSThread的currentThread可以取得当前操作的线程，其中会记录线程名称name和编号number，需要注意主线程编号永远为1。多个线程虽然按顺序启动，但是实际执行未必按照顺序加载照片（loadImage:方法未必依次创建，可以通过在loadImage:中打印索引查看），因为线程启动后仅仅处于就绪状态，实际是否执行要由CPU根据当前状态调度。</span><br><span class="line"></span><br><span class="line">从上面的运行效果大家不难发现，图片并未按顺序加载，原因有两个：第一，每个线程的实际执行顺序并不一定按顺序执行（虽然是按顺序启动）；第二，每个线程执行时实际网络状况很可能不一致。当然网络问题无法改变，只能尽可能让网速更快，但是可以改变线程的优先级，让15个线程优先执行某个线程。线程优先级范围为0~1，值越大优先级越高，每个线程的优先级默认为0.5。修改图片下载方法如下，改变最后一张图片加载的优先级，这样可以提高它被优先加载的几率，但是它也未必就第一个加载。因为首先其他线程是先启动的，其次网络状况我们没办法修改：</span><br><span class="line"></span><br><span class="line">-(void)loadImageWithMultiThread&#123;</span><br><span class="line">    NSMutableArray *threads=[NSMutableArray array];</span><br><span class="line">    int count=ROW_COUNT*COLUMN_COUNT;</span><br><span class="line">    //创建多个线程用于填充图片</span><br><span class="line">    for (int i=0; i&lt;count; ++i) &#123;</span><br><span class="line">//        [NSThread detachNewThreadSelector:@selector(loadImage:) toTarget:self withObject:[NSNumber numberWithInt:i]];</span><br><span class="line">        NSThread *thread=[[NSThread alloc]initWithTarget:self selector:@selector(loadImage:) object:[NSNumber numberWithInt:i]];</span><br><span class="line">        thread.name=[NSString stringWithFormat:@&quot;myThread%i&quot;,i];//设置线程名称</span><br><span class="line">        if(i==(count-1))&#123;</span><br><span class="line">            thread.threadPriority=1.0;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            thread.threadPriority=0.0;</span><br><span class="line">        &#125;</span><br><span class="line">        [threads addObject:thread];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for (int i=0; i&lt;count; i++) &#123;</span><br><span class="line">        NSThread *thread=threads[i];</span><br><span class="line">        [thread start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line">在线程操作过程中可以让某个线程休眠等待，优先执行其他线程操作，而且在这个过程中还可以修改某个线程的状态或者终止某个指定线程。为了解决上面优先加载最后一张图片的问题，不妨让其他线程先休眠一会等待最后一个线程执行。修改图片加载方法如下即可：</span><br><span class="line"></span><br><span class="line">-(NSData *)requestData:(int )index&#123;</span><br><span class="line">    //对非最后一张图片加载线程休眠2秒</span><br><span class="line">    if (index!=(ROW_COUNT*COLUMN_COUNT-1)) &#123;</span><br><span class="line">        [NSThread sleepForTimeInterval:2.0];</span><br><span class="line">    &#125;</span><br><span class="line">    NSURL *url=[NSURL URLWithString:_imageNames[index]];</span><br><span class="line">    NSData *data=[NSData dataWithContentsOfURL:url];</span><br><span class="line"></span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br><span class="line">在这里让其他线程休眠2秒，此时你就会看到最后一张图片总是第一个加载（除非网速特别差）。</span><br><span class="line">线程状态分为isExecuting（正在执行）、isFinished（已经完成）、isCancellled（已经取消）三种。其中取消状态程序可以干预设置，只要调用线程的cancel方法即可。但是需要注意在主线程中仅仅能设置线程状态，并不能真正停止当前线程，如果要终止线程必须在线程中调用exist方法，这是一个静态方法，调用该方法可以退出当前线程。</span><br><span class="line"></span><br><span class="line">假设在图片加载过程中点击停止按钮让没有完成的线程停止加载，可以改造程序如下：</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">//  NSThread实现多线程</span><br><span class="line">//  MultiThread</span><br><span class="line">//</span><br><span class="line">//  Created by Kenshin Cui on 14-3-22.</span><br><span class="line">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;KCMainViewController.h&quot;</span><br><span class="line">#import &quot;KCImageData.h&quot;</span><br><span class="line">#define ROW_COUNT 5</span><br><span class="line">#define COLUMN_COUNT 3</span><br><span class="line">#define ROW_HEIGHT 100</span><br><span class="line">#define ROW_WIDTH ROW_HEIGHT</span><br><span class="line">#define CELL_SPACING 10</span><br><span class="line"></span><br><span class="line">@interface KCMainViewController ()&#123;</span><br><span class="line">    NSMutableArray *_imageViews;</span><br><span class="line">    NSMutableArray *_imageNames;</span><br><span class="line">    NSMutableArray *_threads;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation KCMainViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    [self layoutUI];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 界面布局</span><br><span class="line">-(void)layoutUI&#123;</span><br><span class="line">    //创建多个图片空间用于显示图片</span><br><span class="line">    _imageViews=[NSMutableArray array];</span><br><span class="line">    for (int r=0; r&lt;ROW_COUNT; r++) &#123;</span><br><span class="line">        for (int c=0; c&lt;COLUMN_COUNT; c++) &#123;</span><br><span class="line">            UIImageView *imageView=[[UIImageView alloc]initWithFrame:CGRectMake(c*ROW_WIDTH+(c*CELL_SPACING), r*ROW_HEIGHT+(r*CELL_SPACING                           ), ROW_WIDTH, ROW_HEIGHT)];</span><br><span class="line">            imageView.contentMode=UIViewContentModeScaleAspectFit;</span><br><span class="line">//            imageView.backgroundColor=[UIColor redColor];</span><br><span class="line">            [self.view addSubview:imageView];</span><br><span class="line">            [_imageViews addObject:imageView];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //加载按钮</span><br><span class="line">    UIButton *buttonStart=[UIButton buttonWithType:UIButtonTypeRoundedRect];</span><br><span class="line">    buttonStart.frame=CGRectMake(50, 500, 100, 25);</span><br><span class="line">    [buttonStart setTitle:@&quot;加载图片&quot; forState:UIControlStateNormal];</span><br><span class="line">    [buttonStart addTarget:self action:@selector(loadImageWithMultiThread) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">    [self.view addSubview:buttonStart];</span><br><span class="line">    </span><br><span class="line">    //停止按钮</span><br><span class="line">    UIButton *buttonStop=[UIButton buttonWithType:UIButtonTypeRoundedRect];</span><br><span class="line">    buttonStop.frame=CGRectMake(160, 500, 100, 25);</span><br><span class="line">    [buttonStop setTitle:@&quot;停止加载&quot; forState:UIControlStateNormal];</span><br><span class="line">    [buttonStop addTarget:self action:@selector(stopLoadImage) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">    [self.view addSubview:buttonStop];</span><br><span class="line">    </span><br><span class="line">    //创建图片链接</span><br><span class="line">    _imageNames=[NSMutableArray array];</span><br><span class="line">    [_imageNames addObject:@    for (int i=0; i&lt;IMAGE_COUNT; i++) &#123;</span><br><span class="line">        [_imageNames addObject:[NSString stringWithFormat:@&quot;http://images.cnblogs.com/cnblogs_com/kenshincui/613474/o_%i.jpg&quot;,i]];</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 将图片显示到界面</span><br><span class="line">-(void)updateImage:(KCImageData *)imageData&#123;</span><br><span class="line">    UIImage *image=[UIImage imageWithData:imageData.data];</span><br><span class="line">    UIImageView *imageView= _imageViews[imageData.index];</span><br><span class="line">    imageView.image=image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 请求图片数据</span><br><span class="line">-(NSData *)requestData:(int )index&#123;</span><br><span class="line">    NSURL *url=[NSURL URLWithString:_imageNames[index]];</span><br><span class="line">    NSData *data=[NSData dataWithContentsOfURL:url];</span><br><span class="line"></span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 加载图片</span><br><span class="line">-(void)loadImage:(NSNumber *)index&#123;</span><br><span class="line">    int i=[index integerValue];</span><br><span class="line"></span><br><span class="line">    NSData *data= [self requestData:i];</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    NSThread *currentThread=[NSThread currentThread];</span><br><span class="line">    </span><br><span class="line">//    如果当前线程处于取消状态，则退出当前线程</span><br><span class="line">    if (currentThread.isCancelled) &#123;</span><br><span class="line">        NSLog(@&quot;thread(%@) will be cancelled!&quot;,currentThread);</span><br><span class="line">        [NSThread exit];//取消当前线程</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    KCImageData *imageData=[[KCImageData alloc]init];</span><br><span class="line">    imageData.index=i;</span><br><span class="line">    imageData.data=data;</span><br><span class="line">    [self performSelectorOnMainThread:@selector(updateImage:) withObject:imageData waitUntilDone:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 多线程下载图片</span><br><span class="line">-(void)loadImageWithMultiThread&#123;</span><br><span class="line">    int count=ROW_COUNT*COLUMN_COUNT;</span><br><span class="line">    _threads=[NSMutableArray arrayWithCapacity:count];</span><br><span class="line">    </span><br><span class="line">    //创建多个线程用于填充图片</span><br><span class="line">    for (int i=0; i&lt;count; ++i) &#123;</span><br><span class="line">        NSThread *thread=[[NSThread alloc]initWithTarget:self selector:@selector(loadImage:) object:[NSNumber numberWithInt:i]];</span><br><span class="line">        thread.name=[NSString stringWithFormat:@&quot;myThread%i&quot;,i];//设置线程名称</span><br><span class="line">        [_threads addObject:thread];</span><br><span class="line">    &#125;</span><br><span class="line">    //循环启动线程</span><br><span class="line">    for (int i=0; i&lt;count; ++i) &#123;</span><br><span class="line">        NSThread *thread= _threads[i];</span><br><span class="line">        [thread start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 停止加载图片</span><br><span class="line">-(void)stopLoadImage&#123;</span><br><span class="line">    for (int i=0; i&lt;ROW_COUNT*COLUMN_COUNT; i++) &#123;</span><br><span class="line">        NSThread *thread= _threads[i];</span><br><span class="line">        //判断线程是否完成，如果没有完成则设置为取消状态</span><br><span class="line">        //注意设置为取消状态仅仅是改变了线程状态而言，并不能终止线程</span><br><span class="line">        if (!thread.isFinished) &#123;</span><br><span class="line">            [thread cancel];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">运行效果（点击加载大概1秒后点击停止加载）：</span><br><span class="line"></span><br><span class="line"> NSThreadEffect3</span><br><span class="line"></span><br><span class="line">使用NSThread在进行多线程开发过程中操作比较简单，但是要控制线程执行顺序并不容易（前面万不得已采用了休眠的方法），另外在这个过程中如果打印线程会发现循环几次就创建了几个线程，这在实际开发过程中是不得不考虑的问题，因为每个线程的创建也是相当占用系统开销的。</span><br><span class="line"></span><br><span class="line">扩展--NSObject分类扩展方法</span><br><span class="line"></span><br><span class="line">为了简化多线程开发过程，苹果官方对NSObject进行分类扩展(本质还是创建NSThread)，对于简单的多线程操作可以直接使用这些扩展方法。</span><br><span class="line"></span><br><span class="line">- (void)performSelectorInBackground:(SEL)aSelector withObject:(id)arg：在后台执行一个操作，本质就是重新创建一个线程执行当前方法。</span><br><span class="line"></span><br><span class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(id)arg waitUntilDone:(BOOL)wait：在指定的线程上执行一个方法，需要用户创建一个线程对象。</span><br><span class="line"></span><br><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(id)arg waitUntilDone:(BOOL)wait：在主线程上执行一个方法（前面已经使用过）。</span><br><span class="line"></span><br><span class="line">例如前面加载图多个图片的方法，可以改为后台线程执行：</span><br><span class="line"></span><br><span class="line">-(void)loadImageWithMultiThread&#123;</span><br><span class="line">    int count=ROW_COUNT*COLUMN_COUNT;</span><br><span class="line">    </span><br><span class="line">    for (int i=0; i&lt;count; ++i) &#123;</span><br><span class="line">        [self performSelectorInBackground:@selector(loadImage:) withObject:[NSNumber numberWithInt:i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line">使用NSOperation和NSOperationQueue进行多线程开发类似于C#中的线程池，只要将一个NSOperation（实际开中需要使用其子类NSInvocationOperation、NSBlockOperation）放到NSOperationQueue这个队列中线程就会依次启动。NSOperationQueue负责管理、执行所有的NSOperation，在这个过程中可以更加容易的管理线程总数和控制线程之间的依赖关系。</span><br><span class="line"></span><br><span class="line">NSOperation有两个常用子类用于创建线程操作：NSInvocationOperation和NSBlockOperation，两种方式本质没有区别，但是是后者使用Block形式进行代码组织，使用相对方便。</span><br><span class="line"></span><br><span class="line">NSInvocationOperation</span><br><span class="line"></span><br><span class="line">首先使用NSInvocationOperation进行一张图片的加载演示，整个过程就是：创建一个操作，在这个操作中指定调用方法和参数，然后加入到操作队列。其他代码基本不用修改，直接修加载图片方法如下：</span><br><span class="line"></span><br><span class="line">-(void)loadImageWithMultiThread&#123;</span><br><span class="line">    /*创建一个调用操作</span><br><span class="line">     object:调用方法参数</span><br><span class="line">    */</span><br><span class="line">    NSInvocationOperation *invocationOperation=[[NSInvocationOperation alloc]initWithTarget:self selector:@selector(loadImage) object:nil];</span><br><span class="line">    //创建完NSInvocationOperation对象并不会调用，它由一个start方法启动操作，但是注意如果直接调用start方法，则此操作会在主线程中调用，一般不会这么操作,而是添加到NSOperationQueue中</span><br><span class="line">//    [invocationOperation start];</span><br><span class="line">    </span><br><span class="line">    //创建操作队列</span><br><span class="line">    NSOperationQueue *operationQueue=[[NSOperationQueue alloc]init];</span><br><span class="line">    //注意添加到操作队后，队列会开启一个线程执行此操作</span><br><span class="line">    [operationQueue addOperation:invocationOperation];</span><br><span class="line">&#125;</span><br><span class="line">NSBlockOperation</span><br><span class="line"></span><br><span class="line">下面采用NSBlockOperation创建多个线程加载图片。</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">//  NSOperation实现多线程</span><br><span class="line">//  MultiThread</span><br><span class="line">//</span><br><span class="line">//  Created by Kenshin Cui on 14-3-22.</span><br><span class="line">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;KCMainViewController.h&quot;</span><br><span class="line">#import &quot;KCImageData.h&quot;</span><br><span class="line">#define ROW_COUNT 5</span><br><span class="line">#define COLUMN_COUNT 3</span><br><span class="line">#define ROW_HEIGHT 100</span><br><span class="line">#define ROW_WIDTH ROW_HEIGHT</span><br><span class="line">#define CELL_SPACING 10</span><br><span class="line"></span><br><span class="line">@interface KCMainViewController ()&#123;</span><br><span class="line">    NSMutableArray *_imageViews;</span><br><span class="line">    NSMutableArray *_imageNames;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation KCMainViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    [self layoutUI];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 界面布局</span><br><span class="line">-(void)layoutUI&#123;</span><br><span class="line">    //创建多个图片控件用于显示图片</span><br><span class="line">    _imageViews=[NSMutableArray array];</span><br><span class="line">    for (int r=0; r&lt;ROW_COUNT; r++) &#123;</span><br><span class="line">        for (int c=0; c&lt;COLUMN_COUNT; c++) &#123;</span><br><span class="line">            UIImageView *imageView=[[UIImageView alloc]initWithFrame:CGRectMake(c*ROW_WIDTH+(c*CELL_SPACING), r*ROW_HEIGHT+(r*CELL_SPACING                           ), ROW_WIDTH, ROW_HEIGHT)];</span><br><span class="line">            imageView.contentMode=UIViewContentModeScaleAspectFit;</span><br><span class="line">//            imageView.backgroundColor=[UIColor redColor];</span><br><span class="line">            [self.view addSubview:imageView];</span><br><span class="line">            [_imageViews addObject:imageView];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UIButton *button=[UIButton buttonWithType:UIButtonTypeRoundedRect];</span><br><span class="line">    button.frame=CGRectMake(50, 500, 220, 25);</span><br><span class="line">    [button setTitle:@&quot;加载图片&quot; forState:UIControlStateNormal];</span><br><span class="line">    //添加方法</span><br><span class="line">    [button addTarget:self action:@selector(loadImageWithMultiThread) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">    [self.view addSubview:button];</span><br><span class="line">    </span><br><span class="line">    //创建图片链接</span><br><span class="line">    _imageNames=[NSMutableArray array];</span><br><span class="line">    for (int i=0; i&lt;IMAGE_COUNT; i++) &#123;</span><br><span class="line">        [_imageNames addObject:[NSString stringWithFormat:@&quot;http://images.cnblogs.com/cnblogs_com/kenshincui/613474/o_%i.jpg&quot;,i]];</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 将图片显示到界面</span><br><span class="line">-(void)updateImageWithData:(NSData *)data andIndex:(int )index&#123;</span><br><span class="line">    UIImage *image=[UIImage imageWithData:data];</span><br><span class="line">    UIImageView *imageView= _imageViews[index];</span><br><span class="line">    imageView.image=image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 请求图片数据</span><br><span class="line">-(NSData *)requestData:(int )index&#123;</span><br><span class="line">    NSURL *url=[NSURL URLWithString:_imageNames[index]];</span><br><span class="line">    NSData *data=[NSData dataWithContentsOfURL:url];</span><br><span class="line"></span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 加载图片</span><br><span class="line">-(void)loadImage:(NSNumber *)index&#123;</span><br><span class="line">    int i=[index integerValue];</span><br><span class="line"></span><br><span class="line">    //请求数据</span><br><span class="line">    NSData *data= [self requestData:i];</span><br><span class="line">    NSLog(@&quot;%@&quot;,[NSThread currentThread]);</span><br><span class="line">    //更新UI界面,此处调用了主线程队列的方法（mainQueue是UI主线程）</span><br><span class="line">    [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">        [self updateImageWithData:data andIndex:i];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 多线程下载图片</span><br><span class="line">-(void)loadImageWithMultiThread&#123;</span><br><span class="line">    int count=ROW_COUNT*COLUMN_COUNT;</span><br><span class="line">    //创建操作队列</span><br><span class="line">    NSOperationQueue *operationQueue=[[NSOperationQueue alloc]init];</span><br><span class="line">    operationQueue.maxConcurrentOperationCount=5;//设置最大并发线程数</span><br><span class="line">    //创建多个线程用于填充图片</span><br><span class="line">    for (int i=0; i&lt;count; ++i) &#123;</span><br><span class="line">        //方法1：创建操作块添加到队列</span><br><span class="line">//        //创建多线程操作</span><br><span class="line">//        NSBlockOperation *blockOperation=[NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">//            [self loadImage:[NSNumber numberWithInt:i]];</span><br><span class="line">//        &#125;];</span><br><span class="line">//        //创建操作队列</span><br><span class="line">//</span><br><span class="line">//        [operationQueue addOperation:blockOperation];</span><br><span class="line">        </span><br><span class="line">        //方法2：直接使用操队列添加操作</span><br><span class="line">        [operationQueue addOperationWithBlock:^&#123;</span><br><span class="line">            [self loadImage:[NSNumber numberWithInt:i]];</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">对比之前NSThread加载张图片很发现核心代码简化了不少，这里着重强调两点：</span><br><span class="line"></span><br><span class="line">使用NSBlockOperation方法，所有的操作不必单独定义方法，同时解决了只能传递一个参数的问题。</span><br><span class="line">调用主线程队列的addOperationWithBlock:方法进行UI更新，不用再定义一个参数实体（之前必须定义一个KCImageData解决只能传递一个参数的问题）。</span><br><span class="line">使用NSOperation进行多线程开发可以设置最大并发线程，有效的对线程进行了控制（上面的代码运行起来你会发现打印当前进程时只有有限的线程被创建，如上面的代码设置最大线程数为5，则图片基本上是五个一次加载的）。</span><br><span class="line">线程执行顺序</span><br><span class="line"></span><br><span class="line">前面使用NSThread很难控制线程的执行顺序，但是使用NSOperation就容易多了，每个NSOperation可以设置依赖线程。假设操作A依赖于操作B，线程操作队列在启动线程时就会首先执行B操作，然后执行A。对于前面优先加载最后一张图的需求，只要设置前面的线程操作的依赖线程为最后一个操作即可。修改图片加载方法如下：</span><br><span class="line"></span><br><span class="line">-(void)loadImageWithMultiThread&#123;</span><br><span class="line">    int count=ROW_COUNT*COLUMN_COUNT;</span><br><span class="line">    //创建操作队列</span><br><span class="line">    NSOperationQueue *operationQueue=[[NSOperationQueue alloc]init];</span><br><span class="line">    operationQueue.maxConcurrentOperationCount=5;//设置最大并发线程数</span><br><span class="line">    </span><br><span class="line">    NSBlockOperation *lastBlockOperation=[NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        [self loadImage:[NSNumber numberWithInt:(count-1)]];</span><br><span class="line">    &#125;];</span><br><span class="line">    //创建多个线程用于填充图片</span><br><span class="line">    for (int i=0; i&lt;count-1; ++i) &#123;</span><br><span class="line">        //方法1：创建操作块添加到队列</span><br><span class="line">        //创建多线程操作</span><br><span class="line">        NSBlockOperation *blockOperation=[NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">            [self loadImage:[NSNumber numberWithInt:i]];</span><br><span class="line">        &#125;];</span><br><span class="line">        //设置依赖操作为最后一张图片加载操作</span><br><span class="line">        [blockOperation addDependency:lastBlockOperation];</span><br><span class="line">        </span><br><span class="line">        [operationQueue addOperation:blockOperation];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    //将最后一个图片的加载操作加入线程队列</span><br><span class="line">    [operationQueue addOperation:lastBlockOperation];</span><br><span class="line">&#125;</span><br><span class="line">运行效果：</span><br><span class="line"></span><br><span class="line">NSOperationEffect</span><br><span class="line"></span><br><span class="line">可以看到虽然加载最后一张图片的操作最后被加入到操作队列，但是它却是被第一个执行的。操作依赖关系可以设置多个，例如A依赖于B、B依赖于C…但是千万不要设置为循环依赖关系（例如A依赖于B，B依赖于C，C又依赖于A），否则是不会被执行的。</span><br></pre></td></tr></table></figure>
<h3 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line">GCD(Grand Central Dispatch)是基于C语言开发的一套多线程开发机制，也是目前苹果官方推荐的多线程开发方法。前面也说过三种开发中GCD抽象层次最高，当然是用起来也最简单，只是它基于C语言开发，并不像NSOperation是面向对象的开发，而是完全面向过程的。对于熟悉C#异步调用的朋友对于GCD学习起来应该很快，因为它与C#中的异步调用基本是一样的。这种机制相比较于前面两种多线程开发方式最显著的优点就是它对于多核运算更加有效。</span><br><span class="line"></span><br><span class="line">GCD中也有一个类似于NSOperationQueue的队列，GCD统一管理整个队列中的任务。但是GCD中的队列分为并行队列和串行队列两类：</span><br><span class="line"></span><br><span class="line">串行队列：只有一个线程，加入到队列中的操作按添加顺序依次执行。</span><br><span class="line">并发队列：有多个线程，操作进来之后它会将这些队列安排在可用的处理器上，同时保证先进来的任务优先处理。</span><br><span class="line">其实在GCD中还有一个特殊队列就是主队列，用来执行主线程上的操作任务（从前面的演示中可以看到其实在NSOperation中也有一个主队列）。</span><br><span class="line"></span><br><span class="line">串行队列</span><br><span class="line"></span><br><span class="line">使用串行队列时首先要创建一个串行队列，然后调用异步调用方法，在此方法中传入串行队列和线程操作即可自动执行。下面使用线程队列演示图片的加载过程，你会发现多张图片会按顺序加载，因为当前队列中只有一个线程。</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">//  GCD实现多线程</span><br><span class="line">//  MultiThread</span><br><span class="line">//</span><br><span class="line">//  Created by Kenshin Cui on 14-3-22.</span><br><span class="line">//  Copyright (c) 2014年 Kenshin Cui. All rights reserved.</span><br><span class="line">//</span><br><span class="line"></span><br><span class="line">#import &quot;KCMainViewController.h&quot;</span><br><span class="line">#import &quot;KCImageData.h&quot;</span><br><span class="line">#define ROW_COUNT 5</span><br><span class="line">#define COLUMN_COUNT 3</span><br><span class="line">#define ROW_HEIGHT 100</span><br><span class="line">#define ROW_WIDTH ROW_HEIGHT</span><br><span class="line">#define CELL_SPACING 10</span><br><span class="line"></span><br><span class="line">@interface KCMainViewController ()&#123;</span><br><span class="line">    NSMutableArray *_imageViews;</span><br><span class="line">    NSMutableArray *_imageNames;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation KCMainViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    [self layoutUI];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 界面布局</span><br><span class="line">-(void)layoutUI&#123;</span><br><span class="line">    //创建多个图片控件用于显示图片</span><br><span class="line">    _imageViews=[NSMutableArray array];</span><br><span class="line">    for (int r=0; r&lt;ROW_COUNT; r++) &#123;</span><br><span class="line">        for (int c=0; c&lt;COLUMN_COUNT; c++) &#123;</span><br><span class="line">            UIImageView *imageView=[[UIImageView alloc]initWithFrame:CGRectMake(c*ROW_WIDTH+(c*CELL_SPACING), r*ROW_HEIGHT+(r*CELL_SPACING                           ), ROW_WIDTH, ROW_HEIGHT)];</span><br><span class="line">            imageView.contentMode=UIViewContentModeScaleAspectFit;</span><br><span class="line">//            imageView.backgroundColor=[UIColor redColor];</span><br><span class="line">            [self.view addSubview:imageView];</span><br><span class="line">            [_imageViews addObject:imageView];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UIButton *button=[UIButton buttonWithType:UIButtonTypeRoundedRect];</span><br><span class="line">    button.frame=CGRectMake(50, 500, 220, 25);</span><br><span class="line">    [button setTitle:@&quot;加载图片&quot; forState:UIControlStateNormal];</span><br><span class="line">    //添加方法</span><br><span class="line">    [button addTarget:self action:@selector(loadImageWithMultiThread) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">    [self.view addSubview:button];</span><br><span class="line">    </span><br><span class="line">    //创建图片链接</span><br><span class="line">    _imageNames=[NSMutableArray array];</span><br><span class="line">    for (int i=0; i&lt;ROW_COUNT*COLUMN_COUNT; i++) &#123;</span><br><span class="line">        [_imageNames addObject:[NSString stringWithFormat:@&quot;http://images.cnblogs.com/cnblogs_com/kenshincui/613474/o_%i.jpg&quot;,i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 将图片显示到界面</span><br><span class="line">-(void)updateImageWithData:(NSData *)data andIndex:(int )index&#123;</span><br><span class="line">    UIImage *image=[UIImage imageWithData:data];</span><br><span class="line">    UIImageView *imageView= _imageViews[index];</span><br><span class="line">    imageView.image=image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 请求图片数据</span><br><span class="line">-(NSData *)requestData:(int )index&#123;</span><br><span class="line">    NSURL *url=[NSURL URLWithString:_imageNames[index]];</span><br><span class="line">    NSData *data=[NSData dataWithContentsOfURL:url];</span><br><span class="line"></span><br><span class="line">    return data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 加载图片</span><br><span class="line">-(void)loadImage:(NSNumber *)index&#123;</span><br><span class="line">    </span><br><span class="line">    //如果在串行队列中会发现当前线程打印变化完全一样，因为他们在一个线程中</span><br><span class="line">    NSLog(@&quot;thread is :%@&quot;,[NSThread currentThread]);</span><br><span class="line">    </span><br><span class="line">    int i=[index integerValue];</span><br><span class="line">    //请求数据</span><br><span class="line">    NSData *data= [self requestData:i];</span><br><span class="line">    //更新UI界面,此处调用了GCD主线程队列的方法</span><br><span class="line">    dispatch_queue_t mainQueue= dispatch_get_main_queue();</span><br><span class="line">    dispatch_sync(mainQueue, ^&#123;</span><br><span class="line">        [self updateImageWithData:data andIndex:i];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark 多线程下载图片</span><br><span class="line">-(void)loadImageWithMultiThread&#123;</span><br><span class="line">    int count=ROW_COUNT*COLUMN_COUNT;</span><br><span class="line">    </span><br><span class="line">    /*创建一个串行队列</span><br><span class="line">     第一个参数：队列名称</span><br><span class="line">     第二个参数：队列类型</span><br><span class="line">    */</span><br><span class="line">    dispatch_queue_t serialQueue=dispatch_queue_create(&quot;myThreadQueue1&quot;, DISPATCH_QUEUE_SERIAL);//注意queue对象不是指针类型</span><br><span class="line">    //创建多个线程用于填充图片</span><br><span class="line">    for (int i=0; i&lt;count; ++i) &#123;</span><br><span class="line">        //异步执行队列任务</span><br><span class="line">        dispatch_async(serialQueue, ^&#123;</span><br><span class="line">            [self loadImage:[NSNumber numberWithInt:i]];</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    //非ARC环境请释放</span><br><span class="line">//    dispatch_release(seriQueue);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line">运行效果：</span><br><span class="line"></span><br><span class="line">GCDEffect1 </span><br><span class="line"></span><br><span class="line">在上面的代码中更新UI还使用了GCD方法的主线程队列dispatch_get_main_queue()，其实这与前面两种主线程更新UI没有本质的区别。</span><br><span class="line"></span><br><span class="line">并发队列</span><br><span class="line"></span><br><span class="line">并发队列同样是使用dispatch_queue_create()方法创建，只是最后一个参数指定为DISPATCH_QUEUE_CONCURRENT进行创建，但是在实际开发中我们通常不会重新创建一个并发队列而是使用dispatch_get_global_queue()方法取得一个全局的并发队列（当然如果有多个并发队列可以使用前者创建）。下面通过并行队列演示一下多个图片的加载。代码与上面串行队列加载类似，只需要修改照片加载方法如下：</span><br><span class="line"></span><br><span class="line">-(void)loadImageWithMultiThread&#123;</span><br><span class="line">    int count=ROW_COUNT*COLUMN_COUNT;</span><br><span class="line">    </span><br><span class="line">    /*取得全局队列</span><br><span class="line">     第一个参数：线程优先级</span><br><span class="line">     第二个参数：标记参数，目前没有用，一般传入0</span><br><span class="line">    */</span><br><span class="line">    dispatch_queue_t globalQueue=dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">    //创建多个线程用于填充图片</span><br><span class="line">    for (int i=0; i&lt;count; ++i) &#123;</span><br><span class="line">        //异步执行队列任务</span><br><span class="line">        dispatch_async(globalQueue, ^&#123;</span><br><span class="line">            [self loadImage:[NSNumber numberWithInt:i]];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行效果：</span><br><span class="line"></span><br><span class="line">GCDEffect2 </span><br><span class="line"></span><br><span class="line">细心的朋友肯定会思考，既然可以使用dispatch_async()异步调用方法，是不是还有同步方法，确实如此，在GCD中还有一个dispatch_sync()方法。假设将上面的代码修改为同步调用，可以看到如下效果：</span><br><span class="line"></span><br><span class="line">GCDEffect3</span><br><span class="line"></span><br><span class="line">可以看点击按钮后按钮无法再次点击，因为所有图片的加载全部在主线程中（可以打印线程查看），主线程被阻塞，造成图片最终是一次性显示。可以得出结论：</span><br><span class="line"></span><br><span class="line">在GDC中一个操作是多线程执行还是单线程执行取决于当前队列类型和执行方法，只有队列类型为并行队列并且使用异步方法执行时才能在多个线程中执行。</span><br><span class="line">串行队列可以按顺序执行，并行队列的异步方法无法确定执行顺序。</span><br><span class="line">UI界面的更新最好采用同步方法，其他操作采用异步方法。</span><br><span class="line">其他任务执行方法</span><br><span class="line"></span><br><span class="line">GCD执行任务的方法并非只有简单的同步调用方法和异步调用方法，还有其他一些常用方法：</span><br><span class="line"></span><br><span class="line">dispatch_apply():重复执行某个任务，但是注意这个方法没有办法异步执行（为了不阻塞线程可以使用dispatch_async()包装一下再执行）。</span><br><span class="line">dispatch_once():单次执行一个任务，此方法中的任务只会执行一次，重复调用也没办法重复执行（单例模式中常用此方法）。</span><br><span class="line">dispatch_time()：延迟一定的时间后执行。</span><br><span class="line">dispatch_barrier_async()：使用此方法创建的任务首先会查看队列中有没有别的任务要执行，如果有，则会等待已有任务执行完毕再执行；同时在此方法后添加的任务必须等待此方法中任务执行后才能执行。（利用这个方法可以控制执行顺序，例如前面先加载最后一张图片的需求就可以先使用这个方法将最后一张图片加载的操作添加到队列，然后调用dispatch_async()添加其他图片加载任务）</span><br><span class="line">dispatch_group_async()：实现对任务分组管理，如果一组任务全部完成可以通过dispatch_group_notify()方法获得完成通知（需要定义dispatch_group_t作为分组标识）。</span><br></pre></td></tr></table></figure>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>请简单描述一下队列和多线程的使用原理<br>在iOS中队列分为以下几种：<br>• 串行队列：队列中的任务只会顺序执行</p>
<p>dispatch_queue_t q = dispatch_queue_create(“…”, DISPATCH_QUEUE_SERIAL);</p>
<p>• 并行队列： 队列中的任务通常会并发执行</p>
<p>dispatch_queue_t q = dispatch_queue_create(“……”, DISPATCH_QUEUE_CONCURRENT);</p>
<p>• 全局队列：是系统的，直接拿过来（GET）用就可以；与并行队列类似</p>
<p>dispatch_queue_t q = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</p>
<p>• 主队列：每一个应用程序对应唯一一个主队列，直接GET即可；在多线程开发中，使用主队列更新UI</p>
<p>dispatch_queue_t q = dispatch_get_main_queue();</p>
<p>上面这四种是针对GCD来讲的，串行队列中的任务只能一个个地执行，在前一个没有执行完毕之前，下一个只能等待。并行队列可以并发地执行任务，因此多个任务之间执行的顺序不能确定，当添加一个新的任务时，交由GCD来判断是否要创建新的新的线程。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/15/Block/" itemprop="url">
                  Block
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-06-15T11:59:08+08:00" content="2016-06-15">
              2016-06-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>block在iOS编程中有着非常重要的作用，目前对block的理解只存在于表面的应用上，希望以后不断补充这篇介绍。</p>
</blockquote>
<h3 id="block是什么"><a href="#block是什么" class="headerlink" title="block是什么"></a>block是什么</h3><ul>
<li>简单定义：能持有作用域变量的匿名函数</li>
<li>匿名函数就是没有名称的函数，C 语言的标准不允许存在这样的函数，而通过 Block，源代码中就可以使用匿名函数了。</li>
<li>能持有作用域变量就是指 Block 能够获得其所在作用域的变量。其中其所在作用域的变量就包括：局部变量（自动变量）、函数的参数、静态局部变量、静态全局变量、全局变量。</li>
<li>block的作用：用来保存某一段代码。可以在恰当的时间取出来调用。功能点类似于函数和方法，是iOS中一种比较特殊的数据类型</li>
<li>Block 能够让我们创建明显的代码片段，并且可以像参数那样传递给方法或函数。在 Objective-C 中</li>
<li>Block 就像对象一样，能够被添加到集合中（比如：NSArray、NSDictionary）。Block 能够获得其所在作用域的变量</li>
</ul>
<h3 id="Block-语法形式"><a href="#Block-语法形式" class="headerlink" title="Block 语法形式"></a>Block 语法形式</h3><p>Block 的语法遵循如下形式：<br>^ 返回值类型 参数列表 表达式</p>
<p>一些示例：<br><img src="http://ww1.sinaimg.cn/mw1024/bc254b75jw1f4vvaa9wcij20fg06cjsr.jpg" alt=""></p>
<p>^(传入参数列){行为主体};</p>
<p>^(int a){return a*a;}; </p>
<p>int result = ^(int a){return a*a;};<br>NSLog(@”%d”, result);</p>
<p>// 一个最简单的 block：<br>^{<br>    NSLog(@”This is a block”);<br>}<br>// 不省略的 block：<br>^void (void) {<br>    NSLog(@”This is a block”);<br>}<br>// 普通的 block：<br>^int (int a, int b) {<br>    NSLog(@”a is %d, b is %d”, a, b);<br>    return a + b;<br>}</p>
<h3 id="一些简单的使用"><a href="#一些简单的使用" class="headerlink" title="一些简单的使用"></a>一些简单的使用</h3><ul>
<li>最简单的 Block</li>
</ul>
<p>声明和定义一个不返回任何值，不接受任何参数的 Block：</p>
<p>// 完整的写法：<br>//// 声明<br>void (^simpleBlock)(void);<br>//// 定义<br>simpleBlock = ^{<br>    NSLog(@”This is a block”);<br>};<br>//// 声明、定义一起<br>void (^simpleBlock)(void) = ^{<br>    NSLog(@”This is a block”);<br>};<br>// 调用 block<br>simpleBlock();</p>
<ul>
<li>带参数和返回值的 Block</li>
</ul>
<p>下面的 Block，接受两个 double 参数，返回一个 double 值：</p>
<p>// 声明<br>double (^multiplyTwoValues)(double, double);<br>// 定义<br>double (^multiplyTwoValues)(double, double) =<br>                          ^(double firstValue, double secondValue) {<br>                              return firstValue * secondValue;<br>                          };<br>// 调用<br>double result = multiplyTwoValues(2,4);<br>NSLog(@”The result is %f”, result);</p>
<ul>
<li>Block 作为参数时的缩写</li>
</ul>
<p>Block 作为参数时的缩写如 Block 语法规则所约定那样。</p>
<p>// Block 没有参数，则 <code>()</code> 可以省略：<br>[UIView animateViewDuration:5.0 animation:^() { // 这个 block 没有参数，这里的 () 就可以省略。<br>    view.opacity = 0.5;<br>}];<br>// 如果 Block 中返回值的类型根据 return 后的内容能明显推出，那么可以省略：<br>NSSet<em> mySet = …;<br>NSSet</em> matches = [mySet objectsPassingTest:^BOOL(id obj, …) { // 根据return语句，这个block的返回值明显是BOOL，所以这里可以省略BOOL。<br>    return [obj isKindOfClass:[UIView class]]; // 返回值是 BOOL，很明显。<br>}];</p>
<ul>
<li>把 Block 传递给方法或函数</li>
</ul>
<p>// 调用带 block 参数的方法：</p>
<ul>
<li><p>(IBAction)fetchRemoteInformation:(id)sender {<br>  [self showProgressIndicator];</p>
<p>  XYZWebTask *task = …</p>
<p>  [task beginTaskWithCallbackBlock:^{</p>
<pre><code>[self hideProgressIndicator];
</code></pre><p>  }];<br>}<br>// 声明带 block 参数的方法：</p>
</li>
<li>(void)beginTaskWithCallbackBlock:(void (^)(void))callbackBlock;<br>// 方法的具体实现：</li>
<li>(void)beginTaskWithCallbackBlock:(void (^)(void))callbackBlock {<br>  …<br>  callbackBlock();<br>}<br>苹果的建议是在一个方法中最好只使用一个 block 变量，并且如果这个方法如果还带有其他非 block 变量，那么 block 变量应该放在最后一个。</li>
</ul>
<ul>
<li>使用 typedef 来简化 Block 定义</li>
</ul>
<p>上面的 Block 类型的变量在使用时，记述方式会一眼看上去有点不够简洁，这时候我们也可以用 typedef 来解决这个问题。</p>
<p>// typedef 一个 block<br>typedef void (^XYZSimpleBlock)(void);<br>// 使用 1<br>XYZSimpleBlock anotherBlock = ^{<br>    …<br>};<br>// 使用 2</p>
<ul>
<li>(void)beginFetchWithCallbackBlock:(XYZSimpleBlock)callbackBlock {<br>  …<br>  callbackBlock();<br>}<br>来看一个用 typedef 简化复杂 Block 定义的例子，下面的定义的名为 complexBlock 的变量是一个 block，这个 block 接受一个 block 作为参数，并且返回一个 block：</li>
</ul>
<p>// 简化前：<br>void (^(^complexBlock)(void (^)(void)))(void) = ^ (void (^aBlock)(void)) {<br>    …<br>    return ^{<br>        …<br>    };<br>};<br>// 使用上面 typedef 的 XYZSimpleBlock 简化后：<br>XYZSimpleBlock (^betterBlock)(XYZSimpleBlock) = ^ (XYZSimpleBlock aBlock) {<br>    …<br>    return ^{<br>        …<br>    };<br>};</p>
<ul>
<li>定义属性来持有 Block</li>
</ul>
<p>使用 copy，因为 Block 要持有它原本所在作用域的其他外面的变量：</p>
<p>@interface XYZObject : NSObject<br>@property (copy) void (^blockProperty)(void);<br>@end<br>// setter 方法和调用<br>self.blockProperty = ^{<br>    …<br>};<br>self.blockProperty();<br>// 使用 typedef 简化<br>typedef void (^XYZSimpleBlock)(void);</p>
<p>@interface XYZObject : NSObject<br>@property (copy) XYZSimpleBlock blockProperty;<br>@end</p>
<h3 id="block的使用场景"><a href="#block的使用场景" class="headerlink" title="block的使用场景"></a>block的使用场景</h3><ul>
<li>Block 简化枚举</li>
</ul>
<p>// NSArray 的一个方法，接受一个 block 作为参数，这个 block 会在该方法里每枚举一个对象时被调用一次：</p>
<ul>
<li>(void)enumerateObjectsUsingBlock:(void (^)(id obj, NSUInteger idx, BOOL <em>stop))block;<br>// 这个 block 接受三个参数，前两个是当前的对象和其 index，后面的 BOOL 值可以用来控制什么时候停止该枚举。<br>NSArray </em>array = …<br>[array enumerateObjectsUsingBlock:^ (id obj, NSUInteger idx, BOOL <em>stop) {<br>  NSLog(@”Object at index %lu is %@”, idx, obj);<br>}];<br>[array enumerateObjectsUsingBlock:^ (id obj, NSUInteger idx, BOOL </em>stop) {<br>  if (…) {<pre><code>*stop = YES;
</code></pre>  }<br>}];</li>
</ul>
<ul>
<li>Block 简化并发调用</li>
</ul>
<p>Block 和 Operation Queue 一起用</p>
<p>NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{<br>    …<br>}];</p>
<ul>
<li>Block 和 GCD 一起用</li>
</ul>
<p>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);<br>dispatch_async(queue, ^{<br>    NSLog(@”Block for asynchronous execution”);<br>});</p>
<p>GCD主要使用block来代替委托模式,使程序变得简洁,同时运行效率也得到提高.<br>   static int clickNum = 0;<br>   self.Mylabel = [[UILabel alloc]init];<br>   while (clickNum &lt;20) {<br>   dispatch_async(dispatch_get_main_queue(), ^{<br>   self.Mylabel.text = [NSString stringWithFormat:@”%d”,clickNum++];//UI的绘制必须在主线程中<br>   });<br>   [NSThread sleepForTimeInterval:1];<br>     }</p>
<p>cocoaTouch框架下动画效果的Block的调用<br>[UIView transitionWithView:self.view<br>                          duration:0.2<br>                           options:UIViewAnimationOptionTransitionFlipFromLeft<br>                        animations:^{ [self.view addSubview:yellowView.view]; }<br>                        completion:NULL];</p>
<ul>
<li>Block 的使用场景小结</li>
</ul>
<p>Enumeration (像我们上面看到的 NSArray 的枚举接口)<br>View Animations (animations)<br>Sorting (在排序时在 Block 中实现比较逻辑)<br>Notification (当某些事件被触发时，执行对应的 Block)<br>Error handlers (作为错误事件的 Handler)<br>Completion handlers (作为某个任务完成时的 Handler)<br>Multithreading (在 Grand Central Dispatch (GCD) API 中使用)</p>
<h3 id="一些补充"><a href="#一些补充" class="headerlink" title="一些补充"></a>一些补充</h3><ul>
<li>函数内部使用<br>在函数内部定义并实现的block有点类似于java的匿名内部类，这种block也只能作用于当前函数。<br>示例：<br>-(void)testBlock{<br>  void (^blockTest)(int) = ^(int num){<pre><code>NSLog(@&quot;num:%d&quot;,num);
</code></pre>  };<br>  blockTest(2);<br>}</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/15/iOS中的MVC概念/" itemprop="url">
                  iOS中的MVC概念
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-06-15T11:41:21+08:00" content="2016-06-15">
              2016-06-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>在转一篇对MVC的总结文章</p>
</blockquote>
<p><a href="http://www.samirchen.com/mvc-in-ios/" target="_blank" rel="external">原版</a></p>
<ul>
<li>Model</li>
</ul>
<p>Model 是 What your application is(but not how it is desplayed)，各种数据以及它们之间的逻辑等都是Model，Model是独立于UI的。</p>
<ul>
<li>Controller</li>
</ul>
<p>Controller 是 How your Model is presented to the user (UI logic)，即UI逻辑，Controller来把Mode的数据和逻辑表达出来，绘制、展示到屏幕上。</p>
<ul>
<li>View</li>
</ul>
<p>View 是 Your Controller’s minions，是Controller要用到的各种基础性的UI元素（Genetic UI Element），是Controller表达Model数据和逻辑用到的工具。</p>
<p>总的来说，就是 Controller 用 View 来把 Model 表达到屏幕上。</p>
<ul>
<li>M、V、C之间如何对话</li>
</ul>
<p>Controller —&gt; Model (OK)</p>
<p>Controller 对相应的 Model 说话是很正常的。</p>
<p>Controller —&gt; Vew (OK)</p>
<p>Controller 对相应的 View 说话也是很正常的。</p>
<p>Model &lt;—&gt; View (Never)</p>
<p>Model 和 View 之间则永远不要对话！</p>
<p>View —&gt; Controller (Limited)</p>
<p>View 一般不要对 Controller 直接说话。但有时候，确实有这个需要，所以有以下几种方式让View对Controller说话：</p>
<p>action - target</p>
<p>Controller 在自己上面放了 target 明确告诉 View 的 action 去和这个 target 对话。比如一个 button 的 touch 动作触发时去告诉 Controller 的 target 这个 action，让 Controller 在这个 action 中做点什么。其实 View 这时候是不知道关于这个 target 背后的这个 Controller 的任何信息的。所以</p>
<p>It is a blind, simple, structured way for the view to communicate with the controller.</p>
<p>delegate</p>
<p>View 和 Controller 对话还有更复杂的方式，比如当一个 ScrollView 被滑动了，滑动停止时，View 需要告诉 Controller 滑动停止了，像我们常见的 will，should，did 类的方法，它们就是在 Controller 里设置了代理 Delegate 去响应这些消息，对 View 来说，它也不知道 Controller 的具体信息，它只是知道 Controller 能响应它的那些 will，should，did 类的消息。要使用 Delegate 模式，就涉及到 protocal。</p>
<p>A protocal is a blind way to talk to another object.</p>
<p>datasource</p>
<p>View 不持有它所显示的数据，这些数据应该是属于 Model 的。View 常常通过 datasource 来询问数据，它通常会向 datasource 询问 count，data at * index 之类的消息，其实 datasource 就是另一种 delegate，很明显 Controller 应该作为 View 的 datasource delegate，而不是 Model。当 View 询问数据相关的消息时，Controller 则先去询问 Model 然后再作为 datasource delegate 来响应 View。</p>
<p>Data source is just a kind of delegate, it’s a specific kind of delegate for getting data.</p>
<p>Model —&gt; Controller (Limited)</p>
<p>Model 一般也不要对 Controller 直接对话。但有时候也有需求，所以提供了一些机制来满足这些需求：</p>
<p>Notification &amp; KVO(Key Value Observing)</p>
<p>有时候 Model 中的某些东西改变了，比如数据改变了、网络连通了等，它需要告诉 Controller。这时候我们用 “radio station”，类似广播机制去通知任何对这信息感兴趣的对象，这就是常用的 Notification(通知中心) &amp; KVO(Key Value Observing，键值观察)。这就相当于 Model 在广播里吼 “我Model这某时某刻某些东东发生变动了，大家快来看啊！”，这时 Controller 就调到那个广播频道听到了，知道 Model 那某些东东发生变化了，然后它对此感兴趣就通过 Control—&gt;Model 这个途径去 Model 那取那些发生变化的数据。</p>
<p>MVC对话示意图<br><img src="http://www.samirchen.com/images/mvc-in-ios/mvc-communication.png" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/15/iOS应用程序的生命周期/" itemprop="url">
                  iOS应用程序的生命周期
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-06-15T09:34:12+08:00" content="2016-06-15">
              2016-06-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文介绍iOS应用程序的生命周期</p>
</blockquote>
<p><img src="http://ww4.sinaimg.cn/mw1024/bc254b75jw1f4vo55m8hkj20yx14ktez.jpg" alt=""></p>
<p><img src="http://ww2.sinaimg.cn/mw1024/bc254b75jw1f4vo77jo3yj20ft07xacb.jpg" alt=""></p>
<h3 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h3><p>上面两张图都描了一个应用的生命周期。<br>首先是打开程序执行main函数。</p>
<ul>
<li><p>main函数做了什么呢？<br>int main(int argc, char * argv[]) {<br>  @autoreleasepool {</p>
<pre><code>return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
</code></pre><p>  }<br>}</p>
</li>
<li><p>原型函数如下：<br>UIKIT_EXTERN int UIApplicationMain(int argc, char <em>argv[], NSString </em>principalClassName, NSString *delegateClassName);</p>
</li>
</ul>
<p>前两个参数：argc和argv：是ISO C标准的main函数的参数，直接传递给UIApplicationMain进行相关处理。参数包含应用程序何时从系统启动等信息。这些参数是由UIKit的基础设施解析，否则可以忽略不计。 </p>
<p>后两个参数：分别表示程序的主要类(principal class)和代理类(delegate class)。如果主要类(principal class)为nil，将从Info.plist中获取，如果Info.plist中不存在对应的key，则默认为UIApplication；如果代理类(delegate class)将在新建工程时创建。代理类关乎着应用程序的生命周期。</p>
<p>Main<br>↓<br>创建Uiapplicaiton 对象（如果为nil,则用UIApplication类作为默认值），并创建一个delegate（NSStringFromClass([AppDelegate class])，一般新建项目时候会自动生成，当然也可以更改别的类为代理对象）<br>对象，并将该对象赋值给UIApplication对象中的delegate属性<br>↓<br>开启事件循环   Main Runloop   (可以暂时理解为一个死循环，按照顺序进行事件处理)<br>↓<br>监听（用户交互时产生的事件，由UIApplication对象来分发给control objects对应的target objects来处理并且管理整个事件循环，而一些关于app运行时重要事件委托给app delegate来处理。）</p>
<p>以上就是启动过程。</p>
<h3 id="启动过后的处理过程"><a href="#启动过后的处理过程" class="headerlink" title="启动过后的处理过程"></a>启动过后的处理过程</h3><p><img src="http://ww1.sinaimg.cn/mw1024/bc254b75jw1f4vo551h0sj20ed09l75c.jpg" alt=""><br>UIApplication对象<br>交互时产生的事件交由UIApplication对象来分发给control objects(UIControl)对应的target objects来处理并且管理整个事件循环，而一些关于app运行时重要事件委托给app delegate来处理。</p>
<p>App delegate对象<br>App delegate对象遵循UIApplicationDelegate协议，响应app运行时重要事件(app启动、app内存不足、app终止、切换到另一个app、切回app)，主要用于app在启动时初始化一些重要数据结构；例如，初始化UIWindow，设置一些属性，为window添加rootViewController。</p>
<p>View controller对象<br>View Controller有一个view属性是view层次结构中的根view，你可以添加子view来构建复杂的view；controller有一些viewDidLoad、viewWillAppear等方法来管理view的生命周期；由于它继承UIResponder，所有还会响应和处理用户事件。</p>
<p>Documents和data model对象<br>data model对象主要用来存储数据。例如，饿了么app在搜索切换地址后，有历史记录搜索地址历史，当app下次启动时，读取和显示搜索地址历史。</p>
<p>document对象(继承UIDocument)用来管理一些或所有的data model对象。document对象并不是必须的，但提供一种方便的方式来分组属于单个文件或多个文件的数据。</p>
<p>UIWindow对象<br>UIWindow对象位于view层次结构中的最顶层，它充当一个基本容器而不显示内容，如果想显示内容，添加一个content view到window。<br>它也是继承UIResponder，所以它也是会响应和处理用户事件。</p>
<p>View、control、layer对象<br>View对象可以通过addSubview和removeFromSuperview 等方法管理view的层次结构，使用layoutSubviews、layoutIfNeeded和setNeedsLayout等方法布局view的层次结构，当你发现系统提供view已经满足不了你想要的外观需求时，可以重写drawRect方法或通过layer属性来构造复杂的图形外观和动画。还有一点，UIView也是继承UIResponder，所以也能够处理用户事件。</p>
<p>Control对象通常就是处理特定类型用户交互的View，常用的有button、switch、text field等。<br>除了使用View和Control来构建view层次结构来影响app外观之外，还可以使用Core Animation框架的Layer对象来渲染view外观和构建复杂的动画。</p>
<p>apppdelegate中的APP运行重要事件：<br>application:willFinishLaunchingWithOptions: - 这个方法是你在启动时的第一次机会来执行代码<br>application:didFinishLaunchingWithOptions: - 这个方法允许你在显示app给用户之前执行最后的初始化操作<br>applicationDidBecomeActive: - app已经切换到active状态后需要执行的操作<br>applicationWillResignActive: - app将要从前台切换到后台时需要执行的操作<br>applicationDidEnterBackground: - app已经进入后台后需要执行的操作<br>applicationWillEnterForeground: - app将要从后台切换到前台需要执行的操作，但app还不是active状态<br>applicationWillTerminate: - app将要结束时需要执行的操作</p>
<p><img src="http://ww3.sinaimg.cn/mw1024/bc254b75jw1f4vo55b1w3j20h60bvwfp.jpg" alt=""><br>相关的操作事件被系统生成并通过UIKit的指定端口分发。事件在内部排成队列，一个个的分发到Main run loop 去做处理。UIApplication对象是第一个接收到时间的对象，它决定事件如何被处理。触摸事件分发到主窗口，窗口再分发到对应出发触摸事件的View。其他的事件通过其他途径分发给其他对象变量做处理。</p>
<p>下面是appdeleate和viewcontroller的关系</p>
<p><img src="http://ww3.sinaimg.cn/mw1024/bc254b75jw1f4vop8bk54j20c30agaaj.jpg" alt=""></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/12/UIView简介和常用方法/" itemprop="url">
                  UIView简介和常用方法
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-06-12T13:55:40+08:00" content="2016-06-12">
              2016-06-12
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>UIView表示屏幕上的一块矩形区域，负责渲染区域的内容，并且响应该区域内发生的触摸事件。</p>
<p>继承关系：NSObject—UIResponder—UIView</p>
<p>屏幕上能够看见的都是UIView<br>每一个UIView都是容器</p>
<p>bounds的x,y永远为0(以自身左上角为原点)，frame的x,y以父视图的左上角为原点</p>
</blockquote>
<h3 id="常见属性"><a href="#常见属性" class="headerlink" title="常见属性"></a>常见属性</h3><p> @property frame<br> @property bounds<br> @property center<br> @property transform<br> @property alpha<br> @property backgroundColor<br> @property contentStretch</p>
<h3 id="UIView层的操作常用方法"><a href="#UIView层的操作常用方法" class="headerlink" title="UIView层的操作常用方法"></a>UIView层的操作常用方法</h3><p>(void)removeFromSuperview; // 从父视图中移除<br>(void)addSubview:(UIView <em>)view; // 添加一个子视图<br>(void)insertSubview:(UIView </em>)view belowSubview:(UIView <em>)slibingSubview; // 插入一个view到某个view的下层<br>(void)insertSubview:(UIView </em>)view aboveSubview:(UIView <em>)slibingSubview; // 插入一个view到某个view的上层<br>(void)insertSubview:(UIView </em>)view atIndex:(NSInteger)index; // 插入一个view到特定层<br>(void)bringSubviewToFront:(UIView <em>)view; // 将某个view放在最上层<br>(void)sendSubviewToBack:(UIView </em>)view; // 将某个view放在最下层<br>(BOOL)isDescendantOfView(UIView <em>)view; // 是否是某个视图的子孙视图<br>(void)exchangeSubviewAtIndex:(NSInteger)index1 withSubviewAtIndex:(NSInteger)index2; // 交换两个层的view<br>(UIView </em>)viewWithTag:(NSInteger)view; // 取到指定tag值的view</p>
<h3 id="UIView的加载过程"><a href="#UIView的加载过程" class="headerlink" title="UIView的加载过程"></a>UIView的加载过程</h3><p><img src="http://ww2.sinaimg.cn/mw1024/bc254b75jw1f4usac93ohj20mi0vsac7.jpg" alt="view"><br>我们可以知道如果是从 Storyboard 或 Nib 文件中加载 View Controller，我们都不要去重载 loadView，它会自动加载 view 属性以及它的各个 Subviews。只有当我们自己代码创建 View Controller 的时候，我们可能需要去重载 loadView。当然，如果我们不重载，那么默认情况下 loadView 会创建一个光秃秃的 UIView 对象赋给 view 属性。<br>loadView:先寻找有关可用的nib文件的信息，根据这个信息来加载nib文件，如果没有有关nib文件的信息，默认实现会创建一个空白的UIView对象，然后让这个对象成为controller的主view<br>首先访问view属性<br>如果存在view，加载。若不存在，则UIViewController调用loadView方法<br>loadView方法执行如下操作<br>如果覆盖了该方法，必须创建view给UIViewController的view属性<br>如果没有复写该方法，UIViewController会默认调用initWithNibName:bundle:方法初始化并加载view<br>通过viewDidLoad方法来执行一些其他任务</p>
<h3 id="UIViewController生命周期"><a href="#UIViewController生命周期" class="headerlink" title="UIViewController生命周期"></a>UIViewController生命周期</h3><p>(void)viewDidLoad; //视图加载完成<br>(void)viewWillAppear:(BOOL)animated; // 将要显示<br>(void)viewDidAppear:(BOOL)animated; // 显示完成<br>(void)viewWillDisappear:(BOOL)animated; // 将要移除<br>(void)viewDidDisappear:(BOOL)animated; // 已经移除<br>详细版本：</p>
<ol>
<li>-[ViewController initWithCoder:]或-[ViewController initWithNibName:Bundle]:首先从归档文件中加载UIViewController对象。即使是纯代码，也会把nil作为参数传给后者。<ol>
<li>-[UIView awakeFromNib]:作为第一个方法的助手，方便处理一些额外的设置。</li>
<li>-[ViewController loadView]:创建或加载一个view并把它赋值给UIViewController的view属性</li>
<li>-[ViewController viewDidLoad]:此时整个视图层次(view hierarchy)已经被放到内存中，可以移除一些视图，修改约束，加载数据等</li>
<li>-[ViewController viewWillAppear:]:视图加载完成，并即将显示在屏幕上,还没有设置动画，可以改变当前屏幕方向或状态栏的风格等。</li>
<li>-[ViewController viewWillLayoutSubviews]：即将开始子视图位置布局</li>
<li>-[ViewController viewDidLayoutSubviews]：用于通知视图的位置布局已经完成</li>
<li>-[ViewController viewDidAppear:]：视图已经展示在屏幕上，可以对视图做一些关于展示效果方面的修改。</li>
<li>-[ViewController viewWillDisappear:]：视图即将消失</li>
<li>-[ViewController viewDidDisappear:]：视图已经消失<br>如果考虑UIViewController可能在某个时刻释放整个view。那么再次加载视图时显然会从步骤3开始。因为此时的UIViewController对象依然存在。</li>
</ol>
</li>
</ol>
<h3 id="UIView、UIWindow、UIScreen、UIViewController-之间的层级关系"><a href="#UIView、UIWindow、UIScreen、UIViewController-之间的层级关系" class="headerlink" title="UIView、UIWindow、UIScreen、UIViewController 之间的层级关系"></a>UIView、UIWindow、UIScreen、UIViewController 之间的层级关系</h3><p><img src="http://ww1.sinaimg.cn/mw1024/bc254b75jw1f4usaaorkrj20y00i8gni.jpg" alt=""> </p>
<h3 id="UIView的bounds-frame和center属性"><a href="#UIView的bounds-frame和center属性" class="headerlink" title="UIView的bounds,frame和center属性"></a>UIView的bounds,frame和center属性</h3><p><img src="http://ww3.sinaimg.cn/mw1024/bc254b75jw1f4usab9jhfj20dk0abwf7.jpg" alt="bound"><br>看着上图，对照一下就很清楚了<br>View B’s bounds= ((0,0),(200,250))<br>View B’s frame= ((140,65),(320,320))<br>View B’s center= (300,225)</p>
<h3 id="常用方法收录"><a href="#常用方法收录" class="headerlink" title="常用方法收录"></a>常用方法收录</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">===获取指定的subViewfor(UIView *view in subviews)</span><br><span class="line">&#123;</span><br><span class="line">if(view.tag == 998)</span><br><span class="line">&#123;</span><br><span class="line">//根据tag判断</span><br><span class="line">&#125;</span><br><span class="line">if([view isKindOfClass:[UIImageView class]])</span><br><span class="line">&#123;</span><br><span class="line">//根据类型判断</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">===做一个与屏幕同等大小的UIView</span><br><span class="line">方法一：</span><br><span class="line"> #pragma mark - Setup</span><br><span class="line">- (void)setupUI &#123;</span><br><span class="line">// Use full screen layout.</span><br><span class="line">self.edgesForExtendedLayout = UIRectEdgeAll;</span><br><span class="line">self.automaticallyAdjustsScrollViewInsets = YES;</span><br><span class="line">self.extendedLayoutIncludesOpaqueBars = YES;</span><br><span class="line">self.view.backgroundColor = [UIColor whiteColor];</span><br><span class="line">// Title.</span><br><span class="line">self.title = @&quot;Detail&quot;;</span><br><span class="line">&#125;</span><br><span class="line">方法二：</span><br><span class="line">CGRect rect = [[UIScreen mainScreen] bounds];</span><br><span class="line">CGSize size = rect.size;</span><br><span class="line">CGFloat width = size.width;</span><br><span class="line">CGFloat height = size.height; </span><br><span class="line">CGRectMake(origin.x，origin.y，size.width. Size.height)在代码中定义矩形</span><br><span class="line">Frame:     该view在父view坐标系统中的位置和大小。（参照点是，父亲的坐标系统）</span><br><span class="line">bounds：该view在本地坐标系统中的位置和大小。   （参照点是，本地坐标系统，就相当于ViewB自己的坐标系统，以0,0点为起点）</span><br><span class="line">center： 该view的中心点在父view坐标系统中的位置和大小。（参照点是，父亲的坐标系统）</span><br><span class="line">===UIView添加UITableView      TestTableViewController *viewController = [[TestTableViewController alloc] init];</span><br><span class="line">      [self addChildViewController:viewController];</span><br><span class="line">      [self.view addSubview:viewController.view];</span><br><span class="line">      [viewController didMoveToParentViewController:self];</span><br><span class="line">      [如果不添加controller 则viewController 则不具备跳转等controller功能]</span><br><span class="line">===设置uiView的位置</span><br><span class="line">aView.frame = CGRectMake( 100, 200, aView.frame.size.width, aView.frame.size.height ); // set new position exactly</span><br><span class="line">===remove view from superView</span><br><span class="line"></span><br><span class="line">for (UIView* subView in [self.view.subviews])&#123;    if ([subView isKindOfClass:[ZeldaView class]])        [subView removeFromSuperview];&#125;===添加一条分割线</span><br><span class="line">UIView *navDividingLine = [[UIView alloc] initWithFrame:CGRectMake(0,159,self.view.bounds.size.width,1)];</span><br><span class="line">        navDividingLine.backgroundColor = [UIColor groupTableViewBackgroundColor];  //这个颜色就是默认表格线的颜色</span><br><span class="line">        [navDividingLine sizeToFit];</span><br><span class="line">        [self.view addSubview:navDividingLine];</span><br></pre></td></tr></table></figure>
<h3 id="UIView设置圆角"><a href="#UIView设置圆角" class="headerlink" title="UIView设置圆角"></a>UIView设置圆角</h3><p>UIView设置圆角<br>1、比较简单的情况，UIView四个角都是圆角：</p>
<pre><code>UIView *aView = [[UIView alloc] init];

aView.frame = CGRectMake(0, 0, 300, 200);
aView.backgroundColor = [UIColor redColor];

//设置圆角边框

aView.layer.cornerRadius = 8;

aView.layer.masksToBounds = YES;

//设置边框及边框颜色

aView.layer.borderWidth = 8;

aView.layer.borderColor =[ [UIColor grayColor] CGColor];

[self.view addSubview:aView];
</code></pre><p>2、设置四个角中的某个或者某几个为圆角</p>
<pre><code>UIView *aView = [[UIView alloc] init];

aView.frame = CGRectMake(0, 0, 300, 200);
aView.backgroundColor = [UIColor redColor];

[self.view addSubview:aView];

//设置所需的圆角位置以及大小
UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:aView.bounds byRoundingCorners:UIRectCornerBottomLeft | UIRectCornerBottomRight cornerRadii:CGSizeMake(10, 10)];
CAShapeLayer *maskLayer = [[CAShapeLayer alloc] init];
maskLayer.frame = aView.bounds;
maskLayer.path = maskPath.CGPath;
aView.layer.mask = maskLayer;
</code></pre><p>其中，UIRectCornerBottomLeft，UIRectCornerBottomRight是可以选择的角。</p>
<p>typedef NS_OPTIONS(NSUInteger, UIRectCorner) {<br>    UIRectCornerTopLeft     = 1 &lt;&lt; 0,<br>    UIRectCornerTopRight    = 1 &lt;&lt; 1,<br>    UIRectCornerBottomLeft  = 1 &lt;&lt; 2,<br>    UIRectCornerBottomRight = 1 &lt;&lt; 3,<br>    UIRectCornerAllCorners  = ~0UL<br>};</p>
<p>上面的枚举是可以供选择的角，分别是：“左上角”、“右上角”、“左下角”、“右下角”。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/06/iOS常用分类/" itemprop="url">
                  iOS常用分类
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-06-06T17:57:07+08:00" content="2016-06-06">
              2016-06-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>有一些分类在开发中经常应用，做一个收录。</p>
</blockquote>
<h3 id="UIView"><a href="#UIView" class="headerlink" title="UIView"></a>UIView</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">建立类别</span><br><span class="line">建立一个名为Layout的UIView类别，类别的代码如下：</span><br><span class="line">1. UIView+Layout.h</span><br><span class="line">.h 文件定义了 x, y, width, height 等方便读写的属性，代码如下：</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface UIView (Layout)</span><br><span class="line">@property (assign, nonatomic) CGFloat    top;@property (assign, nonatomic) CGFloat    bottom;@property (assign, nonatomic) CGFloat    left;@property (assign, nonatomic) CGFloat    right;</span><br><span class="line">@property (assign, nonatomic) CGFloat    x;@property (assign, nonatomic) CGFloat    y;@property (assign, nonatomic) CGPoint    origin;</span><br><span class="line">@property (assign, nonatomic) CGFloat    centerX;@property (assign, nonatomic) CGFloat    centerY;</span><br><span class="line">@property (assign, nonatomic) CGFloat    width;@property (assign, nonatomic) CGFloat    height;@property (assign, nonatomic) CGSize    size;</span><br><span class="line">@end</span><br><span class="line">2. UIView+Layout.m</span><br><span class="line">.m 文件实现各个属性的setter和getter方法，代码如下：</span><br><span class="line">#import &quot;UIView+Layout.h&quot;</span><br><span class="line">@implementation UIView (Layout)</span><br><span class="line">@dynamic top;@dynamic bottom;@dynamic left;@dynamic right;</span><br><span class="line">@dynamic width;@dynamic height;</span><br><span class="line">@dynamic size;</span><br><span class="line">@dynamic x;@dynamic y;</span><br><span class="line">- (CGFloat)top&#123;    return self.frame.origin.y;&#125;</span><br><span class="line">- (void)setTop:(CGFloat)top&#123;    CGRect frame = self.frame;    frame.origin.y = top;    self.frame = frame;&#125;</span><br><span class="line">- (CGFloat)left&#123;    return self.frame.origin.x;&#125;</span><br><span class="line">- (void)setLeft:(CGFloat)left&#123;    CGRect frame = self.frame;    frame.origin.x = left;    self.frame = frame;&#125;</span><br><span class="line">- (CGFloat)bottom&#123;    return self.frame.size.height + self.frame.origin.y;&#125;</span><br><span class="line">- (void)setBottom:(CGFloat)bottom&#123;    CGRect frame = self.frame;    frame.origin.y = bottom - frame.size.height;    self.frame = frame;&#125;</span><br><span class="line">- (CGFloat)right&#123;    return self.frame.size.width + self.frame.origin.x;&#125;</span><br><span class="line">- (void)setRight:(CGFloat)right&#123;    CGRect frame = self.frame;    frame.origin.x = right - frame.size.width;    self.frame = frame;&#125;</span><br><span class="line">- (CGFloat)x&#123;    return self.frame.origin.x;&#125;</span><br><span class="line">- (void)setX:(CGFloat)value&#123;    CGRect frame = self.frame;    frame.origin.x = value;    self.frame = frame;&#125;</span><br><span class="line">- (CGFloat)y&#123;    return self.frame.origin.y;&#125;</span><br><span class="line">- (void)setY:(CGFloat)value&#123;    CGRect frame = self.frame;    frame.origin.y = value;    self.frame = frame;&#125;</span><br><span class="line">- (CGPoint)origin&#123;    return self.frame.origin;&#125;</span><br><span class="line">- (void)setOrigin:(CGPoint)origin&#123;    CGRect frame = self.frame;    frame.origin = origin;    self.frame = frame;&#125;</span><br><span class="line">- (CGFloat)centerX&#123;    return self.center.x;&#125;</span><br><span class="line">- (void)setCenterX:(CGFloat)centerX&#123;    CGPoint center = self.center;    center.x = centerX;    self.center = center;&#125;</span><br><span class="line">- (CGFloat)centerY&#123;    return self.center.y;&#125;</span><br><span class="line">- (void)setCenterY:(CGFloat)centerY&#123;    CGPoint center = self.center;    center.y = centerY;    self.center = center;&#125;</span><br><span class="line">- (CGFloat)width&#123;    return self.frame.size.width;&#125;</span><br><span class="line">- (void)setWidth:(CGFloat)width&#123;    CGRect frame = self.frame;    frame.size.width = width;    self.frame = frame;&#125;</span><br><span class="line">- (CGFloat)height&#123;    return self.frame.size.height;&#125;</span><br><span class="line">- (void)setHeight:(CGFloat)height&#123;    CGRect frame = self.frame;    frame.size.height = height;    self.frame = frame;&#125;</span><br><span class="line">- (CGSize)size&#123;    return self.frame.size;&#125;</span><br><span class="line">- (void)setSize:(CGSize)size&#123;    CGRect frame = self.frame;    frame.size = size;    self.frame = frame;&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">二、使用</span><br><span class="line">类别创建完成以后，view的布局就显得轻松很多了</span><br><span class="line">例如原来你要修改y坐标时要这样写：</span><br><span class="line">view.frame = CGRectMake(view.frame.origin.x, 100, view.frame.size.width, view.frame.size.height);</span><br><span class="line">而现在只需要这样写：</span><br><span class="line">view.y = 100;</span><br></pre></td></tr></table></figure>
<h3 id="阿拉伯数字转化为汉语数字"><a href="#阿拉伯数字转化为汉语数字" class="headerlink" title="阿拉伯数字转化为汉语数字"></a>阿拉伯数字转化为汉语数字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">+(NSString *)translation:(NSString *)arebic</span><br><span class="line"></span><br><span class="line">&#123;   NSString *str = arebic;</span><br><span class="line">    NSArray *arabic_numerals = @[@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;,@&quot;7&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;0&quot;];</span><br><span class="line">    NSArray *chinese_numerals = @[@&quot;一&quot;,@&quot;二&quot;,@&quot;三&quot;,@&quot;四&quot;,@&quot;五&quot;,@&quot;六&quot;,@&quot;七&quot;,@&quot;八&quot;,@&quot;九&quot;,@&quot;零&quot;];</span><br><span class="line">    NSArray *digits = @[@&quot;个&quot;,@&quot;十&quot;,@&quot;百&quot;,@&quot;千&quot;,@&quot;万&quot;,@&quot;十&quot;,@&quot;百&quot;,@&quot;千&quot;,@&quot;亿&quot;,@&quot;十&quot;,@&quot;百&quot;,@&quot;千&quot;,@&quot;兆&quot;];</span><br><span class="line">    NSDictionary *dictionary = [NSDictionary dictionaryWithObjects:chinese_numerals forKeys:arabic_numerals];</span><br><span class="line"></span><br><span class="line">    NSMutableArray *sums = [NSMutableArray array];</span><br><span class="line">    for (int i = 0; i &lt; str.length; i ++) &#123;</span><br><span class="line">        NSString *substr = [str substringWithRange:NSMakeRange(i, 1)];</span><br><span class="line">        NSString *a = [dictionary objectForKey:substr];</span><br><span class="line">        NSString *b = digits[str.length -i-1];</span><br><span class="line">        NSString *sum = [a stringByAppendingString:b];</span><br><span class="line">        if ([a isEqualToString:chinese_numerals[9]])</span><br><span class="line">        &#123;</span><br><span class="line">            if([b isEqualToString:digits[4]] || [b isEqualToString:digits[8]])</span><br><span class="line">            &#123;</span><br><span class="line">                sum = b;</span><br><span class="line">                if ([[sums lastObject] isEqualToString:chinese_numerals[9]])</span><br><span class="line">                &#123;</span><br><span class="line">                    [sums removeLastObject];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else</span><br><span class="line">            &#123;</span><br><span class="line">                sum = chinese_numerals[9];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if ([[sums lastObject] isEqualToString:sum])</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [sums addObject:sum];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NSString *sumStr = [sums  componentsJoinedByString:@&quot;&quot;];</span><br><span class="line">    NSString *chinese = [sumStr substringToIndex:sumStr.length-1];</span><br><span class="line">    NSLog(@&quot;%@&quot;,str);</span><br><span class="line">    NSLog(@&quot;%@&quot;,chinese);</span><br><span class="line">    return chinese;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何把一张大图缩小为1-4大小的缩略图？"><a href="#如何把一张大图缩小为1-4大小的缩略图？" class="headerlink" title="如何把一张大图缩小为1/4大小的缩略图？"></a>如何把一张大图缩小为1/4大小的缩略图？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let data = UIImageJPEGRepresentation(image, 0.25)</span><br></pre></td></tr></table></figure>
<h3 id="十六进制的颜色值转换为UIColor"><a href="#十六进制的颜色值转换为UIColor" class="headerlink" title="十六进制的颜色值转换为UIColor"></a>十六进制的颜色值转换为UIColor</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">UIColor+Hex.h里面中</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface UIColor (Hex)+ (UIColor *) colorWithHexString: (NSString *)color;@end</span><br><span class="line"> </span><br><span class="line">UIColor+Hex.m里面中</span><br><span class="line"></span><br><span class="line">#import &quot;UIColor+Hex.h&quot;</span><br><span class="line">@implementation UIColor (Hex)</span><br><span class="line">#pragma mark - 颜色转换 iOS中十六进制的颜色转换为UIColor</span><br><span class="line">+ (UIColor *) colorWithHexString: (NSString *)hexString&#123;    NSString *cString = [[hexString stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]] uppercaseString];        //hexString应该6到8个字符    if ([cString length] &lt; 6) &#123;        return [UIColor clearColor];    &#125;        //如果hexString 有@&quot;0X&quot;前缀    if ([cString hasPrefix:@&quot;0X&quot;])        cString = [cString substringFromIndex:2];        //如果hexString 有@&quot;#&quot;&quot;前缀    if ([cString hasPrefix:@&quot;#&quot;])        cString = [cString substringFromIndex:1];    if ([cString length] != 6)        return [UIColor clearColor];        //RGB转换    NSRange range;    range.location = 0;    range.length = 2;        //R    NSString *rString = [cString substringWithRange:range];        //G    range.location = 2;    NSString *gString = [cString substringWithRange:range];        //B    range.location = 4;    NSString *bString = [cString substringWithRange:range];        //    unsigned int r, g, b;    [[NSScanner scannerWithString:rString] scanHexInt:&amp;r];    [[NSScanner scannerWithString:gString] scanHexInt:&amp;g];    [[NSScanner scannerWithString:bString] scanHexInt:&amp;b];        return [UIColor colorWithRed:((float) r / 255.0f) green:((float) g / 255.0f) blue:((float) b / 255.0f) alpha:1.0f];&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">使用方法：</span><br><span class="line">//1、添加头文件#import &quot;UIColor+Hex.h&quot;</span><br><span class="line">//2、在需要的地方 [UIColor colorWithHexString:@&quot;十六进制&quot;]//eg:[self.view setBackgroundColor:[UIColor colorWithHexString:@&quot;#11489B&quot;]];</span><br></pre></td></tr></table></figure>
<h3 id="UITextField实现对输入内容的限制"><a href="#UITextField实现对输入内容的限制" class="headerlink" title="UITextField实现对输入内容的限制"></a>UITextField实现对输入内容的限制</h3><pre><code>- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string
    {
        BOOL result = YES;
            // restrict the maximum number of characters to 5
            if (textField.text.length == 5 &amp;&amp; string.length &gt; 0)
                    result = NO;
            return result;
    }
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/06/iOS页面流/" itemprop="url">
                  iOS页面流
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-06-06T14:09:27+08:00" content="2016-06-06">
              2016-06-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>开始学iOS编程的时候对页面之间如何跳转，传值等问题一直没太闹清楚，用这篇文章整理一下，大部分内容转载自这位阿里大神的博客（<a href="http://www.samirchen.com/），个人能力有限，希望在不断的记录中踏实前进。" target="_blank" rel="external">http://www.samirchen.com/），个人能力有限，希望在不断的记录中踏实前进。</a></p>
</blockquote>
<h2 id="页面流"><a href="#页面流" class="headerlink" title="页面流"></a>页面流</h2><p><img src="http://ww2.sinaimg.cn/mw1024/bc254b75jw1f4usactd4rj20k20j4gns.jpg" alt="页面流"></p>
<p>一个手机上的app，通常会有多个页面，我们从页面A跳转到页面B，再从页面B跳到页面C，然后我们从页面C跳回到B，或者直接从页面C跳回到页面A，这些跳转，就是我们页面流的逻辑。看看上面的图，可以知道，我们这里主要讨论的是iOS中基于 Navigation方式 + Modal方式 的页面流逻辑。</p>
<p>那么什么是 Navigation式 的跳转？什么又是 Modal式 的跳转呢？</p>
<p>Navigation式 的跳转就是上图中蓝色的实线箭头所表示的跳转方式，它所推动的整个视图流就如同一个树状结构，非常清晰，多用于主干视图的展现。iOS 在管理它们时用到了 UINavigationController，其机制就如同栈一样。在图中所有被 Navigation式 地管理着的 View Controller 我都把背景标为了蓝色。</p>
<p>Modal式 的跳转就是上图中绿色的虚线箭头所表示的跳转方式，它多用于场景式的视图的展现，所以作为 Modal 跳转的目的 VC 通常是用于展示数据的视图或者功能性视图等等，这样的视图可能会在主干中的多种情况下被调用，就比如图中的 VCM1 被 VCN2 和 VCN3 都用到了。在我们实际使用中，通常拍照页面对应的VC就会被用作是Modal式的。在图中所有被 Modal式 地管理着的 View Controller 我都把背景标为了绿色。</p>
<h2 id="页面之间的跳转及传参（暂列出几种，剩下的会在以后逐步添加。）"><a href="#页面之间的跳转及传参（暂列出几种，剩下的会在以后逐步添加。）" class="headerlink" title="页面之间的跳转及传参（暂列出几种，剩下的会在以后逐步添加。）"></a>页面之间的跳转及传参（暂列出几种，剩下的会在以后逐步添加。）</h2><ul>
<li><h4 id="在设置根控制器的时候可以传参："><a href="#在设置根控制器的时候可以传参：" class="headerlink" title="在设置根控制器的时候可以传参："></a>在设置根控制器的时候可以传参：</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NavigationController的初始化</span><br><span class="line">在图中，我们的入口是先创建一个 UINavigationController，并把它的初始VC设置为 VCN1，同时可以在这里传参，代码如下：</span><br><span class="line"></span><br><span class="line">// 在 AppDelegate.m 中</span><br><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">	VCN1* vcn1 = [[VCN1 alloc] init];</span><br><span class="line">	vcn1.stringPara = @&quot;value&quot;; // 传参</span><br><span class="line">	UINavigationController* mainNavigationController = [[UINavigationController alloc] initWithRootViewController:vcn1];</span><br><span class="line">	[mainNavigationController setNavigationBarHidden:YES];</span><br><span class="line">	[self.window setRootViewController:mainNavigationController];</span><br><span class="line">	self.window.backgroundColor = [UIColor whiteColor];</span><br><span class="line">	[self.window makeKeyAndVisible];</span><br><span class="line">	return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="Navigation-Push-传参"><a href="#Navigation-Push-传参" class="headerlink" title="Navigation-Push 传参"></a>Navigation-Push 传参</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">在图中，蓝色实线正向的箭头就表示的是 Navigation 的 Push 动作，比如：VCN1-&gt;VCN2; VCN1-&gt;VCN3-&gt;VCN4; VCN5-&gt;VCN6; VCN5-&gt;VCN7-&gt;VCN8 等跳转。一般来说，我们都是一级一级往前Push的，不应该有 VCN1-&gt;VCN4 这样的正向跳跃式Push的需求，要不然图就不这样画了，页面流就不这样设计了。在Push动作中传参是非常简单直接的，因为你这里创建了你要跳达的VC，直接设置其参数属性就可以了。</span><br><span class="line"></span><br><span class="line">例如，VCN1-&gt;VCN2 的跳转代码</span><br><span class="line"></span><br><span class="line">// 在 VCN1.m 中</span><br><span class="line">-(void) goVCN2:(id)sender &#123;</span><br><span class="line">	VCN2* vcn2 = [[VCN2 alloc] init];</span><br><span class="line">	vcn2.stringPara = @&quot;value&quot;; // 传参</span><br><span class="line">	[self.navigationController pushViewController:vcn2 animated:YES]; // 这里的self.navigationController就是MainNavigationController。</span><br><span class="line">&#125;</span><br><span class="line">在做了以上Push后，VCN2 就会被压到由MainNavigationController管理的栈的栈顶。这个栈就是 self.navigationController.viewControllers。</span><br><span class="line"></span><br><span class="line">Push动作是很简单的，基本上所有的Push代码都类似上面这样写。</span><br><span class="line"></span><br><span class="line">以下为push传值的两个实例：</span><br><span class="line">实例一和实例二都是一个意思，主要是在.m中有可接收的属性，再用push的方式进行传值</span><br><span class="line"></span><br><span class="line">实例一：</span><br><span class="line">首先SecondViewController视图中需要有一个属性用来存储传递过来的值：</span><br><span class="line">@property(nonatomic,retain) NSString *firstValue ;//属性传值</span><br><span class="line"></span><br><span class="line">然后MainViewController视图需要引用SecondViewController视图的头文件，在视图中的按钮点击事件中，通过SecondViewController的对象将需要传递的值存在firstValue中:</span><br><span class="line">(void)buttonAction:(UIButton *)button</span><br><span class="line">&#123;</span><br><span class="line">SecondViewController *second = </span><br><span class="line">[[SecondViewController alloc]init];//用下一个视图的属性接受想要传过去的值,属性传值</span><br><span class="line">second.firstValue = _txtFiled.text;</span><br><span class="line">[self.navigationController pushViewController:second animated:YES];</span><br><span class="line">&#125;</span><br><span class="line">页面跳转之后，就能在SecondViewController视图中，通过存值的属性，取用刚才传递过来的值：</span><br><span class="line">//显示传过来的值[_txtFiled setText:_firstValue];</span><br><span class="line"></span><br><span class="line">实例二：</span><br><span class="line">属性传值 将A页面所拥有的信息通过属性传递到B页面使用</span><br><span class="line">B页面定义了一个naviTitle属性，在A页面中直接通过属性赋值将A页面中的值传到B页面。</span><br><span class="line"></span><br><span class="line">A页面DetailViewController.h文件</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#import &quot;DetailViewController.h&quot;</span><br><span class="line">@interface RootViewController :UIViewController&lt;ChangeDelegate&gt;</span><br><span class="line">&#123;</span><br><span class="line">    UITextField *tf;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">A RootViewController.m页面实现文件</span><br><span class="line">#import &quot;RootViewController.h&quot;</span><br><span class="line">#import &quot;DetailViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface RootViewController ()</span><br><span class="line">@end</span><br><span class="line">@implementation RootViewController</span><br><span class="line">//核心代码</span><br><span class="line">-(void)loadView</span><br><span class="line">&#123;</span><br><span class="line">    UIButton *btn = [UIButton buttonWithType:UIButtonTypeRoundedRect];</span><br><span class="line">    btn.frame = CGRectMake(0, 0, 100, 30);</span><br><span class="line">    [btn setTitle:@&quot;Push&quot; forState:0];</span><br><span class="line">    [btn addTarget:self action:@selector(pushAction:) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">    [self.view addSubview:btn];</span><br><span class="line">&#125;</span><br><span class="line">-(void)pushAction:(id)sender</span><br><span class="line">&#123;</span><br><span class="line">    tf = (UITextField *)[self.viewviewWithTag:1000];</span><br><span class="line">    //导航push到下一个页面</span><br><span class="line">    //pushViewController 入栈引用计数+1，且控制权归系统</span><br><span class="line">    </span><br><span class="line">    DetailViewController *detailViewController = [[DetailViewControlleralloc]init];</span><br><span class="line">    //属性传值，直接属性赋值</span><br><span class="line">    detailViewController.naviTitle =tf.text;</span><br><span class="line">    //导航push到下一个页面</span><br><span class="line">    [self.navigationControllerpushViewController:detailViewController animated:YES];</span><br><span class="line">    [detailViewControllerrelease];   </span><br><span class="line">&#125;</span><br><span class="line">B页面DetailViewController.h文件</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@interface DetailViewController :UIViewController</span><br><span class="line">&#123;</span><br><span class="line">   UITextField *textField;</span><br><span class="line">   NSString *_naviTitle;</span><br><span class="line">&#125;</span><br><span class="line">@property(nonatomic,retain)NSString *naviTitle;</span><br><span class="line">@end</span><br><span class="line">B页面.m实现文件</span><br><span class="line">#import &quot;DetailViewController.h&quot;</span><br><span class="line">@interface DetailViewController ()</span><br><span class="line">@end</span><br><span class="line">@implementation DetailViewController</span><br><span class="line">@synthesize naviTitle =_naviTitle;</span><br><span class="line">-(void)loadView</span><br><span class="line">&#123;</span><br><span class="line">    self.view = [[[UIViewalloc]initWithFrame:CGRectMake(0,0, 320,480)]autorelease];</span><br><span class="line">   self.title = self.naviTitle ;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h4 id="Navigation-Pop-传参"><a href="#Navigation-Pop-传参" class="headerlink" title="Navigation-Pop 传参"></a>Navigation-Pop 传参</h4></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">在图中，蓝色实线反向的箭头就表示的是 Navigation 的 Pop 动作，比如：VCN2-&gt;VCN1; VCN4-&gt;VCN3 等跳转，Pop的跳转需求相对Push就复杂一点了，因为我们还可能有类似 VCN4-&gt;VCN1; VCN8-&gt;VCN5 这样的反向跳跃式Pop的需求，这种需求是合理的。比如：我们由“设置页面”进入“登陆页面”，由“登陆页面”进入“注册页面”，等注册完成了，我们想从“注册页面”直接跳回“登陆页面”这是合理的。所以这里Pop动作就分为：</span><br><span class="line"></span><br><span class="line">1）逐级Pop</span><br><span class="line">逐级Pop是很简单，但是要往回传参就没Push那样方便了，你需要去 self.navigationController.viewControllers 中去找到你要跳达的VC，然后设置其参数。例如，VCN2-&gt;VCN1 的跳转代码</span><br><span class="line"></span><br><span class="line">// 在 VCN2.m 中</span><br><span class="line">-(void) back:(id)sender &#123;</span><br><span class="line">    NSInteger *preVCIndex = self.navigationController.viewControllers.count - 2;</span><br><span class="line">    if (preVCIndex &gt;= 0) &#123;</span><br><span class="line">        UIViewController *preVC = [self.navigationController.viewControllers objectAtIndex:preVCIndex];</span><br><span class="line">        if ([preVC isKindOfClass:[VCN1 class]]) &#123;</span><br><span class="line">        	VCN1* vcn1 = (VCN1*) preVC;</span><br><span class="line">        	vcn1.stringPara = @&quot;value&quot;; // 传参</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	[self.navigationController popViewControllerAnimated:YES];</span><br><span class="line">&#125;</span><br><span class="line">做了以上的Pop后，VCN2 就会被弹出由MainNavigationController管理的栈。</span><br><span class="line"></span><br><span class="line">2）跳跃式Pop</span><br><span class="line">要完成跳跃式Pop，可以去遍历 self.navigationController.viewControllers 找到你想跳达的页面，然后Pop过去就可以了，传参也在这时设置即可。例如，VCN4-&gt;VCN1 的跳转代码</span><br><span class="line"></span><br><span class="line">// 在 VCN4.m 中</span><br><span class="line">-(void) backToVCN1:(id)sender &#123;</span><br><span class="line">	// 这里要稍微复杂一点</span><br><span class="line">	for (UIViewController* vc in self.navigationController.viewControllers) &#123;</span><br><span class="line">    	if ([vc isKindOfClass:[VCN1 class]]) &#123;</span><br><span class="line">    		vcn1.stringPara = @&quot;value&quot;; // 传参</span><br><span class="line">        	[self.navigationController popToViewController:vc animated:YES];</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">做了以上的跳跃式Pop后，self.navigationController.viewControllers 这个栈中所有在 VCN1 上面的 VC 都会被弹出。通过这种方式，可以跳到栈中任意的页面。</span><br><span class="line"></span><br><span class="line">如果你想直接回到栈底，比如在我们的图中 VCN4-&gt;VCN1 就是回到栈底的情况，你还可以这样做：</span><br><span class="line"></span><br><span class="line">// 在 VCN4.m 中</span><br><span class="line">-(void) backToVCN1:(id)sender &#123;</span><br><span class="line">	if ([[self.navigationController.viewControllers firstObject] isKindOfClass:[VCN1 class]]) &#123;</span><br><span class="line">    	VCN1* vcn1 = (VCN1*) [self.navigationController.viewControllers firstObject];</span><br><span class="line">    	vcn1.stringPara = @&quot;value&quot;; // 传参</span><br><span class="line">	&#125;</span><br><span class="line">	[self.navigationController popToRootViewControllerAnimated:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h5 id="Modal-Present"><a href="#Modal-Present" class="headerlink" title="Modal-Present"></a>Modal-Present</h5></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">在图中，绿色虚线正向的箭头就表示的是 Modal 的 Present 动作，比如：VCN2-&gt;VCM1; VCM1-&gt;VCM2; VCN4-&gt;VCN5; VCN6-&gt;VCM3 等跳转。Present 也是一级一级往前的。在Present动作中传参，也跟Push类似，因为在这里你要创建你想要展示的页面，这时候设置其参数属性即可。但是在我们的图中出现了几种不同Present的情况：</span><br><span class="line"></span><br><span class="line">1）Navigation页面流中的某个页面Present一个Modal的页面</span><br><span class="line">例如，VCN2-&gt;VCM1 的跳转代码：</span><br><span class="line"></span><br><span class="line">// 在 VCN2.m 中</span><br><span class="line">-(void) goVCM1:(id)sender &#123;</span><br><span class="line">	VCM1* vcm1 = [[VCM1 alloc] init];</span><br><span class="line">	[vcm1 setModalTransitionStyle:UIModalTransitionStyleCoverVertical];</span><br><span class="line">	vcm1.stringPara = @&quot;value&quot;; // 传参</span><br><span class="line">	[self.navigationController presentViewController:vcm1 animated:YES completion:nil]; // Present modal vc, not pop. 这里用 self.navigationController present 和 用 self present 的效果都是一样的。但是倾向与用前者，后面说明为什么。</span><br><span class="line">&#125;</span><br><span class="line">2）一个Modal的页面Present另一个Modal的页面</span><br><span class="line">例如，VCM1-&gt;VCM2 的跳转代码：</span><br><span class="line"></span><br><span class="line">// 在 VCM1.m 中</span><br><span class="line">-(void) goVCM2:(id)sender &#123;</span><br><span class="line">	VCM2* vcm2 = [[VCM2 alloc] init];</span><br><span class="line">	[vcm2 setModalTransitionStyle:UIModalTransitionStyleCoverVertical];</span><br><span class="line">	vcm2.stringPara = @&quot;value&quot;; // 传参</span><br><span class="line">	[self presentViewController:vcm2 animated:YES completion:nil]; // Present modal vc, not pop. 这里只能用 self present 了。</span><br><span class="line">&#125;</span><br><span class="line">3）一个Navigation页面流中的某个页面Present另一个Navigation页面流</span><br><span class="line">这个过程其实就是再创建一个UINavigationController，指定它的 root vc，然后 Present 出来即可，但是注意这里Present的是这个新创建的 UINavigationController。</span><br><span class="line"></span><br><span class="line">例如，VCN4-&gt;SubNavigationVC.VCN5 的跳转代码：</span><br><span class="line"></span><br><span class="line">// 在 VCN4.m 中</span><br><span class="line">-(void) goSubNavigationVC:(id)sender &#123;</span><br><span class="line">	VCN5* vcn5 = [[VCN5 alloc] init]; // 这个是 subNavigationController 的 root vc。</span><br><span class="line">	vcn5.stringPara = @&quot;value&quot;; // 传参</span><br><span class="line">	UINavigationController* subNavigationController = [[UINavigationController alloc] initWithRootViewController:vcn5];</span><br><span class="line">	subNavigationController.navigationBarHidden = YES;</span><br><span class="line">	[self.navigationController presentViewController:subNavigationController animated:YES completion:nil]; // 这里 present 的是 subNavigationController。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h5 id="Modal-Dismiss"><a href="#Modal-Dismiss" class="headerlink" title="Modal-Dismiss"></a>Modal-Dismiss</h5></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">这种情况稍复杂，现在很多利用block回传待添加。</span><br><span class="line"></span><br><span class="line">在图中，绿色虚线反向的箭头就表示的是 Modal 的 Dismiss 动作，比如：VCM1-&gt;VCN2; VCM2-&gt;VCM1; VCM3-&gt;VCN6 等跳转。Dismiss 这个动作其实写起来是很简单的，但是想要往回传参通常就会复杂一点了，尤其是在不同的情况下。这里的关键点就在于搞清楚当前所在VC的 presentingViewController 这个属性到底指向着谁。</span><br><span class="line"></span><br><span class="line">也就是说，当前的VC1如果是被另一个VC2给Present出来的，那么VC1中self.presentingViewController就是VC2。如果当前的VC1不是被谁Present出来的，但是VC1的某个祖先VC是被另一个VC给Present出来的，那么VC1中self.presentingViewController就是Present当前这个VC1的最近的祖先的那个VC。</span><br><span class="line"></span><br><span class="line">那么下面，我们就根据self.presentingViewController这个属性含义，结合我们图中的几种情况做一下具体的说明：</span><br><span class="line"></span><br><span class="line">1）Navigation页面流中的某个页面Present一个Modal的页面后Dismiss</span><br><span class="line">在 VCM1-&gt;VCN2 这种情况下，在VCM1中，self.presentingViewController是谁呢？一般，我们会认为是 VCN2，但事实上不是VCN2 而是 MainNavigationVC，这是很容易弄错的地方。所以这里想要传参回去的话，就要去 MainNavigationVC 的 viewContollers 栈中找到 VCN2，设置其参数属性。这里就要提到我们在上面介绍 Modal-Present 的时候提到的 VCN2-&gt;VCM1 的跳转代码，在那段代码里我们是用 self.navigationController present...，其实这里不管用 self.navigationController present... 还是用 self present...，到VCM1后，VCM1的presentingViewController都是MainNavigationVC，所以我们选择写清楚点，用前者。</span><br><span class="line"></span><br><span class="line">2）一个Modal的页面Present另一个Modal的页面后Dismiss</span><br><span class="line">在 VCM2-&gt;VCM1 这种情况下，VCM1是被VCM2Present出来的，所以VCM2 的 presentingViewController 就是 VCM1，所以跳转代码如下：</span><br><span class="line"></span><br><span class="line">// 在 VCM2.m 中</span><br><span class="line">-(void) back:(id)sender &#123;</span><br><span class="line">	if ([self.presentingViewController isKindOfClass:[VCM1 class]]) &#123;</span><br><span class="line">		VCM1* vcm1 = (VCM1*) [self.presentingViewController isKindOfClass:[VCM1 class]];</span><br><span class="line">		vcm1.stringPara = @&quot;value&quot;; // 传参</span><br><span class="line">	&#125;</span><br><span class="line">	[self.presentingViewController dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">&#125;</span><br><span class="line">如果我们Present了多层的Modal式VC，而我们想直接跳跃式地Dismiss返回，比如：VCM4-&gt;VCM1 这种情况，VCM4 的 presentingViewController 是 VCM2，而 VCM2 的 presentingViewController 是 VCM1，所以 VCM4-&gt;VCM1 的跳转代码：</span><br><span class="line"></span><br><span class="line">// 在 VCM4.m 中</span><br><span class="line">-(void) backToVCM1:(id)sender &#123;</span><br><span class="line">	if ([self.presentingViewController.presentingViewController isKindOfClass:[VCM1 class]]) &#123;</span><br><span class="line">		VCM1* vcm1 = (VCM1*) [self.presentingViewController.presentingViewController isKindOfClass:[VCM1 class]];</span><br><span class="line">		vcm1.stringPara = @&quot;value&quot;; // 传参</span><br><span class="line">	&#125;</span><br><span class="line">	[self.presentingViewController.presentingViewController dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">&#125;</span><br><span class="line">这样写其实是比较不美观的，尤其是当层次更多更深的时候，如果真有那种情况，那就建议把多层次的Modal式页面流直接改成Navigation式管理更好。</span><br><span class="line"></span><br><span class="line">3）一个Navigation页面流中的某个页面Present另一个Navigation页面流后Dismiss</span><br><span class="line">在 SubNavigationVC.VCN5-&gt;VCN4 的情况下，VCN5 其实不是被谁Present出来的，但是它的父VC(self.parentViewController)是SubNavigationVC，而SubNavigationVC是被MainNavigationVC给Prsent出来的，所以VCN5的presentingViewController就是MainNavigationVC。</span><br><span class="line"></span><br><span class="line">SubNavigationVC.VCN5-&gt;VCN4 的跳转代码：</span><br><span class="line"></span><br><span class="line">// 在 VCN5.m 中</span><br><span class="line">-(void) back:(id)sender &#123;</span><br><span class="line">	// self.presentingViewController是MainNavigationVC</span><br><span class="line">	if ([self.presentingViewController isKindOfClass:[UINavigationController class]]) &#123;</span><br><span class="line">    	UINavigationController* mainNavigationController = (UINavigationController*) self.presentingViewController;</span><br><span class="line">    	if ([[mainNavigationController.viewControllers lastObject] isKindOfClass:[VCN4 class]]) &#123;</span><br><span class="line">        	VCN4* vcn4 = (VCN4*) [mainNavigationController.viewControllers lastObject];</span><br><span class="line">        	vcn4.stringPara = @&quot;value&quot;; // 传参</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	[self.presentingViewController dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line">&#125;</span><br><span class="line">其实所有由SubNavigationVC管理的这些VC(包括VCN5，VCN6，VCN7，VCN8)的presentingViewController都是MainNavigationVC。所以我们可以直接从这些VC中任意一个直接跳到MainNavigationVC的栈顶的VCN4页面。</span><br></pre></td></tr></table></figure>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">===Navigation方式+Modal方式 的页面流逻辑其实已经能够满足我们大多时候的使用场景，如果你发现仍然不能满足，那建议首先考虑考虑项目的视图流的设计是不是合理。</span><br><span class="line">Navigation式的跳转只要牢牢盯住所在 VC 的 self.navigationController，理解其像栈一样管理页面流的方式，然后好好使用 self.navigationController.viewControllers 这个 VC栈 就好了。</span><br><span class="line">Modal式的跳转只要牢牢盯住所在 VC 的 self.presentingViewController 就好了，一定要搞清楚它是哪个，这里是很容易弄混而造成代码逻辑错误的。从Navigation页面流Present出来的Modal页面，这个Modal页面的presentingViewController是对应的的UINavigationController，而不是其中的那个具体的页面。</span><br><span class="line"></span><br><span class="line">===关于基于Storyboard来实现页面跳转和传参的方式多是基于Segue来实现的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">===DismissViewController</span><br><span class="line">这个是控制页面消失的方法，调用方法当前页面消失，适用于presentViewController的反操作。需求是连续dismiss两次回到最开始的页面。方法：[self dismissViewControllerAnimated:YES completion:^&#123;[self.navigationController popViewControllerAnimated:NO]&#125;];在回调的逻辑中填写你自己需要的跳转方法就可以了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">====页面PopViewController的回退调用block</span><br><span class="line">这种回调的block是跟随着动画的，在uitableView中实验了，对于重新加载数据不好用，但是对于一般的回退，很有用[CATransaction begin];[CATransaction setCompletionBlock:^&#123;    // handle completion here&#125;];</span><br><span class="line">[self.navigationController popViewControllerAnimated:YES];</span><br><span class="line">[CATransaction commit];</span><br><span class="line"></span><br><span class="line">自己研究的方法是，在pop之前给一个全局变量赋值，然后在新的页面viewWillAppear()中，进行判断然后书写相应逻辑进行刷新等操作。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">===StoryBoard使用segue页面间传递数据:</span><br><span class="line"></span><br><span class="line">- (void) prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender</span><br><span class="line">&#123;</span><br><span class="line">    if ([segue.identifier isEqualToString:@&quot;SubLevelSegue&quot;]) &#123;</span><br><span class="line">        SubLevelViewController *mySubLevelViewController = segue.destinationViewController;</span><br><span class="line">        UITableViewCell *cell = sender;</span><br><span class="line">        mySubLevelViewController.title = cell.textLabel.text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123;     UIViewController *destination = segue.destinationViewController;       if ([destination respondsToSelector:@selector(setDelegate:)]) &#123;            [destination setValue:self forKey:@&quot;delegate&quot;];        &#125;        if ([destination respondsToSelector:@selector(setSelection:)]) &#123;            // prepare selection info          NSIndexPath *indexPath = [self.tableView indexPathForCell:sender];                   id object = self.tasks[indexPath.row];                NSDictionary *selection = @&#123;   @&quot;indexPath&quot; : indexPath,   @&quot;object&quot; : object&#125;;            [destination setValue:selection forKey:@&quot;selection&quot;];    &#125; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">===iOS PresentViewControlle后,直接返回根视图</span><br><span class="line">在开发中：用[self presentViewController:VC animated:YES completion:nil];实现跳转，多次跳转后，直接返回第一个。</span><br><span class="line">例如：</span><br><span class="line">A presentViewController B</span><br><span class="line">B presentViewController C</span><br><span class="line">C 直接回到A：</span><br><span class="line"> </span><br><span class="line">返回第一个视图核心代码如下：</span><br><span class="line">[self.presentingViewController.presentingViewController dismissViewControllerAnimated:YES completion:nil];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">===关于几种逆向传值的方法接下来会补充：</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/06/iOS开发中的几种设计模式/" itemprop="url">
                  iOS开发中的几种设计模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Veröffentlicht am</span>
            <time itemprop="dateCreated" datetime="2016-06-06T11:48:22+08:00" content="2016-06-06">
              2016-06-06
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">in</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>收录几种常见设计模式的使用方法</p>
</blockquote>
<h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">单例就是全局都只有一个对象存在，而且是在整个App运行过程中都存在。每个App都会有单例，比如UIApplication。而我们在做用户数据存储时，通常都会用单例存储，因为应用在所有操作中，经常要求先登录。</span><br><span class="line"></span><br><span class="line">单例模式的要点：</span><br><span class="line">一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。</span><br><span class="line"></span><br><span class="line">下面这种写法是最常用的写法，这个是线程安全的。 </span><br><span class="line">dispach_once函数中的代码块只会被执行一次。+(SchoolManager *)sharedInstance  </span><br><span class="line">&#123;  </span><br><span class="line">    static SchoolManager *sharedManager;  </span><br><span class="line">      </span><br><span class="line">    static dispatch_once_t onceToken;  </span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;  </span><br><span class="line">        sharedManager = [[SchoolManager alloc] init];  </span><br><span class="line">    &#125;);  </span><br><span class="line">      </span><br><span class="line">    return sharedManager;  </span><br><span class="line">&#125;  </span><br><span class="line">获取实例：SchoolManager *schoolManager = [SchoolManager sharedInstance];  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">===单例模式的实现：</span><br><span class="line">代码示例：</span><br><span class="line">MySingletonClass.h</span><br><span class="line"></span><br><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">@interface MySingletonClass : NSObject//单例方法</span><br><span class="line">+(MySingletonClass *)sharedInstance;</span><br><span class="line">@end</span><br><span class="line">MySingletonClass.m</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">#import &quot;MySingletonClass.h&quot;</span><br><span class="line">@implementation MySingletonClass</span><br><span class="line">//1、为单例对象实现一个静态实例，并初始化，然后设置成nil，static MySingletonClass *manager = nil;</span><br><span class="line">//2、实现一个实例构造方法检查上面声明的静态实例是否为nil，如果是则新建并返回一个本类的实例，+(MySingletonClass *)sharedInstance&#123;        @synchronized(self) &#123;        if(manager == nil) &#123;            manager = [[MySingletonClass  alloc] init]; //   assignment   not   done   here        &#125;    &#125;    return manager;&#125;</span><br><span class="line">//3、重写allocWithZone方法，用来保证其他人直接使用alloc和init试图获得一个新实力的时候不产生一个新实例，+(id)allocWithZone:(NSZone *)zone&#123;    @synchronized(self)&#123;                if (!manager) &#123;                        manager = [super allocWithZone:zone]; //确保使用同一块内存地址                        return manager;                    &#125;                return nil;    &#125;&#125;</span><br><span class="line">//4、适当实现copyWithZone，release和autorelease。- (id)init;&#123;    @synchronized(self) &#123;                if (self = [super init])&#123;                        return self;        &#125;                return nil;    &#125;&#125;</span><br><span class="line">//确保copy对象也是唯一- (id)copyWithZone:(NSZone *)zone;&#123;        return self;    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="委托模式"><a href="#委托模式" class="headerlink" title="委托模式"></a>委托模式</h3><p>转载自 :<a href="http://www.samirchen.com/ios-delegate/" target="_blank" rel="external">这里</a></p>
<ul>
<li>介绍：delegation，委托模式，是简单的强大的模式，可让一个对象扮演另外对象的行为。委托对象保持到另外对象的引用，并在适当的时候发消息给另外对象。委托对象可以在发送消息的时候做一些额外的事情。<br>在cocoa框架中的委托模式，委托对象往往是框架中的对象，被委托对象是自定义的controller对象。委托对象保持一个到被委托对象的弱引用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">2.1）代码：CPPropOperationView.h</span><br><span class="line"></span><br><span class="line">在这里定义了 CPPropOperationViewDelegate，它有两个 required 的方法 refreshPropOperationView: 和 closePropOperationView: ，所有实现这个 CPPropOperationViewDelegate 的类需要去实现这两个方法。</span><br><span class="line"></span><br><span class="line">接着，声明了 CPPropOperationView 这个类的一些属性，其中包括 id delegate。</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line"> </span><br><span class="line">#pragma mark - delegate</span><br><span class="line">@protocol CPPropOperationViewDelegate &lt;NSObject&gt;</span><br><span class="line">@required</span><br><span class="line">-(void) refreshPropOperationView:(id)sender;</span><br><span class="line">-(void) closePropOperationView:(id)sender; </span><br><span class="line">@end</span><br><span class="line"> </span><br><span class="line">#pragma mark - class</span><br><span class="line">@interface CPPropOperationView : UIView &#123;</span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic, assign) id&lt;CPPropOperationViewDelegate&gt; delegate;</span><br><span class="line">@property (nonatomic, retain) UIImageView* backgroundImageView;</span><br><span class="line">@property (nonatomic, retain) UIButton* refreshBtn;</span><br><span class="line">@property (nonatomic, retain) UIButton* closeBtn;</span><br><span class="line">@end</span><br><span class="line">2.2）代码：CPPropOperationView.m</span><br><span class="line"></span><br><span class="line">这里是对 CPPropOperationView 页面元素的一些实现代码。可以看到，我们在给 CPPropOperationView 的两个按钮 refreshBtn 和 closeBtn 绑定方法的时候，addTarget: 的对象是 delegate，这说明我们将用代理调用这些按钮对应的方法。</span><br><span class="line"></span><br><span class="line">#import &quot;CPPropOperationView.h&quot;</span><br><span class="line"> </span><br><span class="line">@implementation CPPropOperationView</span><br><span class="line">@synthesize delegate;</span><br><span class="line">@synthesize backgroundImageView = _backgroundImageView;</span><br><span class="line">@synthesize refreshBtn = _refreshBtn;</span><br><span class="line">@synthesize closeBtn = _closeBtn;</span><br><span class="line"> </span><br><span class="line">#pragma mark - View Life Cycle</span><br><span class="line">- (id)initWithFrame:(CGRect)frame &#123;</span><br><span class="line">    self = [super initWithFrame:frame];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        // Initialization code       </span><br><span class="line">        </span><br><span class="line">        // background image.</span><br><span class="line">        self.backgroundImageView = [[[UIImageView alloc] initWithImage:[UIImage imageNamed:@&quot;bg.png&quot;]] autorelease];</span><br><span class="line">        [self.backgroundImageView setFrame:CGRectMake(0, 0, frame.size.width, frame.size.height)];</span><br><span class="line">        [self addSubview:self.backgroundImageView];</span><br><span class="line">         </span><br><span class="line">        // Refresh button. Bind to delegate&apos;s refreshPropOperationView:.</span><br><span class="line">        self.refreshBtn = [UIButton buttonWithType:UIButtonTypeCustom];</span><br><span class="line">        [self.refreshBtn setFrame:CGRectMake(0, 0, 225, 45)];</span><br><span class="line">        [self.refreshBtn setTitle:@&quot;Refresh 0&quot; forState:UIControlStateNormal];</span><br><span class="line">        [self.refreshBtn addTarget:delegate action:@selector(refreshPropOperationView:) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">        [self addSubview:self.refreshBtn];</span><br><span class="line">        </span><br><span class="line">        // Prop close button. Bind to delegate&apos;s closePropOperationView:.</span><br><span class="line">        self.closeBtn = [UIButton buttonWithType:UIButtonTypeCustom];</span><br><span class="line">        [self.closeBtn setFrame:CGRectMake(0, 100, 45, 45)];</span><br><span class="line">        [self.closeBtn setImage:[UIImage imageNamed:@&quot;close.png&quot;] forState:UIControlStateNormal];</span><br><span class="line">        [self.closeBtn addTarget:delegate action:@selector(closePropOperationView:) forControlEvents:UIControlEventTouchUpInside];</span><br><span class="line">        [self addSubview:self.closeBtn];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">-(void) dealloc &#123;</span><br><span class="line">    [_backgroundImageView release];</span><br><span class="line">    [_refreshBtn release];</span><br><span class="line">    [_closeBtn release];</span><br><span class="line">    </span><br><span class="line">    [super dealloc];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@end</span><br><span class="line">2.3）代码：StoreViewCtrler.h StoreViewCtrler 拥有 CPPropOperationView 的实例，并实现 CPPropOperationViewDelegate。</span><br><span class="line"></span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#import &quot;CPPropOperationView.h&quot;</span><br><span class="line"> </span><br><span class="line">@interface StoreViewCtrler : UIViewController &lt;CPPropOperationViewDelegate&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line">@property (nonatomic, retain) CPPropOperationView* propOperationView;</span><br><span class="line">@end</span><br><span class="line">2.4）代码：StoreViewCtrler.m</span><br><span class="line"></span><br><span class="line">在这里，实现了 CPPropOperationViewDelegate 的 refreshPropOperationView: 和 closePropOperationView: 这两个方法。并通过 self.propOperationView.delegate = self; 将代理设为自己。那么点击 self.propOperationView 的 refreshBtn 和 closeBtn 将分别调用这里实现的 refreshPropOperationView: 和 closePropOperationView: 这两个方法。</span><br><span class="line"></span><br><span class="line">#import &quot;StoreViewCtrler.h&quot;</span><br><span class="line">#import &quot;CPPropOperationView.h&quot;</span><br><span class="line"> </span><br><span class="line">@implementation StoreViewCtrler</span><br><span class="line">@synthesize magiboxOperationView;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#pragma mark - CPPropOperationViewDelegate </span><br><span class="line">-(void) refreshPropOperationView:(id)sender &#123; </span><br><span class="line">     self.backgroundImageView.image = [UIImage imageNamed:@&quot;bg2.png&quot;];</span><br><span class="line">     [self.propOperationView.refreshBtn setTitle:[NSString stringWithFormat:@&quot;Refresh 1&quot;] forState:UIControlStateNormal]; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">-(void) closePropOperationView:(id)sender &#123;</span><br><span class="line">     self.propOperationView.hidden = YES;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">#pragma mark - View lifecycle </span><br><span class="line">-(void) viewWillAppear:(BOOL)animated &#123;</span><br><span class="line">    [super viewWillAppear:animated];</span><br><span class="line">     </span><br><span class="line">    if (self.propOperationView == nil) &#123;</span><br><span class="line">        self.propOperationView = [[[CPPropOperationView alloc] initWithFrame:CGRectMake(0, 0, 300, 300)] autorelease];</span><br><span class="line">        self.propOperationView.delegate = self;</span><br><span class="line">        [self.view addSubview:self.propOperationView];</span><br><span class="line">    &#125;</span><br><span class="line">    self.propOperationView.hidden = NO;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">- (void)viewDidUnload &#123;</span><br><span class="line">    [super viewDidUnload];</span><br><span class="line">    </span><br><span class="line">    // Release any retained subviews of the main view.</span><br><span class="line">    self.magiboxOperationView = nil;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">-(void) dealloc &#123;</span><br><span class="line">    [magiboxOperationView release];</span><br><span class="line">    </span><br><span class="line">    [super dealloc];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="" />
          <p class="site-author-name" itemprop="name"></p>
          <p class="site-description motion-element" itemprop="description">coder-gwb</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">16</span>
              <span class="site-state-item-name">Artikel</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">Kategorien</span>
              
            </div>
          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>

<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  
  

  

  

</body>
</html>
